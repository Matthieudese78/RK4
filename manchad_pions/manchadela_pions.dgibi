Opti dime 3 ; 
Opti impi 555 ; 
OPTI 'MODE' 'TRID' ;
opti elem CUB8 ;
*
opti 'TRAC' PSC ; 
opti 'EPTR' 5 ;

*# reprise :
reprise = faux ;
**************************************************************
*                   REPERE :
**************************************************************
ex = 0. -1. 0.   ; 
ey = 0. 0. 1.    ;
ez = (-1.) 0. 0. ;
*
* opti donn 5 ; 
**************************************************************
*                   REPSAUV
**************************************************************
* rep_sauv = (chai './data/') ;

**************************************************************
*                   Temps :
**************************************************************
*# ttot :
ttot = 128. ;

*# t :
T = 5.e-6 ;

*# dte :
dte = 1.e-6 ;

NPASe = (ENTI 'PROCH' (T / DTe)) - 1 ;

*# nsort :
nsort = 1 ;

tprog = prog 0. 'PAS' Dte 'NPAS' (NPASe + 1 ) ;

si (reprise) ;
*# trep :
trep = 0. ;
* on reajuste l'evolution du temps : pour le chargement uniquement !!
tprog_rep = prog trep 'PAS' dte 'NPAS' (npase + 1) ;
finsi ;
**************************************************************
*         adaptateur rigide ou raidtimo ?
**************************************************************
* le cone est il fixe ?
lconefixe = faux ;
* adaptateur : modele elastique ou modele FE ?
lraidtimo = faux ;
* liaison cercle-cone ?
ccone = vrai ;
* on met les pions ?
lpion = faux ;
* veut on sortir la force transmise ?
ltrans = faux ;
* amortissement modal ?
*# lamode :
lamode = faux ;
*# amode_ad :
amode_ad = 0.01 ;
*# amode_m :
amode_m = 0.01 ;
*# lexp :
lexp = vrai ;
* est-ce qu'on retire le 2eme mode de l'adaptateur ?
*# lmad2 :
lmad2 = faux ;
* raidisseurs entre les ressorts a lames ?
*# raidiss :
raidiss = vrai ;
* on sort les depl de plam_h et plam_b ?
lplam = faux ;
* seulement 1 point cercle pour les pions haut et bas ?
*# lpcirc :
lpcirc = vrai ;
*# blqry :
blqry = vrai ;

* Oden : vitesse limite d'adhrence ?
* vlimoden = 1.e-1 ;
* vlimoden = 1.e-2 ;

*# vlimoden :
vlimoden = 1.e-3 ;

* vlimoden = 1.e-5 ;
* vlimoden = 1.e-6 ;
* sinus simple ou sinus balaye ?
lsin = faux ;
lsinb = vrai ;

****************************************************************************
*                       PARAMETRES SORTIE 
****************************************************************************
*# POSTRAITEMENT: (englobe tous les post-traitements)
POSTRAITEMENT = VRAI ;

*# EVOLRECO :
EVOLRECO = VRAI ;

*# SORTLIAI :
SORTLIAI = VRAI ;

*# FLVTK :
FLVTK = faux ;

*# SORTEXCEL :
SORTEXCEL = VRAI ;

*# on ne sauvegarde qu'un nombre reduit de sorties :
LSMALLEXIT = faux ;

**************************************************************
*                   SCRIPT :
**************************************************************
* trnache de calcul pour les reprises :

*# slice : 
slice = 1 ;

script = (chai 'manchadela_pions_'slice) ;
* si (LSMALLEXIT) ;
* script = (chai 'slice_'slice) ;
* finsi ;
* script = 'manchadela_rsg' ;
* rep_sauv = 'xdr' ;
*
opti 'FTRA' (chai 'fig/'script'.ps');
*
****************************************************************************
*                       CHARGEMENT 
****************************************************************************
* amplitude de la force :


*# Fext :
Fext = 250. ;

* valeur de la force a la fin du calcul (si lexp)

*# fefin :
fefin = 50. ;

* opti donn 5 ;

si (lsin) ;
* Freq = 8.6574 ; 
  Freq = 2. ; 
  OMEGA = 360.*Freq ;
  Fprog2 = (SIN (OMEGA*tprog)) ;
finsi ;

si (lsinb) ;
*# f1 :
  f1 = 5. ; 
*# f2 :
  f2 = 20. ; 
  fend = f1 + ((T/ttot)*(f2 - f1)) ; 
  df = (fend - f1) / ((dime tprog) - 1 ) ;
  freq = prog f1 'PAS' df 'NPAS' ((dime tprog) - 1) ;
  omega = 360. * freq ; 
  Fprog2 =(sin ( omega * tprog ) ) ;
  si (T >EG (10.e-3)) ;
  dtr = 1.e-3 ;
  nptr = (ENTI 'PROCH' (T / dtr)) - 1 ;
  ttrac = prog 0. 'PAS' dtr 'NPAS' (nptr + 1 ) ;
  dftr = (f2 - f1) / ((dime ttrac) - 1 ) ;
  ftr = prog f1 'PAS' dftr 'NPAS' ((dime ttrac) - 1) ;
  omegtr = 360. * ftr ; 
  fprogtr =(sin ( omegtr * ttrac ) ) ;
  evfprogtr = EVOL 'BLEU' 'MANU' 't' ttrac 'fprogtr' fprogtr ; 
  dess evfprogtr 'LEGE' ;
  finsi ;
  si reprise ;
    fstart = f1 + ((trep/ttot)*(f2 - f1)) ; 
    fend = fstart + ((T/ttot)*(f2 - f1)) ; 
    df = (fend - fstart) / ((dime tprog) - 1 ) ;
* freq = prog fstart 'PAS' df 'NPAS' (dime tprog) ;
    freq = prog fstart 'PAS' df 'NPAS' ((dime tprog) - 1) ;
    omega = 360. * freq ; 
    Fprog2 = (sin ( omega * tprog_rep ) ) ;
*   evfprogtr = EVOL 'BLEU' 'MANU' 't' tprog 'fprogtr' fprog2 ; 
*   opti trac x ; 
*   dess evfprogtr 'LEGE' ;
*   opti donn 5 ; 
  finsi ;
finsi ;

si (lexp) ;
* on rajoute une decroissance exponentielle :
  Bf = (log (fefin/Fext))/ttot ; 
  Fprogxp = (exp (Bf*tprog)) ;
  si (reprise) ;
    Fprogxp = (exp (Bf*tprog_rep)) ;
  finsi ;
  Fprog2 = (Fprog2 * Fprogxp) ;
finsi ;
**************************************************************
*                   Système unité
**************************************************************
* longueur : mm
* masse : 10^3kg
* Force : Nmtot_manch
* Temps : sec
* Masse volumique : 10^-12kg/m 3
* Pression : MPa( = N/mm^2 )

****************************************************************************
*                 CONSTANTE GRAVITATION
****************************************************************************
grav = 9.81 ; 
****************************************************************************
*                       MATERIAU 
****************************************************************************
* E = 30.e9 ;
E = 200.e+9 ;
NU = 0.3 ;
RHO = 7900. ; 
****************************************************************************
*                       Restitution des modeles 
****************************************************************************
****************************************************************************
*                       MODELE MANCHETTE 
****************************************************************************
**** modele manchette (genere par : modele_manchette_tete_rigide.dgibi)
**************************************************************
*            Modes elastiques ?
**************************************************************
lela = vrai ;
**************************************************************
*                Paramètres généraux
**************************************************************
*# nmode :
nmode = 3 ;

*# nmode_ad :
nmode_ad = 7 ; 

* au cas ou lmad2 = faux :
nmad = nmode_ad ;
* Trace des defomees modales des 3 parties separement :
* NOMU = VRAI ; 

**************************************************************
*                   MASSE, CDM, Tenseur d'inertie
**************************************************************
MTOT_MANCH = 11.46 ;
GTOT_MANCH = 0.74216686 0. 0. ;

JX_MANCH = 0.010527338424895177 ;
JY_MANCH = 2.583844235854036 ;
JZ_MANCH = 2.583844235854036 ;
**************************************************************
*                   Mesures GLOBAL
**************************************************************
L_tot = 1563.4*1.e-3 ;
L_tete = 28.5*1.e-3 ;
L_corps = L_tot - L_tete ; 
**************************************************************
*                   Points axe de révolution
**************************************************************
PR1 = 0. 0. 0. ;
PR2 = L_tot 0. 0. ;
**************************************************************
*                   Mesures TETE PARTIE CONE
**************************************************************
* Diametre de la tete :
D_tete = 93.6*1.e-3 ; 
R_tete = D_tete/2. ; 
*
R_cone_b = 80.8*1.e-3/2. ; 
R_cone_h  = 55.3*1.e-3/2. ; 
alpha_cone = 30.  ;
L_cone_tot = R_cone_b/( tan alpha_cone ) ;
* Thales : 
htete = (R_cone_h/R_cone_b)*L_cone_tot ;
* Longuer de la partie conique de la tête de manchette :
L_cone = L_cone_tot - htete ; 
* Longueur partie cylindrique de la manchette
L_cyl = L_tete - L_cone ;
**************************************************************
*                   Mesures CORPS MANCHETTE
**************************************************************
D_ext = 63.5*1.e-3 ;
R_ext = D_ext/2. ; 
D_int = 55.3*1.e-3 ;
R_int = D_int/2. ;
epai = R_ext - R_int ;
ep_cyl = R_tete - R_int ;
ratio = epai/ep_cyl ;
**************************************************************
*                   Mesures PIONS
**************************************************************
Larg_pion = 13.4*1.e-3 ; 
L_PH = 203.2*1.e-3 ; 
L_PB = 596.9*1.e-3 ;
L_PH = (L_PH+(Larg_pion/2.)) ;
L_PB = (L_PB+(Larg_pion/2.)) ;
PH = L_PH 0. 0. ; 
PB = L_PB 0. 0. ; 

D_pion = 68.83*1.e-3 ;
h_pion = ((D_pion-D_ext)/2.) ;

* opti donn 5 ; 
**************************************************************
*        POINT BAS : dernier vis-a-vis manchette-adaptateur
**************************************************************
* Rayon interieur de la base du cone de l'adaptateur : 
D_cone_A = 108.5*1.e-3 ;
R_cone_A = D_cone_A/2. ;
D_cone_ext_A = (140.)*1.e-3 ;
R_cone_ext_A = D_cone_ext_A/2. ;

* CORPS : Diametre interieur adaptateur :
Dint_A = 70.e-3 ;
* CORPS : Diametre exterieur adaptateur :
Dext_A = (101.5)*1.e-3 ; 
* Angle du cône de l'adaptateur : en degres
alpha_c_ad = 45. ;
* Hauteur du cone non tronque de l'adaptateur : 
h_cone_A = R_cone_A/(TAN alpha_c_ad) ;
* Longueur tot de l'adaptateur :
L_tot_ad = 745.*1.e-3 ;
* Longueur tete adaptateur :
L_cyl_ad = 35.*1.e-3 ;
* Longueur adaptateur partie conique :
L_cone_ad = ((R_CONE_A/(tan alpha_c_ad))) + ((-1.)*(0.5*Dint_A/(tan alpha_c_ad))) ;
* Longueur tete adaptateur :
L_tete_ad = L_cyl_ad + L_cone_ad ;
* Longueur corps adaptateur : 
L_corps_ad = L_tot_ad - L_tete_ad ;

* Delta altitude entre fin partie cylindrique adaptateur vs manchette :
*     --> Comme diférence de leur distances resp. / sommete du cone de l'adaptateur.
Delta_1 = (R_CONE_A/(TAN ALPHA_C_AD)) - (R_tete/(TAN ALPHA_C_AD)) ;
* On en deduit le delta (>0) entre le sommet de l'adaptateur et le sommet de la manchette lorsque la manchette repose a plat sur le cone :
Delta_MC = L_CYL_AD - L_TETE + DELTA_1 ;
*   --> C EST LE DELTA ENTRE LE REPERE DU CONE ET DE LA MANCHETTE 
*       (sachant qu'on choisit le repere de la manchette comme reference.)

* Différence d'altitude entre le cercle de fin de tete de la manchette et la fin de la tete de l'adapt. (.ie fin partie conique de l'adaptateur) :
* Delta_m_ad = 12.25*1.e-3 ;
Delta_m_ad = L_CONE_AD - Delta_1 ;

* Altitude du point bas = dernier vis-a-vis manchette-adaptateur
L_B = L_tete + Delta_m_ad + L_corps_ad ;

PLOW = L_B 0. 0. ; 
**************************************************************
*        ECART MANCHETTE - ADAPTATEUR : (repere de la manchette)
**************************************************************
* position sommet du cone adaptateur :
*   Par rapport au cercle bas de la tete
Scone = R_TETE / (TAN ALPHA_C_AD) ;
* Par rapport au sommet de la manchette : 
Scone = (Scone + L_TETE) 0. 0. ;
* opti donn 5 ;
**************************************************************
*                   NOMBRE D ELEMENTS
**************************************************************
* Rq : facteur déterminant nb_T_cone 
*   ( = discretisation de la partie a section variable )
*
* Partie conique de la tete : 
nb_T_cone = 20 ;
* Partie cylindrique de la tete : 
nb_T_cyl = 1 ;
a = (FLOT (ENTI (L_cyl/L_cone)*nb_T_cone)) ;
Lf = prog 1. a ;
nb_T_cyl = ENTI (MAXI Lf) ; 
nb_T_cyl = 2 ;
* Nbr d'éléments en longueur du corps : 
a = (FLOT (ENTI (L_corps/L_cone)*nb_T_cone)) ;
Lf = prog 1. a ; 
nb_corps = ENTI (MAXI Lf) ;
* test :
*# nb_corps ;
nb_corps = 80 ;

* qui donne la bonne masse une fois integre :
* nb_corps = 248 ;
**************************************************************
*                   MAILLAGE POUTRE TIMO
**************************************************************
*********** TETE DE LA MANCHETTE 
* On remplace la partie conique + cylindrique de la tete 
*     par une seule partie cylindrique de meme characteristiques
*     que la partie cylindrique.Ntronq = (nmode - n_tronq) ;*************
* centre de masse de la manchette :
* Partie conqie de la tete
P1 = 0. 0. 0. ;
P2 = L_tete 0. 0. ;
L1 = D 1 P1 P2 ;
*********** CORPS MANCHETTE
*  On divise zn 2 pour avoir precisement le centre de masse de la manchette :
P3 = L_tot 0. 0. ;


nbel_21 = ENTI (NB_CORPS*(NORM (PH PLUS ((-1.)*P2))) / L_CORPS) ;
nbel_22 = ENTI (NB_CORPS*(NORM (PB PLUS ((-1.)*PH))) / L_CORPS) ;
nbel_23 = ENTI (NB_CORPS*(NORM (PLOW PLUS ((-1.)*PB))) / L_CORPS) ;
nbel_24 = ENTI (NB_CORPS*(NORM (GTOT_MANCH PLUS ((-1.)*PLOW))) / L_CORPS) ;
nbel_25 = NB_CORPS - NBEL_21 - NBEL_22 - NBEL_23 - NBEL_24 ;
* nbel_25 = (NORM (P3 PLUS ((-1.)*GTOT_MANCH))) / L_CORPS ;

nbel_21 = maxi (lect nbel_21 1) ;
nbel_22 = maxi (lect nbel_22 1) ;
nbel_23 = maxi (lect nbel_23 1) ;
nbel_24 = maxi (lect nbel_24 1) ;
nbel_25 = maxi (lect nbel_25 1) ;

L21 = D nbel_21 P2 PH ;
L22 = D nbel_22 PH PB ;
L23 = D nbel_23 PB PLOW ;
L24 = D nbel_24 PLOW GTOT_MANCH ;
L25 = D nbel_25 GTOT_MANCH P3 ;

L2 = L21 ET L22 ET L23 ET L24 ET L25 ;
***** Sections constantes
* Partie cylindrique de la tete
S_cyl   = Pi*( ((R_tete)**2) - ((R_int)**2) ) ;
* Corps de la manchette
S_corps = Pi*( ((R_ext)**2) - ((R_int)**2) ) ;

**************************************************************
*             MOMENTS QUADRATIQUES ( 'INRY' 'INRZ' )
**************************************************************  
***** Sections constantes
* Partie cylindrique de la tete :
  IGx_cyl = ( Pi*((D_tete**4) - (D_int**4) )/64. ) ;
  IGy_cyl = IGx_cyl ;
  IG_cyl = ( Pi*((D_tete**4) - (D_int**4) )/32. ) ;
  
* Corps de la manchette :
  IGx_corps = ( Pi*((D_ext**4) - (D_int**4) )/64. ) ;
  IGy_corps = IGx_corps ;
  IG_corps = ( Pi*((D_ext**4) -  (D_int**4) )/32. ) ;

*********************************************************************
*                            MODELE 
*********************************************************************

* TETE MANCHETTE :
mod1 = mode L1 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
* Remarque: l'axe x est l'axe de la poutre contrairement au maillage.
mat1 = MATE mod1 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S_cyl 'INRZ' IGx_cyl 'INRY' IGx_cyl 'TORS' IG_cyl ;
*
* CH_S_cyl = EXCO 'SECT' 1 mat2 ;
* CH_IGx_cyl = EXCO 'INRZ' 1 mat2 ;
* CH_IGy_cyl = EXCO 'INRY' 1 mat2 ;
* CH_IG_cyl = EXCO 'TORS' 1 mat2 ;
*
list S_cyl ; 
list IGx_cyl ;
list IG_cyl ;
TRAC 'QUAL' mod1 MAT1 ;
* matrice de raideur:
K1 = rigi mod1 mat1 ;
* matrice de masse:
M1 = mass mod1 mat1 ;

* Corps de la manchette :
mod2 = mode L2 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
* Remarque: l'axe x est l'axe de la poutre contrairement au maillage.
mat2 = MATE mod2 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S_corps 'INRZ' IGx_corps 'INRY' IGx_corps 'TORS' IG_corps ;
* CH_S_corps = EXCO 'SECT' 1 mat3 ;
* CH_IGx_corps = EXCO 'INRZ' 1 mat3 ;
* CH_IGy_corps = EXCO 'INRY' 1 mat3 ;
* CH_IG_corps = EXCO 'TORS' 1 mat3 ;

* opti donn 5 ;
list S_corps ; 
list IGx_corps ;
list IG_corps ;
TRAC 'QUAL' mod2 MAT2 ;
*
* matrice de raideur:
K2 = rigi mod2 mat2 ;
* matrice de masse:
M2 = mass mod2 mat2 ;
  
manchette = L1 et L2 ;
MODmanch = (mod1 et mod2) ;
MATmanch = (mat1 et mat2) ;
* CH_S_manch = EXCO 'SECT' 1 MATmanch ;
* CH_IGx_manch = EXCO 'INRZ' 1 MATmanch ;
* CH_IGy_manch = EXCO 'INRY' 1 MATmanch ;
* CH_IG_manch = EXCO 'TORS' 1 MATmanch ;
*
CHPO_manch = CHAN 'CHPO' MODmanch MATmanch  ;
*
Evs_manch = EVOL 'CHPO' CHPO_manch 'SECT' manchette ;
EvIGX_manch = EVOL 'CHPO' CHPO_manch 'INRY' manchette ;
EvIGY_manch = EVOL 'CHPO' CHPO_manch 'INRZ' manchette ;
EvIG_manch = EVOL 'CHPO' CHPO_manch 'TORS' manchette ;
DESS Evs_manch ;
DESS EvIGX_manch ;
DESS EvIGY_manch ;
DESS EvIG_manch ;
TRAC 'QUAL' MODmanch MATmanch ;

* opti donn 5 ;
* Alternative : FAUX
* S_manch = CH_S_cone et CH_S_cyl et CH_S_corps ; 
* CH_IGx_manch = CH_IGx_corps et CH_IGx_cyl et CH_IGx_c ;
* CH_IGy_manch = CH_IGx_manch ;
* CH_IG_manch = CH_IG_corps et CH_IG_cyl et CH_IG_c ;
* CH_E = MANU 'CHML' manchette 'YOUN' E ;
* CH_nu = MANU 'CHML' manchette 'NU' nu ;
* MODmanch = mode manchette 'MECANIQUE' 'ELASTIQUE' 'TIMO' ; 
* MATmanch = MATE MODmanch 'YOUN' CH_E 'NU' CH_nu 'SECT' S_manch 'INRZ' CH_IGx_manch 'INRY' CH_IGy_manch 'TORS' CH_IG_manch ;
*
MOD1 = MODmanch ;
MAT1 = MATmanch ;
* opti donn 5 ; 
K1 = K1 et K2 ;
M1 = M1 et M2 ;
*********************************************************************
*                            BASE MODALE 
*********************************************************************
* Tmode = VIBR 'IRAM' 1. nmode K1 M1 ;

* 6 modes : tries sur iram : 
lfind = prog 136.97 381.97 747.14 1220.547 1482.64 1788.90 ; 
ltrac = lect 5 ;
lindmode = lect nmode*1 ;
* on fabrique une base modale orthogonale pour le couplage inertiel :
bly = bloq manchette 'UY' ;
k1x = k1 et bly ;
Tmode_elax = VIBR 'PROCHE' lfind lindmode k1x m1 ;
blx = bloq manchette 'UZ' ;
k1y = k1 et blx ;
Tmode_elay = VIBR 'PROCHE' lfind lindmode k1y m1 ;
* creation de la nouvelle base modale de nmode :
tmode = table 'BASE_MODALE' ;
tmode . 'MODES' = table 'BASE_DE_MODES' ;
tmode . 'MODES' . 'MAILLAGE' = manchette ;
Tmode . 'MAILLAGE_REPERE' = VIDE 'MAILLAGE' ;
numode = 1 ;
l_amor_m = prog ; 
repe bmode (nmode) ;
* mode traction-compression ? a ne prendre qu'une fois en compte.
  lect1 = lect &bmode ;
  tracomp = dans lect1 ltrac ;
* on complete le maillage repere :
  tmode . 'MAILLAGE_REPERE' = (tmode . 'MAILLAGE_REPERE') et (Tmode_elax . 'MODES' . &bmode . 'POINT_REPERE') ;
* on renumerote :
  tmode_elax . modes . &bmode . 'NUMERO_MODE' = numode ; 
  tmode . modes . numode = tmode_elax . modes . &bmode ;
* pour l'amortissement : 2 m omega xi = ci :
  mui = tmode_elax . modes . &bmode . 'MASSE_GENERALISEE' ;
  fi  = tmode_elax . modes . &bmode . 'FREQUENCE' ;
  ci = (2.*mui*(2.*pi*fi)*amode_m) ;
  l_amor_m = l_amor_m et ci ;
  si (non tracomp) ;
* on complete le maillage repere :
  tmode . 'MAILLAGE_REPERE' = (tmode . 'MAILLAGE_REPERE') et (Tmode_elay . 'MODES' . &bmode . 'POINT_REPERE') ;
  tmode_elay . modes . &bmode . 'NUMERO_MODE' = (numode + 1) ; 
  tmode . modes . (numode + 1) = tmode_elay . modes . &bmode ;
* le mode est identique ne 'UY' donc l'amortiessement est le mm :
  l_amor_m = l_amor_m et (2.*mui*(2.*pi*fi)*amode_m) ;
  numode = numode + 1 ;
  finsi ;
* incrementation de numode : 
  numode = numode + 1 ;
fin bmode ;
* on met l'amortissement maintenant avant de rajouter les modes de corps rigides :
tamor = table 'AMORTISSEMENT' ;
tamor . 'AMORTISSEMENT' = (amor tmode l_amor_m) ;
* opti trac x ;
postvibr Tmode ; 
* Tmode_middle = VIBR 'IRAM' 5.  nmode K1 M1 ;
* postvibr Tmode_middle ; 
* Tmode_high   = VIBR 'IRAM' 10. nmode K1 M1 ;
* postvibr Tmode_high ; 
*********************************************************************
*                 TRONCATURE BASE MODALE : 
*                     ON VIRE LES MODES RIGIDES
*********************************************************************
* on vire les corps rigides :
*# n_tronq :
*n_tronq = 6 ;
*
*Tmode_tronq = TABL 'BASE_MODALE' ;
*Tmode_tronq . 'MODES' = TABL 'BASE_DE_MODES' ;
*Tmode_tronq . 'MODES' . 'MAILLAGE' = manchette ;
*Tmode_tronq . 'MAILLAGE_REPERE' = VIDE 'MAILLAGE' ;
*numode = 1 ;
*REPE BTRONQ (nmode - n_tronq) ;
**   implementation maillage repere :
*    Tmode_tronq . 'MAILLAGE_REPERE' = (Tmode_tronq . 'MAILLAGE_REPERE') et (Tmode . 'MODES' . (N_tronq + &BTRONQ) . 'POINT_REPERE') ;
**   renumerotation :
*    tmode . modes . (&btronq + n_tronq) . 'NUMERO_MODE' = numode ; 
**   implementation mode :
*    tmode_tronq . modes . numode = tmode . modes . (&btronq + n_tronq) ;
**   increment numode :
*    numode = numode + 1 ;
*FIN BTRONQ ; 
*
*tmode = Tmode_tronq ; 
** opti trac x ;
*postvibr Tmode ; 
** opti donn 5 ;
*********************************************************************
*                  TMODE : translations et rotations 
*********************************************************************

***** Translations : 
PTREP_M_TX = 0. 0. 0. ;
PTREP_M_TY = 0. 0. 0. ;
PTREP_M_TZ = 0. 0. 0. ;
*
TMODE_M_TX = TABLE 'BASE_MODALE' ; 
TMODE_M_TX . MODES = TABLE 'BASE_DE_MODES' ;
TMODE_M_TX . MODES . 'MAILLAGE' = MANCHETTE ;
TMODE_M_TX . MODES . 1 = TABLE 'MODE' ;
*
TMODE_M_TY = TABLE 'BASE_MODALE' ; 
TMODE_M_TY . MODES = TABLE 'BASE_DE_MODES' ;
TMODE_M_TY . MODES . 'MAILLAGE' = MANCHETTE ;
TMODE_M_TY . MODES . 1 = TABLE 'MODE' ;
*
TMODE_M_TZ = TABLE 'BASE_MODALE' ; 
TMODE_M_TZ . MODES = TABLE 'BASE_DE_MODES' ;
TMODE_M_TZ . MODES . 'MAILLAGE' = MANCHETTE ;
TMODE_M_TZ . MODES . 1 = TABLE 'MODE' ;
*     
TMODE_M_TX . MODES . 1 . POINT_REPERE = PTREP_M_TX ;
TMODE_M_TY . MODES . 1 . POINT_REPERE = PTREP_M_TY ;
TMODE_M_TZ . MODES . 1 . POINT_REPERE = PTREP_M_TZ ;
*     
TMODE_M_TX . MODES . 1 . MASSE_GENERALISEE = MTOT_MANCH ; 
TMODE_M_TY . MODES . 1 . MASSE_GENERALISEE = MTOT_MANCH ;
TMODE_M_TZ . MODES . 1 . MASSE_GENERALISEE = MTOT_MANCH ;
*     
TMODE_M_TX . MODES . 1 . FREQUENCE = 0. ;
TMODE_M_TY . MODES . 1 . FREQUENCE = 0. ;
TMODE_M_TZ . MODES . 1 . FREQUENCE = 0. ;
*     
TMODE_M_TX . MODES . 1 . 'TRANSLATION_RIGIDE' = 'VRAI' ;
TMODE_M_TY . MODES . 1 . 'TRANSLATION_RIGIDE' = 'VRAI' ;
TMODE_M_TZ . MODES . 1 . 'TRANSLATION_RIGIDE' = 'VRAI' ;
*
TMODE_M_TX . MODES . 'MAILLAGE' = MANCHETTE ;
TMODE_M_TY . MODES . 'MAILLAGE' = MANCHETTE ;
TMODE_M_TZ . MODES . 'MAILLAGE' = MANCHETTE ;
*
DEF_TX = MANU 'CHPO' MANCHETTE 6 'UX' 1. 'UY' 0. 'UZ' 0. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;
DEF_TY = MANU 'CHPO' MANCHETTE 6 'UX' 0. 'UY' 1. 'UZ' 0. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;
DEF_TZ = MANU 'CHPO' MANCHETTE 6 'UX' 0. 'UY' 0. 'UZ' 1. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;
*
TMODE_M_TX . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_TX ;
TMODE_M_TY . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_TY ;
TMODE_M_TZ . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_TZ ;
*
**** Rotations rigides : 
PTREP_M_RX = 0. 0. 0. ;
PTREP_M_RY = 0. 0. 0. ;
PTREP_M_RZ = 0. 0. 0. ;
* Deformee bidon pour les rotas rigides :
DEF_ROT = MANU 'CHPO' MANCHETTE 6 'UX' 0. 'UY' 0. 'UZ' 0. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;
** Creations des bases modales:
* TMODE_M_RX:
TMODE_M_RX = TABLE 'BASE_MODALE' ;
TMODE_M_RX . 'MODES' = TABLE 'BASE_DE_MODES' ;
TMODE_M_RX . 'MODES' . 'MAILLAGE' = MANCHETTE ;
TMODE_M_RX . 'MODES' . 1 = TABLE 'MODE' ;
* TMODE_M_RY:
TMODE_M_RY = TABLE 'BASE_MODALE' ;
TMODE_M_RY . 'MODES' = TABLE 'BASE_DE_MODES' ;
TMODE_M_RY . 'MODES' . 'MAILLAGE' = MANCHETTE ;
TMODE_M_RY . 'MODES' . 1 = TABLE 'MODE' ;
* TMODE_M_RZ:
TMODE_M_RZ = TABLE 'BASE_MODALE' ;
TMODE_M_RZ . 'MODES' = TABLE 'BASE_DE_MODES' ;
TMODE_M_RZ . 'MODES' . 'MAILLAGE' = MANCHETTE ;
TMODE_M_RZ . 'MODES' . 1 = TABLE 'MODE' ;
*
TMODE_M_RX . 'MODES' . 1 . 'POINT_REPERE' = PTREP_M_RX ;
TMODE_M_RY . 'MODES' . 1 . 'POINT_REPERE' = PTREP_M_RY ;
TMODE_M_RZ . 'MODES' . 1 . 'POINT_REPERE' = PTREP_M_RZ ;
*
TMODE_M_RX . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_ROT ;
TMODE_M_RY . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_ROT ;
TMODE_M_RZ . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_ROT ;
*
TMODE_M_RX . 'MODES'  . 'MAILLAGE' = MANCHETTE ;
TMODE_M_RY . 'MODES'  . 'MAILLAGE' = MANCHETTE ;
TMODE_M_RZ . 'MODES'  . 'MAILLAGE' = MANCHETTE ;
*
TMODE_M_RX . 'MODES' . 1 . MASSE_GENERALISEE = JX_MANCH ;
TMODE_M_RY . 'MODES' . 1 . MASSE_GENERALISEE = JY_MANCH ;
TMODE_M_RZ . 'MODES' . 1 . MASSE_GENERALISEE = JZ_MANCH ;
* ON MET tous les CDM à P1 pour éviter la correction des moments d'inertie:
TMODE_M_RX . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
TMODE_M_RX . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= GTOT_MANCH ;
* TMODE_M_RX . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P2 ;
TMODE_M_RX . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= gtot_manch ;
TMODE_M_RX . 'MODES' . 1 . 'MASSE'= MTOT_MANCH ;
TMODE_M_RX . 'MODES' . 1 . 'COMPOSANTE' = 'RX' ;

TMODE_M_RY . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
TMODE_M_RY . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= GTOT_MANCH ;
* TMODE_M_RY . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P2 ;
TMODE_M_RY . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= gtot_manch ;
TMODE_M_RY . 'MODES' . 1 . 'MASSE'= MTOT_MANCH ;
TMODE_M_RY . 'MODES' . 1 . 'COMPOSANTE' = 'RY' ;

TMODE_M_RZ . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
TMODE_M_RZ . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= GTOT_MANCH ;
* TMODE_M_RZ . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P2 ;
TMODE_M_RZ . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= Gtot_manch ;
TMODE_M_RZ . 'MODES' . 1 . 'MASSE'= MTOT_MANCH ;
TMODE_M_RZ . 'MODES' . 1 . 'COMPOSANTE' = 'RZ' ;

TMODE_DEBUG = vibr 'IRAM' 1. 1 K1 M1 ;
DEF_DEBUG = MANU 'CHPO' MANCHETTE 6 'UX' 0. 'UY' 0. 'UZ' 0. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;
TMODE_DEBUG . MODES . 1 . DEFORMEE_MODALE = DEF_DEBUG ; 

* Avec le mode debug : 
* TMODE_M_RIG = TMODE_DEBUG ET TMODE_M_TX ET TMODE_M_TY ET TMODE_M_TZ
*               ET TMODE_M_RX ET TMODE_M_RY ET TMODE_M_RZ ;
* Sans le mode debug :
TMODE_M_RIG = TMODE_M_TX ET TMODE_M_TY ET TMODE_M_TZ
              ET TMODE_M_RX ET TMODE_M_RY ET TMODE_M_RZ ;
*** on assemble : 
* MS : base modale FLEX + RIG :
si lela ;
* on ajoute les modes elastiques
  TMODE = TMODE ET TMODE_M_RIG ; 
sinon ;
* Modes rigides only : 
  TMODE = TMODE_M_RIG ; 
finsi ;

**** modele adaptateur (genere en 1ere partie du script : adaptateur_susp_ela.dgibi)
**************************************************************
*        MODELE ADAPTATEUR : (repere de la manchette)
**************************************************************
**************************************************************
*        ECART MANCHETTE - ADAPTATEUR : (repere de la manchette)
**************************************************************
* position sommet du cone adaptateur :
*   Par rapport au cercle bas de la tete
Scone = R_TETE / (TAN ALPHA_C_AD) ;
* Par rapport au sommet de la manchette : 
Scone = (Scone + L_TETE) 0. 0. ;

**************************************************************
*        POSITIONS DES BRIDES 
*       = point d'attache des ressorts a lame : 
*         (repere de la manchette)
**************************************************************
* L'origine du scripte python est donnée par le laser 4 
* --> pl4 = [0. , 0. , 0. ]
* le laser est vraissemblablement 
* legerement surélevé / somme tmanchette, 
* mais on ne sait pas de combien. On prend tel quel.
* Rq : ces point vont appartenir à l'adaptateur !
* PAR RAPPORT au pion_haut : zPPH_py = 697.e-3
*   zPL1_py = 715.e-3
*   zPL2_py = zPL3_py  = 224.e-3
*   Ressort a lame haut :
PLAM_B = ((697.e-3) - (224.e-3)) 0. 0. ; 
PLAM_B = PLAM_B PLUS PH ;
* Pour le point support de la liaison : 
PLAM_B_sup = ((697.e-3) - (224.e-3)) 0. 0. ; 
PLAM_B_sup = PLAM_B_sup PLUS PH ;
*   Ressort a lame bas (rappel x vers le bas) :
PLAM_H = ((697.e-3) - (715.e-3)) 0. 0. ; 
PLAM_H = PLAM_H PLUS PH ; 
* Pour le point support de la liaison : 
PLAM_H_sup = ((697.e-3) - (715.e-3)) 0. 0. ; 
PLAM_H_sup = PLAM_H_sup PLUS PH ; 
* On rajoute la bride de support de la cible pour les cameras
*   epaisseur de la bride : 
ep_br = 50.e-3 ; 
PSUP = (L_TETE_AD + (ep_br/2.)) 0. 0. ;
PSUP = PSUP  PLUS (((-1.)*DELTA_MC) 0. 0.) ;

****************************************************************************
*           RAIDEURS EQUIVALENTES RESSORTS A LAME
****************************************************************************
* largeur section ressorts (petit cote) :
b_lam = 5.5*(1.e-3) ;
* hauteur section ressorts (gd cote = largeur bride) :
h_lam = 50.*(1.e-3) ;
* Longueur des ressorts a lame : 
L_lam = 450.*(1.e-3) ;
* Section ressorts a lames :
S_lam = b_lam * h_lam ;

* Moments quadratiques :
*     ____       Y : vertical
*    |    |      |
*    |    |      |____ X : horizontal
*    |    |
*    |    |
*    |    |
*    |____|
*   autour de l'axe fort :
IGx_lam = (b_lam * (h_lam**3)) / 12. ;
*   autour de l'axe faible :
IGy_lam = (h_lam * (b_lam**3)) / 12. ;
*   en torsion :
IG_lam = ((b_lam*h_lam)/12.)*((b_lam**2)+(h_lam**2)) ;
*       dist. entre les deux lames : 
Dlam = NORM (PLAM_H PLUS ((-1.)*PLAM_B)) ;
*       module de cisaillement :
Glam = E / (2.*(1. + nu)) ;

****************************************************************************
*                       ADAPTATEUR
****************************************************************************

****************************************************************************
*           MASSES DES SUPPORTS DES BRIDES : 
****************************************************************************
*  Script python : /home/matthieu/Documents/Cast3M/corps_rigide_castem/fortran/dev_git/rotations_rigides/python/calcul_raideur/analytique/modele_manchette_final.py
* Rq : brides en ALU.
* Celle au centre qui est au centre qui recoit la tige du pot vibrant.
*   en Gtot_manch : 
MBR_C = 1.4888768635817482 ;
* Celles = aux points d'attache des ressorts a lame :
*   en PLAM_H & PLAM_B : 
MBR_L = 3.6893768635817485 ;

* Masse de l'adpatateur SANS BRIDES :
MTOT_AD = 25.643267377499903 ;
* CDM de l'adpatateur SANS BRIDES :
GTOT_AD = 0.36361255 0. 0. ; 
* Moment d'inertie de l'adaptateur SANS BRIDES :
JX_AD = 0.05296382 ;
JY_AD = 1.25252025 ;
JZ_AD = 1.25252025 ;

LBRIDE = VRAI ;
SI (LBRIDE) ;
* On compte 3 brides : 
*   - 2 de masse MBR_C :
*       - au centre de gravite de l'adaptateur Gtot_ad
*       - au niveau de la fixation de la cible pour camera rapide
*         en PSUP (juste en dessous de la tete de l'adaptateur)
*   - 2 de masse MBR_L
*       - aux fixations PLAM_H & PLAM_B
* Masse de l'adpatateur AVEC BRIDES :
MTOT_AD = MTOT_AD + (2.*MBR_C) + (2.*MBR_L) ;
* CDM de l'adpatateur AVEC BRIDES :
GTOT_AD_BR = 0.36639892 0. 0. ; 
* Moment d'inertie de l'adaptateur AVEC BRIDES :
JX_AD = 0.05296382 ;
JY_AD = 1.86943098 ;
JZ_AD = 1.86943098 ;

delta_Jyad = 100. * ((ABS (1.86943098 - 1.25252025))/1.25252025) ;

FINSI ;
**************************************************************
*                   MAILLAGE POUTRE TIMO
**************************************************************
* L'adaptateur est considéré comme un corps rigide
* On le divise simplement comme 2 poutres de part et d'autre de son centre de massse
* de 1 elements qui n'a pas vocation a subir des defo.
*   / sommet de l'adaptateur :
* Dans le repere de l'adaptateur (sera decale plsu tard): 
SCONE_AD = (L_CYL_AD + (R_CONE_A/(TAN ALPHA_C_AD))) 0. 0. ;
P1_ad = 0. 0. 0. ;
P2_ad = L_TETE_AD 0. 0. ; 
P3_ad = L_TOT_AD 0. 0. ;
* On passe dans le repere de la manchette :
P1_AD    = P1_AD    PLUS (((-1.)*DELTA_MC) 0. 0.) ;
P2_AD    = P2_AD    PLUS (((-1.)*DELTA_MC) 0. 0.) ;
P3_AD    = P3_AD    PLUS (((-1.)*DELTA_MC) 0. 0.) ;
SCONE_AD = SCONE_AD PLUS (((-1.)*DELTA_MC) 0. 0.) ;
GTOT_AD  = GTOT_AD  PLUS (((-1.)*DELTA_MC) 0. 0.) ;
* Positions des pions deja exprimes dans le repere manchette
PH_AD = L_PH 0. 0. ; 
PB_AD = L_PB 0. 0. ; 
* vis a vis adaptateur du centre du cercle : 
pce_ad = L_TETE 0. 0. ; 
*
nbelad_1  = 1 ; 
nbelad_2  = ENTI (NB_CORPS*(NORM (pce_ad PLUS ((-1.)*p2_ad))) / L_CORPS) ; 
* nbelad_1 = ENTI (NB_CORPS*(NORM (P1_AD PLUS ((-1.)*P2_AD))) / L_CORPS) ;
nbelad_3  = ENTI (NB_CORPS*(NORM (P2_AD PLUS ((-1.)*SCONE_AD))) / L_CORPS) ;
nbelad_4  = ENTI (NB_CORPS*(NORM (SCONE_AD PLUS ((-1.)*PLAM_H))) / L_CORPS) ;
nbelad_5  = ENTI (NB_CORPS*(NORM (PLAM_H PLUS ((-1.)*PH_AD))) / L_CORPS) ;
nbelad_6  = ENTI (NB_CORPS*(NORM (PH_AD PLUS ((-1.)*GTOT_AD))) / L_CORPS) ;
nbelad_7  = ENTI (NB_CORPS*(NORM (GTOT_AD PLUS ((-1.)*GTOT_AD_BR))) / L_CORPS) ;
nbelad_8  = ENTI (NB_CORPS*(NORM (GTOT_AD_BR PLUS ((-1.)*PB_AD))) / L_CORPS) ;
nbelad_9  = ENTI (NB_CORPS*(NORM (PB_AD PLUS ((-1.)*PLAM_B))) / L_CORPS) ;
nbelad_10 = ENTI (NB_CORPS*(NORM (PLAM_B PLUS ((-1.)*P3_AD))) / L_CORPS) ;

nbelad_2  = MAXI (LECT 1 nbelad_2 ) ; 
nbelad_3  = MAXI (LECT 1 nbelad_3 ) ; 
nbelad_4  = MAXI (LECT 1 nbelad_4 ) ; 
nbelad_5  = MAXI (LECT 1 nbelad_5 ) ; 
nbelad_6  = MAXI (LECT 1 nbelad_6 ) ; 
nbelad_7  = MAXI (LECT 1 nbelad_7 ) ; 
nbelad_8  = MAXI (LECT 1 nbelad_8 ) ; 
nbelad_9  = MAXI (LECT 1 nbelad_9 ) ; 
nbelad_10 = MAXI (LECT 1 nbelad_10 ) ; 
* Tete : 
L1_AD = D NBELAD_1 P1_AD pce_ad ;
L2_AD = D NBELAD_2 pce_ad P2_AD ;
* Corps :
L3_AD  = D NBELAD_3 P2_AD SCONE_AD ;
L4_AD  = D NBELAD_4 SCONE_AD PLAM_H ;
L5_AD  = D NBELAD_5 PLAM_H PH_AD ;
L6_AD  = D NBELAD_6 PH_AD GTOT_AD ;
L7_AD  = D NBELAD_7 GTOT_AD GTOT_AD_BR ;
L8_AD  = D NBELAD_8 GTOT_AD_BR PB_AD ;
L9_AD  = D NBELAD_9 PB_AD PLAM_B ;
L10_AD = D NBELAD_10 PLAM_B P3_AD ;
*
ADAPTATEUR = (L1_AD ET L2_AD ET L3_AD 
           ET L4_AD ET L5_AD ET L6_AD ET L7_AD ET L8_AD ET L9_AD ET L10_AD) ;
ELIM adaptateur 1.e-10 ;

***** Momments quadratiques et sections : **** 

* Tete  :
IGx1_ad = ( Pi*((D_CONE_EXT_A**4) - (D_CONE_A**4))/64. ) ;
IGy1_ad = IGx1_ad ;
IG1_ad  = ( Pi*((D_CONE_EXT_A**4) - (D_CONE_A**4))/32. ) ;
  
* Corps de l'adaptateur :
IGx2_ad = (Pi*((Dext_A**4) - (Dint_A**4) )/64.) ;
IGy2_ad = IGx2_ad ;
IG2_ad  = (Pi*((Dext_A**4) -  (Dint_A**4) )/32.) ;
*
S1_AD   = Pi*(((R_CONE_EXT_A)**2) - ((R_CONE_A)**2)) ;
S2_AD   = Pi*(((0.5*Dext_A)**2) - ((0.5*Dint_A)**2)) ;
*
**************************************************************
*                   MODELE POUTRE
**************************************************************
* TETE MANCHETTE :
mod1_ad = mode ADAPTATEUR 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
* Remarque : l'axe x est l'axe de la poutre contrairement au maillage.
* mat1_ad = MATE mod1_ad 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S1_ad 'INRZ' IGx1_ad 'INRY' IGy1_ad 'TORS' IG1_ad ;
mat1_ad = MATE mod1_ad 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S2_ad 'INRZ' IGx2_ad 'INRY' IGy2_ad 'TORS' IG2_ad ;
*
****************************************************************************
*                       suspensions tout elastique 
****************************************************************************
* vrai valeur : 40 cm
* lspring = 40.e-2 ; 
* on raccourcit les ressorts de la largeur des raidisseurs :
lspring = 35.e-2 ; 

pbath1 = plam_h plus (lspring*ex) ;
pbath2 = plam_h plus (((-1.)*lspring)*ex) ;
pbatb1 = plam_b plus (lspring*ex) ;
pbatb2 = plam_b plus (((-1.)*lspring)*ex) ;
* 
nbelbat = 20 ;

nbelbat = ENTI (NB_CORPS*(lspring)/L_CORPS) ;

lbath1 = d nbelbat PLAM_H pbath1 ;
lbath2 = d nbelbat PLAM_H pbath2 ;
lbatb1 = d nbelbat PLAM_B pbatb1 ;
lbatb2 = d nbelbat PLAM_B pbatb2 ;

si (raidiss) ;
pmidh1 = plam_h plus (0.5*(lspring*ex)) ;
pmidh2 = plam_h plus (0.5*(((-1.)*lspring)*ex)) ;
pmidb1 = plam_b plus (0.5*(lspring*ex)) ;
pmidb2 = plam_b plus (0.5*(((-1.)*lspring)*ex)) ;
*
nbelbat12 = ENTI ((flott nbelbat)/2.) ;
lbath11 = d nbelbat12 PLAM_H pmidh1 ;
lbath21 = d nbelbat12 PLAM_H pmidh2 ;
lbatb11 = d nbelbat12 PLAM_B pmidb1 ;
lbatb21 = d nbelbat12 PLAM_B pmidb2 ;
lbath12 = d nbelbat12 pmidh1 pbath1 ;
lbath22 = d nbelbat12 pmidh2 pbath2 ;
lbatb12 = d nbelbat12 pmidb1 pbatb1 ;
lbatb22 = d nbelbat12 pmidb2 pbatb2 ;
* 
lbath1 = lbath11 et lbath12 ;
lbath2 = lbath21 et lbath22 ;
lbatb1 = lbatb11 et lbatb12 ;
lbatb2 = lbatb21 et lbatb22 ;
* raidisseurs :
lraid1 = d nbelbat12 pmidh1 pmidb1 ;
lraid2 = d nbelbat12 pmidh2 pmidb2 ;
*
finsi ;
* test adaptateur horiz :
cladry = bloq adaptateur 'RY' ;

si (raidiss) ;
adaptateur = adaptateur et lbath1 et lbath2 et lbatb1 et lbatb2 et lraid1 et lraid2 ;
sinon ;
adaptateur = adaptateur et lbath1 et lbath2 et lbatb1 et lbatb2 ;
finsi ;
*
modlh1 = mode lbath1 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
matlh1 = MATE modlh1 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S_lam 'INRZ' IGx_lam 'INRY' IGy_lam 'TORS' IG_lam ;

modlh2 = mode lbath2 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
matlh2 = MATE modlh2 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S_lam 'INRZ' IGx_lam 'INRY' IGy_lam 'TORS' IG_lam ;

modlb1 = mode lbatb1 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
matlb1 = MATE modlb1 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S_lam 'INRZ' IGx_lam 'INRY' IGy_lam 'TORS' IG_lam ;

modlb2 = mode lbatb2 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
matlb2 = MATE modlb2 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S_lam 'INRZ' IGx_lam 'INRY' IGy_lam 'TORS' IG_lam ;
*
si (raidiss) ;
igxraid = 10.*igx_lam ;
igyraid = 10.*igy_lam ;
igraid = 10.*ig_lam ;
modraid1 = mode lraid1 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
matraid1 = MATE modraid1 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S_lam 'INRZ' IGxraid 'INRY' IGyraid 'TORS' IGraid ;
modraid2 = mode lraid2 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
matraid2 = MATE modraid2 'YOUN' E 'NU' nu 'RHO' rho  'SECT' S_lam 'INRZ' IGxraid 'INRY' IGyraid 'TORS' IGraid ;
*
mod1_ad = mod1_ad et modlh1 et modlh2 et modlb1 et modlb2 et modraid1 et modraid2 ;
mat1_ad = mat1_ad et matlh1 et matlh2 et matlb1 et matlb2 et matraid1 et matraid2 ;
sinon ;
mod1_ad = mod1_ad et modlh1 et modlh2 et modlb1 et modlb2 ;
mat1_ad = mat1_ad et matlh1 et matlh2 et matlb1 et matlb2 ;
finsi ;
*
* matrice de raideur :
K_ad = rigi mod1_ad mat1_ad ;
* matrice de masse :
M_ad = mass mod1_ad mat1_ad ;
* Conditions limites : on bloque les 4 points appartenants au bati :
clbath1 = bloq 'DEPL' 'ROTA' pbath1 ;
clbath2 = bloq 'DEPL' 'ROTA' pbath2 ;
clbatb1 = bloq 'DEPL' 'ROTA' pbatb1 ;
clbatb2 = bloq 'DEPL' 'ROTA' pbatb2 ;
*
k_ad = k_ad et clbath1 et clbath2 et clbatb1 et clbatb2 ;
* test horiz :
si (blqry) ;
  k_ad = k_ad et cladry ;
finsi ;
**** BRIDES : MAJ matrice de masse : 
MPBR_C   = MASSE 'UX' 'UY' 'UZ'  MBR_C  GTOT_AD ; 
MPBR_L_H = MASSE 'UX' 'UY' 'UZ'  MBR_L  PLAM_H ;
MPBR_L_B = MASSE 'UX' 'UY' 'UZ'  MBR_L  PLAM_B ;

M_AD = M_AD ET MPBR_C ET MPBR_L_B ET MPBR_L_H ;
****************************************************************************
*                       On bloque l'adaptateur en Y 
****************************************************************************
* CLad_1 = BLOQ 'UY' PLAM_B ; 
* CLad_2 = BLOQ 'UY' PLAM_H ; 
* K_AD = K_AD ET CLad_1 ET CLad_2 ;

* On enleve le mode de translation en y pour l'adaptateur :

* TMODE_BLOQ_AD = VIBR 'IRAM' 1. 1 K_AD M_AD ;
* DEF_BLOQ_AD = MANU 'CHPO' ADAPTATEUR 6 'UX' 0. 'UY' 0. 'UZ' 0. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;
* TMODE_BLOQ_AD . MODES . 1 . DEFORMEE_MODALE = DEF_BLOQ_AD ; 
* Tmode_ad = Tmode_ad et Tmode_bloq_ad ;

*  Tmode_ad = VIBR 'PROCH' (prog 0.1) (lect Nmode_ad) K_ad M_ad ;
 Tmode_ad = VIBR 'IRAM' 0.1 Nmode_ad K_ad M_ad ;

 ptrepad1 = Tmode_ad . modes . 1 . point_repere ;
 ptrepad2 = Tmode_ad . modes . 2 . point_repere ;
 ptrepad3 = Tmode_ad . modes . 3 . point_repere ;
 ptrepad4 = Tmode_ad . modes . 4 . point_repere ;

si (lmad2) ;
* si on veut que l'adaptateur rest horizontal on retire le mode 2 :
Tmodead2 = TABL 'BASE_MODALE' ;
Tmodead2 . 'MODES' = TABL 'BASE_DE_MODES' ;
Tmodead2 . 'MODES' . 'MAILLAGE' = adaptateur ;
Tmodead2 . 'MAILLAGE_REPERE' = VIDE 'MAILLAGE' ;
numode = 1 ; 
repe bm2 nmode_ad ;
*  si (non (&bm2 ega 2)) ;
  si (&bm2 <EG 6) ;
*   implementation maillage repere :
    tmodead2 . 'MAILLAGE_REPERE' = (tmodead2 . 'MAILLAGE_REPERE') et (Tmode_ad . 'MODES' . &bm2 . 'POINT_REPERE') ;
*   renumerotation :
    tmode_ad . modes . &bm2 . 'NUMERO_MODE' = numode ; 
*   implementation mode :
    tmodead2 . modes . numode = tmode_ad . modes . &bm2 ;
*   increment numode :
    numode = numode + 1 ;
  finsi ;
fin bm2 ;
tmode_ad = tmodead2 ;
* on change le nbr de mode pour sauver et initialiser .
nmad = 6 ;
finsi ;
* opti trac x ;
postvibr  tmode_ad ;
* opti donn 5 ; 
*
*pextr_ad = adaptateur poin 'PROC' p2 ; 
** mode1 :
*uzp1m1 = (extr (tmode_ad . modes . 1 . deformee_modale) 'VALE' 'UZ' p1_ad) ;
*uzp2m1 = (extr (tmode_ad . modes . 1 . deformee_modale) 'VALE' 'UZ' p2_ad) ;
*uzscm1 = (extr (tmode_ad . modes . 1 . deformee_modale) 'VALE' 'UZ' scone_ad) ;
** mode2 :
*rymode2 = (extr (tmode_ad . modes . 2 . deformee_modale) 'VALE' 'RY' p1_ad) ;
*uzp1ad = (extr (tmode_ad . modes . 2 . deformee_modale) 'VALE' 'UZ' p1_ad) ;
*uzp2ad = (extr (tmode_ad . modes . 2 . deformee_modale) 'VALE' 'UZ' p2_ad) ;
*uzp3ad = (extr (tmode_ad . modes . 2 . deformee_modale) 'VALE' 'UZ' p3_ad) ;
*uzscad = (extr (tmode_ad . modes . 2 . deformee_modale) 'VALE' 'UZ' scone_ad) ;
**   determination du centre de rotation du mode2 :
*l1thales = l_tot_ad / (1. + (abs (uzp1ad/uzp3ad))) ;
*l2thales = l_tot_ad - l1thales ;
*cdrmode2 = (p1_ad coor 1) + l1thales ; 
**   test de la composante rotation / flexion du mode 2 :
**       p1_ad :
*uztest = rymode2*(abs ((p1_ad coor 1) - cdrmode2)) ;
*valtest1 = (uzp1ad-uztest) ; 
**       p2_ad :
*rym2 = (extr (tmode_ad . modes . 2 . deformee_modale) 'VALE' 'RY' p2_ad) ;
*uztest = rym2*(abs ((p2_ad coor 1) - cdrmode2)) ;
*valtest2 = (uzp2ad-uztest) ; 
**       p3_ad :
*rym2 = (extr (tmode_ad . modes . 2 . deformee_modale) 'VALE' 'RY' p3_ad) ;
*uztest = rym2*(abs ((p2_ad coor 1) - cdrmode2)) ;
*valtest3 = (uzp2ad-uztest) ; 
**       scone_ad :
*rym2 = (extr (tmode_ad . modes . 2 . deformee_modale) 'VALE' 'RY' scone_ad) ;
*uztest = rym2*(abs ((scone_ad coor 1) - cdrmode2)) ;
*valtest4 = (uzscad-uztest) ; 
**       mm offset ?
*list valtest1 ;
*list valtest2 ;
*list valtest3 ;
*list valtest4 ;
** mode4 : 
*uxp1ad = (extr (tmode_ad . modes . 4 . deformee_modale) 'VALE' 'UX' p1_ad) ;
*uxp2ad = (extr (tmode_ad . modes . 4 . deformee_modale) 'VALE' 'UX' p2_ad) ;
*uxscad = (extr (tmode_ad . modes . 4 . deformee_modale) 'VALE' 'UX' scone_ad) ;
** on obtient le mode de translation en bloquant 'RY' sur l'adaptateur :
* cltr = bloq 'RY' (gtot_ad_br) ;
* K_ad_bloq = k_ad et cltr ;  
* Tmode_ad_bloq = VIBR 'IRAM' 0.1 1 K_ad_bloq M_ad ;

****************************************************************************
*                       Assemblage des bases modales 
****************************************************************************
IND_AD = 1 ;
IND_M = 2 ;
*
TMODE_TOT = TABLE 'ENSEMBLE_DE_BASES' ;
* BM manchette : 
TMODE_TOT . IND_AD = TMODE_AD ;
* BM adaptateur :
TMODE_TOT . IND_M = TMODE ; 

**************************************************************
*                   Conditions initiales :
**************************************************************
* CIs manchette :
* orientation vis a vis pion tt debut de calcul :
*# spinini :
spinini = 0. ;

theta_RX = 0. ;
theta_RY = 0. ;
theta_RZ = spinini ; 

WXini = 0. ;
WYini = 0. ;
WZini = 0. ;
  
VXini = 0. ;
VYini = 0. ;
VZini = 0. ;

UXini = 0. ;
UYini = 0. ;
UZini = 0. ;

* CIs ADAPTATEUR :
THETA_RZ_AD = 0. ; 
THETA_RY_AD = 0. ;
THETA_RX_AD = 0. ;
*
WXINI_AD = 0. ;
WYINI_AD = 0. ;
WZINI_AD = 0. ;
*
VXINI_AD = 0. ;
VYINI_AD = 0. ;
VZINI_AD = 0. ;
*
* UXINI_AD = 5.6 * 1.e-5 ;
UXINI_AD = 0. ;
UYINI_AD = 0. ;
UZINI_AD = 0. ;
**************************************************************
*                   Conditions initiales : reprise
**************************************************************
si (reprise) ;
*** manchette :
**** rotations rigides :
*# theta_rx :
theta_rx = 0. ;
*# theta_ry :
theta_ry = 0. ;
*# theta_rz :
theta_rz = 0. ;
**** translations rigides :
*# uxini :
uxini = 0. ;
*# uyini :
uyini = 0. ;
*# uzini :
uzini = 0. ;
*# vxini :
vxini = 0. ;
*# vyini :
vyini = 0. ;
*# vzini :
vzini = 0. ;
*# axini :
axini = 0. ;
*# ayini :
ayini = 0. ;
*# azini :
azini = 0. ;
**
*# wxini :
WXini = 0. ;
*# wyini :
WYini = 0. ;
*# wzini :
WZini = 0. ;
*# arxini :
arXini = 0. ;
*# aryini :
arYini = 0. ;
*# arzini :
arZini = 0. ;
**** ddls elastiques : (manchette --> 4 modes)
*# q1 :
 q1 = 0. ;
*# q1v :
 q1v = 0. ;
*# q2 :
 q2 = 0. ;
*# q2v :
 q2v = 0. ;
*# q3 :
 q3 = 0. ;
*# q3v :
 q3v = 0. ;
*# q4 :
 q4 = 0. ;
*# q4v :
 q4v = 0. ;
*# q5 :
 q5 = 0. ;
*# q5v :
 q5v = 0. ;
*# q6 :
 q6 = 0. ;
*# q6v :
 q6v = 0. ;
*# q7 :
 q7 = 0. ;
*# q7v :
 q7v = 0. ;
*# q8 :
 q8 = 0. ;
*# q8v :
 q8v = 0. ;
*# q1a :
q1a = 0. ;
*# q2a :
q2a = 0. ;
*# q3a :
q3a = 0. ;
*# q4a :
q4a = 0. ;
*# q5a :
q5a = 0. ;
*# q6a :
q6a = 0. ;
*# q7a :
q7a = 0. ;
*# q8a :
q8a = 0. ;
*
lqini = prog q1 q2 q3 q4 q5 q6 q7 q8 ;
lqvini = prog q1v q2v q3v q4v q5v q6v q7v q8v;
lqaini = prog q1a q2a q3a q4a q5a q6a q7a q8a;
*
*** adaptateur :
**** ddls elastiques : (7 modes)
*# q1ad :
 q1ad = 0. ;
*# q1vad :
 q1vad = 0. ;
*# q2ad :
 q2ad = 0. ;
*# q2vad :
 q2vad = 0. ;
*# q3ad :
 q3ad = 0. ;
*# q3vad :
 q3vad = 0. ;
*# q4ad :
 q4ad = 0. ;
*# q4vad :
 q4vad = 0. ;
*# q5ad :
 q5ad = 0. ;
*# q5vad :
 q5vad = 0. ;
*# q6ad :
 q6ad = 0. ;
*# q6vad :
 q6vad = 0. ;
*# q7ad :
 q7ad = 0. ;
*# q7vad :
 q7vad = 0. ;

*# q1aad :
 q1aad = 0. ;
*# q2aad :
 q2aad = 0. ;
*# q3aad :
 q3aad = 0. ;
*# q4aad :
 q4aad = 0. ;
*# q5aad :
 q5aad = 0. ;
*# q6aad :
 q6aad = 0. ;
*# q7aad :
 q7aad = 0. ;
*
lqini_ad = prog q1ad q2ad q3ad q4ad q5ad q6ad q7ad ;
lqvini_ad = prog q1vad q2vad q3vad q4vad q5vad q6vad q7vad ;
lqaini_ad = prog q1aad q2aad q3aad q4aad q5aad q6aad q7aad ;
* fin si reprise.
finsi ;
**************************************************************
*                   Conditions initiales : cas particuliers
**************************************************************
* manchette a plat : 
XCMAJ = 0. ;
YCMAJ = 0. ;
ZCMAJ = 4.68000E-02 ;
*
LRSG = faux ; 
SI LRSG ; 
* Rq : CAS TEST RSG incline :
*  WZini = 1 rad/s --> VYini = - R_tete*WZini
*       --> repere Cast3m : 
  w_ini = 2.*PI ; 
* w_ini = PI ; 
*   EZ = - ex repere Cast3m :
  WXini = (-1.)*w_ini ;
*   EY = ez repere Cast3m :
  VZini = (-1.)*R_tete*w_ini ;
***** NUT = 0., INCID = 0, Rcurv/Rcirc = 1.02
*         depl imp horizontal
  XCMAJ = 9.36001E-04 + (0.02*R_tete) ;
  YCMAJ = 0. ;
  ZCMAJ = 4.77360E-02 + (0.02*R_tete) ;
  NPEX = 1. ;
  NPEY = 0. ;
  NPEZ = 0. ;

  UXini = (Scone COOR 1) + ((-1.)*(P2 COOR 1)) + ((-1.)*ZCMAJ) ;
  UYini = (Scone COOR 2) + ((-1.)*(P2 COOR 2)) + ((-1.)*XCMAJ) ;
  UZini = (Scone COOR 3) + ((-1.)*(P2 COOR 3)) + YCMAJ ;

  LDI = vrai ; 
  SI LDI ;
*   Valeur du depl. radial :
    DIMP = 2.e-10 ; 
*   Dans le repère Cast3m :
*       EZ = (-1.) 0. 0. ;
*       EX = 0. -1. 0. ; 
*       Ey = 0. 0. 1. ;
    UXini = UXini + (DIMP*(-1.)*NPEZ) ;
    UYini = UYini + (DIMP*(-1.)*NPEX) ;
    UZini = UZini + (DIMP*NPEY) ;
  FINSI ; 

FINSI ; 

lchoc45 = faux ; 
SI lchoc45 ; 
* ZCMAJ = 1.04*R_tete ;
* XCMAJ = (0.04/2.)*R_tete ;
  deltah = 1.e-2 ;
  ZCMAJ = R_tete + deltah ;
  XCMAJ = (deltah/2.) ;
  YCMAJ = 0. ;
* NPEX = 1. ;
* NPEY = 0. ;
* NPEZ = 0. ;
  UXini = (Scone COOR 1) + ((-1.)*(P2 COOR 1)) + ((-1.)*ZCMAJ) ;
  UYini = (Scone COOR 2) + ((-1.)*(P2 COOR 2)) + ((-1.)*XCMAJ) ;
  UZini = (Scone COOR 3) + ((-1.)*(P2 COOR 3)) + YCMAJ ;
* vitesse horiz selon ey 
  VYini = 0.3 ;
FINSI ; 

lchute = faux ; 
SI lchute ; 
  deltah = 1.*1.e-2 ;
*  ZCMAJ = 1.1*R_tete ;
*  XCMAJ = (0.1/2.)*R_tete ;
  ZCMAJ = R_tete + deltah ;
* decalage positif direction EX
  XCMAJ = (deltah/2.) ;
  YCMAJ = 0. ;
* NPEX = 1. ;
* NPEY = 0. ;
* NPEZ = 0. ;
  UXini = (Scone COOR 1) + ((-1.)*(P2 COOR 1)) + ((-1.)*ZCMAJ) ;
  UYini = (Scone COOR 2) + ((-1.)*(P2 COOR 2)) + ((-1.)*XCMAJ) ;
  UZini = (Scone COOR 3) + ((-1.)*(P2 COOR 3)) + YCMAJ ;
* inclinaison positive autour de EY  
  Theta_rz = 2. ;
FINSI ; 
***** NUT = 0., INCID = 0, Rcurv/Rcirc = 1.02
*         depl imp vertical
* XCMAJ = 0. ;
* YCMAJ = 0. ;
* ZCMAJ = 4.68E-02 ;
* NPEX = 0. ;
* NPEY = 0. ;
* NPEZ = -1. ;

***** NUT = 0., INCID = 0, Rcurv/Rcirc = 1., DIMP = 10.e-6
*         depl imp vertical
* ZC = (R_tete + (2.e-6)) ;
* *
* * pour avoir une elevation ZC par rapport au sommet du cone 
* *     AVANT mise en tangence avec l'ellipse!
* UXini = (Scone COOR 1) + ((-1.)*ZC) + ((-1.)*(P2 COOR 1)) ;
* MESS (CHAI 'avant mise en tangence UXini ='Uxini) ;

* XCMAJ = 0. ;
* YCMAJ = 0. ;
* ZCMAJ = 4.68000E-02 ;
* NPEX = 0. ;
* NPEY = 0. ;
* NPEZ = -1. ;
* --> si on veut depl vertical vers le bas il faut un - a NPEZ.

***** NUT = 10., INCID = 0, Rcurv/Rcirc = 1., DIMP = 10.e-6
* Avant mise en tangence ZC = 0.0475219654 
* Mise en tangence avec l'ellipse :
*   (Dans le repere de l'adaptateur)
*       EZ = (-1.) 0. 0. ;
*       EX = 0. -1. 0. ; 
*       Ey = 0. 0. 1. ;
* XCMAJ = -5.69040E-03 ;
* YCMAJ = 0. ; 
* ZCMAJ = 4.85253E-02 ;

* NPEX = 9.84808E-01 ;
* NPEY = 0.00000E+00 ;
* NPEZ = -1.73648E-01 ;

* ***** Application des XCMAJ YCMAJ ZCMAJ initiaux

***** Ajout depl. imp. initial ? 


* opti donn 5 ;
****************************************************************************
*                       PARAMETRES LIAISONS 
****************************************************************************
**** CCONE 
*# Normale_cone
Normale_cone = -1. 0. 0. ;
*# Normale_cercle
Normale_cercle = -1. 0. 0. ;

*# amo_ccone :
amo_ccone = 3.4 ;

*# Normale point cercle mobile : 
Normale_pcerc = 1. 0. 0. ;
*
Rayon_supp = R_tete ;

**** CERCLE - CERCLE :
* Kchoc = 2.E+06;
* On prend la raideur d'ovalisation analytique :
Kchoc = 3.8*E*(epai**2)*((epai/D_ext)**0.5)/D_ext ; 
*test :
* kchoc = 1.e8 ;
* opti donn 5  ;
* Freq_max = ((Kchoc/MTOT_MANCH)**0.5)/(2.*Pi) ;

*# K_T 
K_T= 0.*Kchoc ;

* old :
* K_T= 0.01*Kchoc ;

*# xi :
xi = 0.01 ;
*# mu
mu = 0.6 ;

*# adh
adh = 0.03 ;

*# Cchoc
* Cchoc = 0.*((MTOT_MANCH*Kchoc)**0.5) ;

omegachoc = (Kchoc/MTOT_MANCH)**0.5 ;
Cchoc = 2.*Mtot_manch*omegachoc*xi ;

* pour les pions :
alphap = 120. ;
excpb1 = ((-1.)*(h_pion)) * ey ;
excpb2 = (((cos alphap)*(h_pion)) * ey) plus (((sin alphap)*(h_pion)) * ex);
excpb3 = (((cos alphap)*(h_pion)) * ey) plus (((-1.)*((sin alphap)*(h_pion))) * ex);
****************************************************************************
*                       SORTIE 
****************************************************************************
SI (POSTRAITEMENT EGA VRAI ) ;
* name_fic = (chai script'_T_'T'_PDT_'DTe'_NSORT_'NSORT'_THRZ_'THETA_RZ'_Kchoc_'Kchoc'_Wy_'WYini'_Wz_'WZini'.ps') ;
* opti 'FTRA' (chai 'fig/'script'_T_'T'_PDT_'DTe'_NSORT_'NSORT'_THRZ_'THETA_RZ'_Kchoc_'Kchoc'_Wy_'WYini'_Wz_'WZini'.ps') ;
oeil1 = (L_tete)  0.  (L_tot/20.)  ;
FINSI ;

****************************************************************************
*                       conditions initiales : implementation 
****************************************************************************

*************
* MANCHETTE :
*************
* au debut les angles sont donnes en degres :
U0_RX = MANU 'CHPO' PTREP_M_RX 'NATUR' 'DIFFUS' 'ALFA' (theta_RX*Pi/180.) ;
U0_RY = MANU 'CHPO' PTREP_M_RY 'NATUR' 'DIFFUS' 'ALFA' (theta_RY*Pi/180.) ;
U0_RZ = MANU 'CHPO' PTREP_M_RZ 'NATUR' 'DIFFUS' 'ALFA' (theta_RZ*Pi/180.) ;

* reprise : les angles ont ete calcules avec quat2vect
* on veut garder la precision donc on laisse en radians.
* slice 0 : calcul avec fort amortissement dont les resultats sont repris des slice 1.
* si ((reprise) et (slice >EG 2)) ;
si ((reprise) et (slice >EG 1)) ;
U0_RX = MANU 'CHPO' PTREP_M_RX 'NATUR' 'DIFFUS' 'ALFA' (theta_RX) ;
U0_RY = MANU 'CHPO' PTREP_M_RY 'NATUR' 'DIFFUS' 'ALFA' (theta_RY) ;
U0_RZ = MANU 'CHPO' PTREP_M_RZ 'NATUR' 'DIFFUS' 'ALFA' (theta_RZ) ;
finsi ;

U0_TX = MANU 'CHPO' PTREP_M_TX 'NATUR' 'DIFFUS' 'ALFA' UXINI ;
U0_TY = MANU 'CHPO' PTREP_M_TY 'NATUR' 'DIFFUS' 'ALFA' UYINI ;
U0_TZ = MANU 'CHPO' PTREP_M_TZ 'NATUR' 'DIFFUS' 'ALFA' UZINI ;

*Vitesse de rotation :
V0_RX = MANU 'CHPO' PTREP_M_RX 'NATUR' 'DIFFUS' 'ALFA' WXini ;
V0_RY = MANU 'CHPO' PTREP_M_RY 'NATUR' 'DIFFUS' 'ALFA' WYini ;
V0_RZ = MANU 'CHPO' PTREP_M_RZ 'NATUR' 'DIFFUS' 'ALFA' WZini ; 

*Vitesse de translation : 
V0_P_TX = MANU 'CHPO' PTREP_M_TX 'NATURE' 'DIFFUS' 'ALFA' VXini ;
V0_P_TY = MANU 'CHPO' PTREP_M_TY 'NATURE' 'DIFFUS' 'ALFA' VYini ;
V0_P_TZ = MANU 'CHPO' PTREP_M_TZ 'NATURE' 'DIFFUS' 'ALFA' VZini ;
*
V0_P_TRANS = ( V0_P_TX et V0_P_TX et V0_P_TZ ) ;
U0_P = (U0_RZ et U0_RY et U0_RX et U0_TX et U0_TY et U0_TZ) ;
V0_P = (V0_RX et V0_RY et V0_RZ et V0_P_TRANS) ;

*************
* ADAPTATEUR :
*************
si lraidtimo ;
  U0_RX_AD = MANU 'CHPO' PTREP_AD_RX 'NATUR' 'DIFFUS' 'ALFA' (THETA_RX_AD*Pi/180.) ;
  U0_RY_AD = MANU 'CHPO' PTREP_AD_RY 'NATUR' 'DIFFUS' 'ALFA' (THETA_RY_AD*Pi/180.) ;
  U0_RZ_AD = MANU 'CHPO' PTREP_AD_RZ 'NATUR' 'DIFFUS' 'ALFA' (THETA_RZ_AD*Pi/180.) ;
*      
  U0_TX_AD = MANU 'CHPO' PTREP_AD_TX 'NATUR' 'DIFFUS' 'ALFA' UXINI_AD ;
  U0_TY_AD = MANU 'CHPO' PTREP_AD_TY 'NATUR' 'DIFFUS' 'ALFA' UYINI_AD ;
  U0_TZ_AD = MANU 'CHPO' PTREP_AD_TZ 'NATUR' 'DIFFUS' 'ALFA' UZINI_AD ;
*
* Vitesse de rotation :
  V0_RX_AD = MANU 'CHPO' PTREP_AD_RX 'NATUR' 'DIFFUS' 'ALFA' WXINI_AD ;
  V0_RY_AD = MANU 'CHPO' PTREP_AD_RY 'NATUR' 'DIFFUS' 'ALFA' WYINI_AD ;
  V0_RZ_AD = MANU 'CHPO' PTREP_AD_RZ 'NATUR' 'DIFFUS' 'ALFA' WZINI_AD ; 
* Vitesse de translation : 
* translations rigides:
  V0_P_TX_AD = MANU 'CHPO' PTREP_AD_TX 'NATURE' 'DIFFUS' 'ALFA' VXINI_AD ;
  V0_P_TY_AD = MANU 'CHPO' PTREP_AD_TY 'NATURE' 'DIFFUS' 'ALFA' VYINI_AD ;
  V0_P_TZ_AD = MANU 'CHPO' PTREP_AD_TZ 'NATURE' 'DIFFUS' 'ALFA' VZINI_AD ;
*
  V0_P_TRANS_AD = ( V0_P_TX_AD et V0_P_TX_AD et V0_P_TZ_AD ) ;
*
  U0_P = U0_P ET ( U0_RZ_AD et U0_RY_AD et U0_RX_AD et U0_TX_AD et U0_TY_AD et U0_TZ_AD) ;
  V0_P = V0_P ET ( V0_RX_AD et V0_RY_AD et V0_RZ_AD et V0_P_TRANS_AD) ;
finsi ;

si (reprise) ;
**** reprise : Remarque importante !! : 
* on a fait tmode = tmode et tmode_m_rig :
* la boucle bqini ne fonctionne que si on garde cette ordre.
* ne pas faire : tmode = tmode_m_rig et tmode.
* ddls elastiques manchette :
*acceleration angulaire de rotation :
A0_RX = MANU 'CHPO' PTREP_M_RX 'NATUR' 'DIFFUS' 'ALFA' ARXini ;
A0_RY = MANU 'CHPO' PTREP_M_RY 'NATUR' 'DIFFUS' 'ALFA' ARYini ;
A0_RZ = MANU 'CHPO' PTREP_M_RZ 'NATUR' 'DIFFUS' 'ALFA' ARZini ; 
*Acceleration en translation : 
A0_P_TX = MANU 'CHPO' PTREP_M_TX 'NATURE' 'DIFFUS' 'ALFA' AXini ;
A0_P_TY = MANU 'CHPO' PTREP_M_TY 'NATURE' 'DIFFUS' 'ALFA' AYini ;
A0_P_TZ = MANU 'CHPO' PTREP_M_TZ 'NATURE' 'DIFFUS' 'ALFA' AZini ;

A0_P_TRANS = ( A0_P_TX et A0_P_TX et A0_P_TZ ) ;
A0_P = (A0_RX et A0_RY et A0_RZ et A0_P_TRANS) ;

  repe bqini (nmode - n_tronq) ;
    ptrpi = tmode . modes . &bqini . point_repere ; 
    ui =  MANU 'CHPO' ptrpi 'NATUR' 'DIFFUS' 'ALFA' (extr lqini &bqini) ;
    vi =  MANU 'CHPO' ptrpi 'NATUR' 'DIFFUS' 'ALFA' (extr lqvini &bqini) ;
    ai =  MANU 'CHPO' ptrpi 'NATUR' 'DIFFUS' 'ALFA' (extr lqaini &bqini) ;
    u0_p = u0_p et ui ;
    v0_p = v0_p et vi ;
    a0_p = a0_p et ai ;
  fin bqini ;
* ddls elastiques adaptateur :
* petit check si on a retire le 2eme mode de l'adapter :
  repe bqiniad (nmad) ;
    ptrpi = tmode_ad . modes . &bqiniad . point_repere ; 
    ui =  MANU 'CHPO' ptrpi 'NATUR' 'DIFFUS' 'ALFA' (extr lqini_ad &bqiniad) ;
    vi =  MANU 'CHPO' ptrpi 'NATUR' 'DIFFUS' 'ALFA' (extr lqvini_ad &bqiniad) ;
    ai =  MANU 'CHPO' ptrpi 'NATUR' 'DIFFUS' 'ALFA' (extr lqaini_ad &bqiniad) ;
    u0_p = u0_p et ui ;
    v0_p = v0_p et vi ;
    a0_p = a0_p et ai ;
  fin bqiniad ;
finsi ;
*
TINI = TABLE 'INITIAL';
TINI . 'DEPLACEMENT' = U0_P ;
TINI . 'VITESSE'     = V0_P ;

si (reprise) ;
TINI = TABLE 'INITIAL';
TINI . 'DEPLACEMENT' = U0_P ;
TINI . 'VITESSE'     = V0_P ;
TINI . 'ACCELERATION'     = A0_P ;
finsi ; 

****************************************************************************   
*              CHARGEMENT 
****************************************************************************
* POIDS :
*************
* MANCHETTE :
*************
FEX1 = FORC 'FX' (MTOT_MANCH*grav) GTOT_MANCH ;    
FEX1_P = PJBA FEX1 TMODE_M_TX ;
Fprog = prog (dime tprog)*1. ; 
evol0 = evol 'ROSE' 'MANU' 't' tprog 'F' Fprog;     
CHA1_P = CHAR 'FORC' FEX1_P evol0 ;   
CHA1 = CHAR 'FORC' FEX1 evol0 ;

*************
* ADAPTATEUR :
*************
FEX1_AD = FORC 'FX' (MTOT_AD*grav) gtot_ad_br ;    
si (lraidtimo) ;
  FEX1_AD_P = PJBA FEX1_AD TMODE_AD_TX ;
sinon ; 
  fex1_ad_p = pjba fex1_ad tmode_ad ;
finsi ;
Fprog = prog (dime tprog)*1. ; 
evol0 = evol 'ROSE' 'MANU' 't' tprog 'F' Fprog;     
CHA1_AD_P = CHAR 'FORC' FEX1_AD_P evol0 ;   
CHA1_AD = CHAR 'FORC' FEX1_AD evol0 ;

*************
* SINUS :
*************
* Freq = 8.6574 ; 
FEX2   = FORC 'FZ' Fext GTOT_AD_BR ;
FEX2_P = PJBA FEX2 TMODE_AD ;
evol2 = evol 'ROSE' 'MANU' 't' tprog 'F' Fprog2 ;
CHA2_P = CHAR 'FORC' FEX2_P evol2 ;   
CHA2 = CHAR 'FORC' FEX2 evol2 ;

**** TCHAR :
TCHAR = TABL 'CHARGEMENT';
TCHAR .'BASE_B' = TABLE ;  
* TCHAR .'BASE_B' = CHA1 et cha1_ad  ;
TCHAR .'BASE_B' = CHA1 et cha1_ad et cha2 ;

* Base A: pour la chute libre (FEXB n'est pas introduit dans le calcul de FTOTA, contrairement aux forces de liasons qui sont projetees dasn devpro)
*   On doit definir le poids en base 1 sans quoi le solide ne chute pas :
TCHAR .'BASE_A' = TABLE ;  
* TCHAR .'BASE_A' = CHA1_P et cha1_ad_p ;  
TCHAR .'BASE_A' = CHA1_P et cha1_ad_p et cha2_p ;  

****************************************************************************   
*              LIAISONS 
****************************************************************************  
*   Seul Oden est disponible :
TL1 = TABLE 'LIAISON_ELEMENTAIRE' ;
TL1.'TYPE_LIAISON'  =  MOT 'CERCLE_CONE' ;
TL1.'SUPPORT'       =  P2                 ;
TL1.'RAYON_CERCLE' =  R_TETE         ;    
TL1.'NORMALE_CERCLE'   =  NORMALE_CERCLE      ;  
TL1.'NORMALE_CONE'       =  NORMALE_CONE      ;
TL1.'RAIDEUR'       =  KCHOC              ;
TL1.'RAIDEUR_VERTICALE'       =  KCHOC              ;
*     Oden : AMO_TANG = vitesse limite d'adherence
TL1.'VITESSE_LIMITE_ADHERENCE' = vlimoden    ;
* TL1.'VITESSE_LIMITE_ADHERENCE' = 1.e-4    ;
* relation amor pour un contact ccone total (a plat) a 1 m . s^-1 :
* 2.*np.pi*R_tete*vref*eta = 1 %
* - vref = 1 m.s^-1 --> eta = 3.4
TL1.'AMORTISSEMENT' = amo_ccone        ;
* TL1.'AMORTISSEMENT' = 0.                  ;
si (non LCONEFIXE) ;
  TL1.'SOUS_BASE_CONE' = ind_ad             ;
finsi ;
si (LCONEFIXE) ;
  TL1.'SOUS_BASE_CONE' = -1             ;
finsi ;
TL1.'COEFFICIENT_GLISSEMENT'   =  MU      ;
TL1.'SOMMET_CONE' = SCONE_AD ;    
TL1.'ANGLE_CONE' = 45. ;
TL1.'ECHANTILLONNAGE' = 41 ;

TLP_M = TABLE 'LIAISON_ELEMENTAIRE' ;
TLP_M.'TYPE_LIAISON'  =  MOT 'POINT_CERCLE_FROTTEMENT' ;
TLP_M.'SUPPORT'       =  GTOT_MANCH         ;
TLP_M.'NORMALE'       =  Normale_CONE      ;
TLP_M.'RAIDEUR'       =  Kchoc              ;
TLP_M.'RAYON'         =  10.        ;
TLP_M.'AMORTISSEMENT_TANGENTIEL' =  Cchoc   ;
TLP_M.'EXCENTRATION' =   0. 0. 0.           ;
TLP_M.'COEFFICIENT_GLISSEMENT'   =  mu      ;
TLP_M.'COEFFICIENT_ADHERENCE'   =  adh      ;
TLP_M.'RAIDEUR_TANGENTIELLE' = K_T          ;

TLP_A = TABLE 'LIAISON_ELEMENTAIRE' ;
TLP_A.'TYPE_LIAISON'  =  MOT 'POINT_CERCLE_FROTTEMENT' ;
TLP_A.'SUPPORT'       =  GTOT_AD_BR         ;
TLP_A.'NORMALE'       =  Normale_CONE      ;
TLP_A.'RAIDEUR'       =  Kchoc              ;
TLP_A.'RAYON'         =  10.        ;
TLP_A.'AMORTISSEMENT_TANGENTIEL' =  Cchoc   ;
TLP_A.'EXCENTRATION' =   0. 0. 0.           ;
TLP_A.'COEFFICIENT_GLISSEMENT'   =  mu      ;
TLP_A.'COEFFICIENT_ADHERENCE'   =  adh      ;
TLP_A.'RAIDEUR_TANGENTIELLE' = K_T          ;
*

si (lpcirc) ;

excpcircb1 = ((-1.)*h_pion)*EY ;
excpcircb2 = (h_pion*((sin 30.)*EY)) plus (h_pion*((cos 30.)*EX)) ;
excpcircb3 = (h_pion*((sin 30.)*EY)) plus (h_pion*(((-1.)*(cos 30.))*EX)) ;

jeup = ((DINT_A/2.) - (D_ext/2.)) ;

jeuph = ((DINT_A/2.) - (D_ext/2.) - h_pion) ;

  TLpcirch1 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpcirch1.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpcirch1.'POINT'                     =  ph           ;
  TLpcirch1.'CERCLE'                    =  ph_ad        ;
  TLpcirch1.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLpcirch1.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpcirch1.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpcirch1.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpcirch1.'RAIDEUR'                   = Kchoc    ;
  TLpcirch1.'AMORTISSEMENT_TANGENTIEL'  = Cchoc  ;
  TLpcirch1.'EXCENTRATION' =     excpcircb1         ;
  TLpcirch1.'NORMALE'                   = normale_cone ;
  TLpcirch1.'RAYON'                     = jeup          ;

  TLpcirch2 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpcirch2.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpcirch2.'POINT'                     =  ph           ;
  TLpcirch2.'CERCLE'                    =  ph_ad        ;
  TLpcirch2.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLpcirch2.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpcirch2.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpcirch2.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpcirch2.'RAIDEUR'                   = Kchoc    ;
  TLpcirch2.'AMORTISSEMENT_TANGENTIEL'  = Cchoc  ;
  TLpcirch2.'EXCENTRATION' =     excpcircb2         ;
  TLpcirch2.'NORMALE'                   = normale_cone ;
  TLpcirch2.'RAYON'                     = jeup          ;

  TLpcirch3 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpcirch3.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpcirch3.'POINT'                     =  ph           ;
  TLpcirch3.'CERCLE'                    =  ph_ad        ;
  TLpcirch3.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLpcirch3.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpcirch3.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpcirch3.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpcirch3.'RAIDEUR'                   = Kchoc    ;
  TLpcirch3.'AMORTISSEMENT_TANGENTIEL'  = Cchoc  ;
  TLpcirch3.'EXCENTRATION' =     excpcircb3         ;
  TLpcirch3.'NORMALE'                   = normale_cone ;
  TLpcirch3.'RAYON'                     = jeup          ;
*
  TLpcircb1  = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpcircb1 .'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpcircb1 .'POINT'                     =  pb           ;
  TLpcircb1 .'CERCLE'                    =  pb_ad        ;
  TLpcircb1 .'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLpcircb1 .'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpcircb1 .'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpcircb1 .'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpcircb1 .'RAIDEUR'                   = Kchoc    ;
  TLpcircb1 .'AMORTISSEMENT_TANGENTIEL'  = Cchoc  ;
  TLpcircb1 .'EXCENTRATION' =     excpcircb1         ;
  TLpcircb1 .'NORMALE'                   = normale_cone ;
  TLpcircb1 .'RAYON'                     = jeup          ;

  TLpcircb2  = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpcircb2 .'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpcircb2 .'POINT'                     =  pb           ;
  TLpcircb2 .'CERCLE'                    =  pb_ad        ;
  TLpcircb2 .'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLpcircb2 .'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpcircb2 .'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpcircb2 .'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpcircb2 .'RAIDEUR'                   = Kchoc    ;
  TLpcircb2 .'AMORTISSEMENT_TANGENTIEL'  = Cchoc  ;
  TLpcircb2 .'EXCENTRATION' =     excpcircb2         ;
  TLpcircb2 .'NORMALE'                   = normale_cone ;
  TLpcircb2 .'RAYON'                     = jeup          ;

  TLpcircb3  = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpcircb3 .'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpcircb3 .'POINT'                     = pb           ;
  TLpcircb3 .'CERCLE'                    = pb_ad        ;
  TLpcircb3 .'CONTACT_INTERIEUR'         = 'VRAI'        ;
  TLpcircb3 .'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpcircb3 .'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpcircb3 .'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpcircb3 .'RAIDEUR'                   = Kchoc    ;
  TLpcircb3 .'AMORTISSEMENT_TANGENTIEL'  = Cchoc  ;
  TLpcircb3 .'EXCENTRATION' =     excpcircb3         ;
  TLpcircb3 .'NORMALE'                   = normale_cone ;
  TLpcircb3 .'RAYON'                     = jeup          ;
finsi ;
*
* opti donn 5 ;
si (lpion) ;
* conseil de benoit :
jeup = ((DINT_A/2.) - (D_ext/2.)) ;
* jeup = (DINT_A/2.) ;
* opti donn 5 ; 
* pions haut : 
  TLph1 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLph1.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLph1.'POINT'                     =  ph           ;
  TLph1.'CERCLE'                    =  ph_ad        ;
  TLph1.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLph1.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLph1.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLph1.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLph1.'RAIDEUR'                   = Kchoc    ;
  TLph1.'AMORTISSEMENT_TANGENTIEL'  = 0.01  ;
  TLph1.'EXCENTRATION' =     excpb1         ;
  TLph1.'NORMALE'                   = normale_cone ;
  TLph1.'RAYON'                     = jeup          ;

  TLph2 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLph2.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLph2.'POINT'                     =  ph           ;
  TLph2.'CERCLE'                    =  ph_ad        ;
  TLph2.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLph2.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLph2.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLph2.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLph2.'RAIDEUR'                   = Kchoc    ;
  TLph2.'AMORTISSEMENT_TANGENTIEL'  = 0.01  ;
  TLph2.'EXCENTRATION' =   excpb2            ;
  TLph2.'NORMALE'                   = normale_cone            ;
  TLph2.'RAYON'                     = jeup          ;

  TLph3 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLph3.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLph3.'POINT'                     =  ph           ;
  TLph3.'CERCLE'                    =  ph_ad        ;
  TLph3.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLph3.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLph3.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLph3.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLph3.'RAIDEUR'                   = Kchoc    ;
  TLph3.'AMORTISSEMENT_TANGENTIEL'  = 0.01  ;
  TLph3.'EXCENTRATION' =   excpb3            ;
  TLph3.'NORMALE'                   = normale_cone            ;
  TLph3.'RAYON'                     = jeup          ;
* pions bas : 
  TLpb1 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpb1.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpb1.'POINT'                     =  pb           ;
  TLpb1.'CERCLE'                    =  pb_ad        ;
  TLpb1.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLpb1.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpb1.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpb1.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpb1.'RAIDEUR'                   = Kchoc    ;
  TLpb1.'AMORTISSEMENT_TANGENTIEL'  = 0.01  ;
  TLpb1.'EXCENTRATION' =     excpb1         ;
  TLpb1.'NORMALE'                   = normale_cone            ;
  TLpb1.'RAYON'                     = jeup          ;

  TLpb2 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpb2.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpb2.'POINT'                     =  pb           ;
  TLpb2.'CERCLE'                    =  pb_ad        ;
  TLpb2.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLpb2.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpb2.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpb2.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpb2.'RAIDEUR'                   = Kchoc    ;
  TLpb2.'AMORTISSEMENT_TANGENTIEL'  = 0.01  ;
  TLpb2.'EXCENTRATION' =   excpb2            ;
  TLpb2.'NORMALE'                   = normale_cone            ;
  TLpb2.'RAYON'                     = jeup          ;

  TLpb3 = TABLE 'LIAISON_ELEMENTAIRE' ;
  TLpb3.'TYPE_LIAISON'= MOT 'POINT_CERCLE_MOBILE';
  TLpb3.'POINT'                     =  pb           ;
  TLpb3.'CERCLE'                    =  pb_ad        ;
  TLpb3.'CONTACT_INTERIEUR'         =  'VRAI'        ;
  TLpb3.'COEFFICIENT_GLISSEMENT'    = mu          ;
  TLpb3.'COEFFICIENT_ADHERENCE'     = adh          ;
  TLpb3.'RAIDEUR_TANGENTIELLE'      = K_T ;
  TLpb3.'RAIDEUR'                   = Kchoc    ;
  TLpb3.'AMORTISSEMENT_TANGENTIEL'  = 0.01  ;
  TLpb3.'EXCENTRATION' =   excpb3            ;
  TLpb3.'NORMALE'                   = normale_cone            ;
  TLpb3.'RAYON'                     = jeup          ;
finsi ;
* opti donn 5 ; 
*   On définit la liaison en base A et en base B:
TLIAI = TABLE 'LIAISON'   ;
TTLB = TABLE 'LIAISON_B' ;
TLIAI .'LIAISON_B' = TTLB  ;
TTLB . 1 = TL1 ;
TTLB . 2 = TLP_M ;
TTLB . 3 = TLP_A ;

si (lpion) ;
 TTLB . 4 = TLpb1 ;
 TTLB . 5 = TLpb2 ;
 TTLB . 6 = TLpb3 ;
 TTLB . 7 = TLph1 ;
 TTLB . 8 = TLph2 ;
 TTLB . 9 = TLph3 ;
finsi ;

si (lpcirc) ;
 TTLB . 4 = TLpcircb1 ;
 TTLB . 5 = TLpcircb2 ;
 TTLB . 6 = TLpcircb3 ;
 TTLB . 7 = TLpcirch1 ;
 TTLB . 8 = TLpcirch2 ;
 TTLB . 9 = TLpcirch3 ;
finsi ;

****************************************************************************
*           SORTIE
****************************************************************************
TSORT = TABLE 'SORTIE';
TSORT . 'VARIABLE'  = table 'VARIABLE' ;
TSORT . 'VARIABLE' . 'TYPE_SORTIE'  = mot 'LISTREEL';
TSORT . 'VARIABLE' . 'ACCELERATION' = faux ;
TSORT . 'VARIABLE' . 'VITESSE' = vrai ;
* Sortie LIAISON :
TSORL = TABLE 'LIAISON_B' ;
TSORT . 'LIAISON_B' = TSORL ;

si (non LSMALLEXIT) ;
TSORT . 'VARIABLE' . 'ACCELERATION' = VRAI;
* MOMENT_CINETIQUE : 
TSORT . 'VARIABLE' . 'TRAVAIL_INTERIEUR' = VRAI ;
* ENERGIE_CINETIQUE :
TSORT . 'VARIABLE' . 'TRAVAIL_EXTERIEUR' = VRAI ;

* liaison cercle-cone :
TSTL1 = table ;
TSTL1 . 'FORCE_DE_CHOC_NORMALE' = VRAI ;
TSTL1 . 'FORCE_DE_CHOC_TANGENTIELLE' = VRAI ;
TSTL1 . 'MX_POINT_FIBRE_NEUTRE' = VRAI ;
TSTL1 . 'MY_POINT_FIBRE_NEUTRE' = VRAI ;
TSTL1 . 'MZ_POINT_FIBRE_NEUTRE' = VRAI ;
*sorties rajoutees : 
TSTL1 . 'PENETRATION_NORMALE' = VRAI ; 
TSTL1 . 'RAYON_COURBURE' = VRAI ; 
TSTL1 . 'NUTATION' = VRAI ; 
TSTL1 . 'LARGEUR_PROFILE' = VRAI ; 
TSTL1 . 'ANGLE_INCIDENCE' = VRAI ; 
TSTL1 . 'FX_BASE_B' = VRAI ; 
TSTL1 . 'FY_BASE_B' = VRAI ; 
TSTL1 . 'FZ_BASE_B' = VRAI ; 

TSTL1 . 'UX_POINT_DE_CONTACT' = VRAI ;
TSTL1 . 'UY_POINT_DE_CONTACT' = VRAI ;
TSTL1 . 'UZ_POINT_DE_CONTACT' = VRAI ;

TSTL1 . 'VX_POINT_CONTACT' = VRAI ;
TSTL1 . 'VY_POINT_CONTACT' = VRAI ;
TSTL1 . 'VZ_POINT_CONTACT' = VRAI ;

TSTL1 . 'PUISSANCE_USURE_INSTANTANEE' = VRAI ;
TSTL1 . 'POURCENTAGE_GLISS_ADH' = VRAI ;

TSTL1 . 'NOMBRE_ITERATIONS' = VRAI ;
TSTL1 . 'RESIDU' = VRAI ;

TSORL . TL1 = TSTL1 ; 
TSORL . tlp_a = vrai ; 
TSORL . tlp_m = vrai ; 

si (lpion) ;
tstlpb1 = table ; 
tstlpb1 . 'FORCE_DE_CHOC_NORMALE' = VRAI ;
tstlpb1 . 'FORCE_DE_CHOC_TANGENTIELLE' = VRAI ;
tstlpb1 . 'PUISSANCE_USURE_INSTANTANEE' = VRAI ;
* bas : 
TSORL . tlpb1 = tstlpb1 ; 
TSORL . tlpb2 = tstlpb1 ; 
TSORL . tlpb3 = tstlpb1 ; 
* haut : 
TSORL . tlph1 = tstlpb1 ; 
TSORL . tlph2 = tstlpb1 ; 
TSORL . tlph3 = tstlpb1 ; 
finsi ; 
* fin si non LSMALLEXIT :
finsi ;

si (lpcirc) ;
tstlpb1 = table ; 
tstlpb1 . 'FORCE_DE_CHOC_NORMALE' = VRAI ;
tstlpb1 . 'FORCE_DE_CHOC_TANGENTIELLE' = VRAI ;
tstlpb1 . 'PUISSANCE_USURE_INSTANTANEE' = VRAI ;
* bas : 
TSORL . tlpcirch1 = tstlpb1 ; 
TSORL . tlpcirch2 = tstlpb1 ; 
TSORL . tlpcirch3 = tstlpb1 ; 
* haut : 
TSORL . tlpcircb1 = tstlpb1 ; 
TSORL . tlpcircb2 = tstlpb1 ; 
TSORL . tlpcircb3 = tstlpb1 ; 
finsi ; 
* fin si non LSMALLEXIT :
finsi ;

si (LSMALLEXIT) ;
* liaison cercle-cone :
TSTL1 = table ;
TSTL1 . 'FORCE_DE_CHOC_NORMALE' = VRAI ;

TSORL . TL1 = TSTL1 ; 
TSORL . tlp_a = faux ; 
TSORL . tlp_m = faux ; 
si (lpion) ;
tstlpb1 = table ; 
tstlpb1 . 'FORCE_DE_CHOC_NORMALE' = VRAI ;
* bas : 
TSORL . tlpb1 = tstlpb1 ; 
TSORL . tlpb2 = tstlpb1 ; 
TSORL . tlpb3 = tstlpb1 ; 
* haut : 
TSORL . tlph1 = tstlpb1 ; 
TSORL . tlph2 = tstlpb1 ; 
TSORL . tlph3 = tstlpb1 ; 
finsi ; 
* fin si LSMALLEXIT :
finsi ; 
****************************************************************************
*           Tamor
****************************************************************************
L_amor_ad = prog ;
repe bamoad (nmode_ad) ;
  mui = tmode_ad . modes . &bamoad . 'MASSE_GENERALISEE' ;
  fi  = tmode_ad . modes . &bamoad . 'FREQUENCE' ;
  ci = (2.*mui*(2.*pi*fi)*amode_ad) ;
  l_amor_ad = l_amor_ad et ci ;
  mess (chai 'mui = 'mui) ;
  mess (chai 'fi = 'fi) ;
fin bamoad ;
*
tamor . 'AMORTISSEMENT' = (tamor . 'AMORTISSEMENT') et (AMOR tmode_ad l_amor_ad) ;
****************************************************************************
*           DYNE
****************************************************************************

'TEMP' 'ZERO' ;
si (lamode) ;
TRESU = DYNE 'RKMK4' TMODE_TOT TCHAR TLIAI Tamor TINI TSORT NPASe DTe NSORT;
sinon ;
TRESU = DYNE 'RKMK4' TMODE_TOT TCHAR TLIAI TINI TSORT NPASe DTe NSORT;
finsi ;
ctime = ('TEMP' 'ENTI' 'HORL') ;

**** temps de sortie :
tprog = TRESU . TEMPS_DE_SORTIE ;
Nt = dime tprog ;
* opti donn 5 ; 
**** 'Nouveaux' ptreps rotas rigides :
* MANCHETTE :
PTREP_RIG1 = TMODE_TOT . IND_M . ROTAS . 1 . POINT_REPERE;
PTREP_RIG2 = TMODE_TOT . IND_M . ROTAS . 2 . POINT_REPERE;
PTREP_RIG3 = TMODE_TOT . IND_M . ROTAS . 3 . POINT_REPERE;
PTREP_RIG4 = TMODE_TOT . IND_M . ROTAS . 4 . POINT_REPERE;

* ADAPTATEUR :
si (lraidtimo) ;
  PTREP_RIG21 = TMODE_TOT . IND_AD . ROTAS . 1 . POINT_REPERE;
  PTREP_RIG22 = TMODE_TOT . IND_AD . ROTAS . 2 . POINT_REPERE;
  PTREP_RIG23 = TMODE_TOT . IND_AD . ROTAS . 3 . POINT_REPERE;
  PTREP_RIG24 = TMODE_TOT . IND_AD . ROTAS . 4 . POINT_REPERE;
finsi ;
****************************************************************************
*           Sorties
****************************************************************************
*    variables corps rigide manchette :
W1 = TRESU . VITESSE . PTREP_RIG1;
W2 = TRESU . VITESSE . PTREP_RIG2;
W3 = TRESU . VITESSE . PTREP_RIG3;

si (non LSMALLEXIT) ;
*
A1 = TRESU . ACCELERATION . PTREP_RIG1;
A2 = TRESU . ACCELERATION . PTREP_RIG2;
A3 = TRESU . ACCELERATION . PTREP_RIG3;
*
PI1 = TRESU . TRAVAIL_INTERIEUR . PTREP_RIG1;
PI2 = TRESU . TRAVAIL_INTERIEUR . PTREP_RIG2;
PI3 = TRESU . TRAVAIL_INTERIEUR . PTREP_RIG3;
*
EC1 = TRESU . TRAVAIL_EXTERIEUR . PTREP_RIG1 ;
*
*
si (lraidtimo) ;
W1_AD = TRESU . VITESSE . PTREP_RIG21;
W2_AD = TRESU . VITESSE . PTREP_RIG22;
W3_AD = TRESU . VITESSE . PTREP_RIG23;
*
A1_AD = TRESU . ACCELERATION . PTREP_RIG21;
A2_AD = TRESU . ACCELERATION . PTREP_RIG22;
A3_AD = TRESU . ACCELERATION . PTREP_RIG23;
*
PI1_AD = TRESU . TRAVAIL_INTERIEUR . PTREP_RIG21;
PI2_AD = TRESU . TRAVAIL_INTERIEUR . PTREP_RIG22;
PI3_AD = TRESU . TRAVAIL_INTERIEUR . PTREP_RIG23;
*
EC1_AD = TRESU . TRAVAIL_EXTERIEUR . PTREP_RIG21 ;
finsi ;

*    CDM manchette : 
UXG_M_TOT = EVOL 'JAUN' 'RECO' TRESU tmode 'DEPL' GTOT_MANCH 'UX' ;
UYG_M_TOT = EVOL 'ORAN' 'RECO' TRESU tmode 'DEPL' GTOT_MANCH 'UY' ;
UZG_M_TOT = EVOL 'ROUG' 'RECO' TRESU tmode 'DEPL' GTOT_MANCH 'UZ' ;
UXG_M_TOT = EXTR UXG_M_tot 'ORDO' 1 ;
UYG_M_TOT = EXTR UYG_M_tot 'ORDO' 1 ;
UZG_M_TOT = EXTR UZG_M_tot 'ORDO' 1 ;

*    CDM adaptateur : 
UXG_AD_TOT = EVOL 'JAUN' 'RECO' TRESU tmode_ad 'DEPL' GTOT_AD_BR 'UX' ;
UYG_AD_TOT = EVOL 'ORAN' 'RECO' TRESU tmode_ad 'DEPL' GTOT_AD_BR 'UY' ;
UZG_AD_TOT = EVOL 'ROUG' 'RECO' TRESU tmode_ad 'DEPL' GTOT_AD_BR 'UZ' ;
UXG_AD_TOT = EXTR UXG_AD_tot 'ORDO' 1 ;
UYG_AD_TOT = EXTR UYG_AD_tot 'ORDO' 1 ;
UZG_AD_TOT = EXTR UZG_AD_tot 'ORDO' 1 ;
*    Sommet cone : 
UXSCONE_TOT = EVOL 'JAUN' 'RECO' TRESU tmode_ad 'DEPL' SCONE_AD 'UX' ;
UYSCONE_TOT = EVOL 'ORAN' 'RECO' TRESU tmode_ad 'DEPL' SCONE_AD 'UY' ;
UZSCONE_TOT = EVOL 'ROUG' 'RECO' TRESU tmode_ad 'DEPL' SCONE_AD 'UZ' ;
UXSCONE_TOT = EXTR UXSCONE_tot 'ORDO' 1 ;
UYSCONE_TOT = EXTR UYSCONE_tot 'ORDO' 1 ;
UZSCONE_TOT = EXTR UZSCONE_tot 'ORDO' 1 ;
*    POINT LAME BAS : 
UXPLAMB_tot = EVOL 'JAUN' 'RECO' TRESU tmode_ad 'DEPL' PLAM_B 'UX' ;
UXPLAMB_tot = EXTR UXPLAMB_tot 'ORDO' 1 ;
UYPLAMB_tot = EVOL 'JAUN' 'RECO' TRESU tmode_ad 'DEPL' PLAM_B 'UY' ;
UYPLAMB_tot = EXTR UYPLAMB_tot 'ORDO' 1 ;
UZPLAMB_tot = EVOL 'JAUN' 'RECO' TRESU tmode_ad 'DEPL' PLAM_B 'UZ' ;
UZPLAMB_tot = EXTR UZPLAMB_tot 'ORDO' 1 ;
*    POINT LAME HAUT : 
UXPLAMH_tot = EVOL 'JAUN' 'RECO' TRESU tmode_ad 'DEPL' PLAM_H 'UX' ;
UXPLAMH_tot = EXTR UXPLAMH_tot 'ORDO' 1 ;
UYPLAMH_tot = EVOL 'JAUN' 'RECO' TRESU tmode_ad 'DEPL' PLAM_H 'UY' ;
UYPLAMH_tot = EXTR UYPLAMH_tot 'ORDO' 1 ;
UZPLAMH_tot = EVOL 'JAUN' 'RECO' TRESU tmode_ad 'DEPL' PLAM_H 'UZ' ;
UZPLAMH_tot = EXTR UZPLAMH_tot 'ORDO' 1 ;

UXP2 = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' P2 'UX' ;
UXP2 = EXTR UXP2 'ORDO' 1 ;
UYP2 = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' P2 'UY' ;
UYP2 = EXTR UYP2 'ORDO' 1 ;
UZP2 = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' P2 'UZ' ;
UZP2 = EXTR UZP2 'ORDO' 1 ;

UXPB = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PB 'UX' ;
UXPB = EXTR UXPB 'ORDO' 1 ;
UYPB = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PB 'UY' ;
UYPB = EXTR UYPB 'ORDO' 1 ;
UZPB = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PB 'UZ' ;
UZPB = EXTR UZPB 'ORDO' 1 ;

UXPH = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PH 'UX' ;
UXPH = EXTR UXPH 'ORDO' 1 ;
UYPH = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PH 'UY' ;
UYPH = EXTR UYPH 'ORDO' 1 ;
UZPH = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PH 'UZ' ;
UZPH = EXTR UZPH 'ORDO' 1 ;

UXcrot = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' (tmode_m_rx . modes . 1 . 'CENTRE_DE_ROTATION') 'UX' ;
UXcrot = EXTR UXcrot 'ORDO' 1 ;
UYcrot = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' (tmode_m_rx . modes . 1 . 'CENTRE_DE_ROTATION') 'UY' ;
UYcrot = EXTR UYcrot 'ORDO' 1 ;
UZcrot = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' (tmode_m_rx . modes . 1 . 'CENTRE_DE_ROTATION') 'UZ' ;
UZcrot = EXTR UZcrot 'ORDO' 1 ;

UXPLOW = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PLOW 'UX' ;
UXPLOW = EXTR UXPLOW 'ORDO' 1 ;
UYPLOW = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PLOW 'UY' ;
UYPLOW = EXTR UYPLOW 'ORDO' 1 ;
UZPLOW = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' PLOW 'UZ' ;
UZPLOW = EXTR UZPLOW 'ORDO' 1 ;

UXPLOW_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' P3_AD 'UX' ;
UXPLOW_AD = EXTR UXPLOW_AD 'ORDO' 1 ;
UYPLOW_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' P3_AD 'UY' ;
UYPLOW_AD = EXTR UYPLOW_AD 'ORDO' 1 ;
UZPLOW_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' P3_AD 'UZ' ;
UZPLOW_AD = EXTR UZPLOW_AD 'ORDO' 1 ;

UXPH_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' PH_AD 'UX' ;
UXPH_AD = EXTR UXPH_AD 'ORDO' 1 ;
UYPH_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' PH_AD 'UY' ;
UYPH_AD = EXTR UYPH_AD 'ORDO' 1 ;
UZPH_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' PH_AD 'UZ' ;
UZPH_AD = EXTR UZPH_AD 'ORDO' 1 ;

UXPB_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' PB_AD 'UX' ;
UXPB_AD = EXTR UXPB_AD 'ORDO' 1 ;
UYPB_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' PB_AD 'UY' ;
UYPB_AD = EXTR UYPB_AD 'ORDO' 1 ;
UZPB_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' PB_AD 'UZ' ;
UZPB_AD = EXTR UZPB_AD 'ORDO' 1 ;

* vis a vis du centre du cercle de l'adaptateur : 
UXce_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' pce_ad 'UX' ;
UXce_AD = EXTR UXce_AD 'ORDO' 1 ;
UYce_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' pce_ad 'UY' ;
UYce_AD = EXTR UYce_AD 'ORDO' 1 ;
UZce_AD = EVOL 'JAUN' 'RECO' TRESU TMODE_AD 'DEPL' pce_ad 'UZ' ;
UZce_AD = EXTR UZce_AD 'ORDO' 1 ;
****************************************************************************
*           Forces de reaction sur le bati
****************************************************************************
si ltrans ;
  AXG_AD = EVOL 'JAUN' 'RECO' TRESU tmode_bloq 'ACCE' gtot_ad_br 'UX' ;
  AXG_AD = EXTR AXG_AD 'ORDO' 1 ;
  AYG_AD = EVOL 'JAUN' 'RECO' TRESU tmode_bloq 'ACCE' gtot_ad_br 'UY' ;
  AYG_AD = EXTR AYG_AD 'ORDO' 1 ;
  AZG_AD = EVOL 'JAUN' 'RECO' TRESU tmode_bloq 'ACCE' gtot_ad_br 'UZ' ;
  AZG_AD = EXTR AZG_AD 'ORDO' 1 ;
finsi ;

****************************************************************************
*           TSORT
****************************************************************************

****************************************************************************
*           fin si non LSMALLEXIT :
****************************************************************************
finsi ;
****************************************************************************
* on met les bons temps si reprise :
si (reprise) ;
* tfin = extr tprog (dime tprog) ;
* dt = (tfin - trep) / ((dime tprog) - 1 ) ;
  dt = ((extr tprog 2) - (extr tprog 1)) ;
  tprog_rep = prog trep 'PAS' dt 'NPAS' ((dime tprog) - 1) ;
*  opti donn 5 ;
  tprog = tprog_rep ; 
finsi ;
* on re-echantillonne les listes de forces exterieures pour les exporter :
si (lsin) ;
  Fprog2 = (SIN (OMEGA*tprog)) ;
finsi ;
si (lsinb) ;
  f2 = f1 + ((T/ttot)*(f2 - f1)) ; 
  df = (f2 - f1) / ((dime tprog) - 1 ) ;
  freq = prog f1 'PAS' df 'NPAS' ((dime tprog) - 1) ;
  omega = 360. * freq ; 
  Fprog2 =(sin ( omega * tprog ) ) ;
  si reprise ;
    df = (fend - fstart) / ((dime tprog) - 1 ) ;
    freq = prog fstart 'PAS' df 'NPAS' ((dime tprog) - 1) ;
    omega = 360. * freq ; 
    Fprog2 = (sin ( omega * tprog ) ) ;
  finsi ;
finsi ;
si (lexp) ;
* on rajoute une decroissance exponentielle :
  Fprogxp = (exp (Bf*tprog)) ;
  Fprog2 = Fprog2 * Fprogxp ;
finsi ;
*
TSORT = 'TABL' ;

TSORT . 't' = table ;
TSORT . 't' = tprog ;

TSORT . 'slice' = table ;
TSORT . 'slice' = (lect (dime tprog)*slice) ;

TSORT . 'ctime' = table ;
TSORT . 'ctime' = (prog (dime tprog)*ctime) ;

TSORT . 'dt' = table ;
TSORT . 'dt' = prog (dime tprog)*dte ;

TSORT . 'nmode' = table ;
TSORT . 'nmode' = lect (dime tprog)*nmode ;

TSORT . 'nmode_ad' = table ;
TSORT . 'nmode_ad' = lect (dime tprog)*nmode_ad ;

TSORT . 'spinini' = table ;
TSORT . 'spinini' = prog (dime tprog)*spinini ;

TSORT . 'Fext0' = table ;
TSORT . 'Fext0' = prog (dime tprog)*Fext ;

TSORT . 'Fext' = table ;
TSORT . 'Fext' = Fext * Fprog2 ;

TSORT . 'vlimoden' = table ;
TSORT . 'vlimoden' = prog (dime tprog)*vlimoden ;

TSORT . 'WX'  = table ;
TSORT . 'WY'  = table ;
TSORT . 'WZ'  = table ;
TSORT . 'AX'  = table ;
TSORT . 'AY'  = table ;
TSORT . 'AZ'  = table ;
TSORT . 'PIX' = table ;
TSORT . 'PIY' = table ;
TSORT . 'PIZ' = table ;
TSORT . 'EC'  = table ;
TSORT . 'edef'  = table ;

TSORT . 'WX'  = W1 ;
TSORT . 'WY'  = W2 ;
TSORT . 'WZ'  = W3 ;
TSORT . 'AX'  = A1 ;
TSORT . 'AY'  = A2 ;
TSORT . 'AZ'  = A3 ;
TSORT . 'EC'  = EC1 ;
TSORT . 'PIX' = PI1 ;
TSORT . 'PIY' = PI2 ;
TSORT . 'PIZ' = PI3 ;
TSORT . 'edef'  = tresu . travail_exterieur . ptrep_rig2 ;
* pour les ss bases ss rotas tigides :
*   l'energie cinetique est stockee dans le premier mode dans travail_exterieur.
*   l'energie de deformation est stockee dans le premier mode dans travail_interieur.
*       (cf. rkpas)
ptrepad1 = tmode_ad . modes . 1 . point_repere ;
tsort . 'ecad' = table ;
tsort . 'edefad' = table ;
tsort . 'ecad' = TRESU . TRAVAIL_EXTERIEUR . ptrepad1 ;
tsort . 'edefad' = TRESU . TRAVAIL_INTERIEUR . ptrepad1 ;

* sauvegarde du quaternion :
tsort . 'quat1' = table ; 
tsort . 'quat2' = table ; 
tsort . 'quat3' = table ; 
TSORT . 'quat4' = table ; 
TSORT . 'quat1' = tresu . 'DEPLACEMENT' . ptrep_rig1 ; 
TSORT . 'quat2' = tresu . 'DEPLACEMENT' . ptrep_rig2 ; 
TSORT . 'quat3' = tresu . 'DEPLACEMENT' . ptrep_rig3 ; 
TSORT . 'quat4' = tresu . 'DEPLACEMENT' . ptrep_rig4 ; 

ncolexce = 27 ;

* sauvegarde des coord modales :
repe bsauvq (nmode - n_tronq) ;
  ptrpi = tmode . modes . &bsauvq . point_repere ;  
  tsort . (chai 'q'&bsauvq)    = table ; 
  tsort . (chai 'q'&bsauvq'v') = table ;
  tsort . (chai 'q'&bsauvq'a') = table ;
  tsort . (chai 'q'&bsauvq) = tresu . deplacement . ptrpi ; 
  tsort . (chai 'q'&bsauvq'v') = tresu . vitesse . ptrpi ; 
  tsort . (chai 'q'&bsauvq'a') = tresu . acceleration . ptrpi ; 
  ncolexce = ncolexce + 3 ;
fin bsauvq ;
* sauvegarde des coord modales --> translation :
tsort . 'qtx' = table ;
tsort . 'qtx' = tresu . deplacement . ptrep_m_tx ;
tsort . 'qty' = table ;
tsort . 'qty' = tresu . deplacement . ptrep_m_ty ;
tsort . 'qtz' = table ;
tsort . 'qtz' = tresu . deplacement . ptrep_m_tz ;
tsort . 'qvtx' = table ;
tsort . 'qvtx' = tresu . vitesse . ptrep_m_tx ;
tsort . 'qvty' = table ;
tsort . 'qvty' = tresu . vitesse . ptrep_m_ty ;
tsort . 'qvtz' = table ;
tsort . 'qvtz' = tresu . vitesse . ptrep_m_tz ;
tsort . 'qatx' = table ;
tsort . 'qatx' = tresu . acceleration . ptrep_m_tx ;
tsort . 'qaty' = table ;
tsort . 'qaty' = tresu . acceleration . ptrep_m_ty ;
tsort . 'qatz' = table ;
tsort . 'qatz' = tresu . acceleration . ptrep_m_tz ;
ncolexce = ncolexce + 9 ;

* centre du cercle manchette :
TSORT . 'uxp2'  = TABLE ; 
TSORT . 'uyp2'  = TABLE ; 
TSORT . 'uzp2'  = TABLE ; 
TSORT . 'uxp2' = UXP2 ; 
TSORT . 'uyp2' = UYP2 ; 
TSORT . 'uzp2' = UZP2 ; 

ncolexce = ncolexce + 3 ;

* CDM manchette :
TSORT . 'uxg_m'  = TABLE ; 
TSORT . 'uyg_m'  = TABLE ; 
TSORT . 'uzg_m'  = TABLE ; 
TSORT . 'uxg_m' = UXG_M_TOT ; 
TSORT . 'uyg_m' = UYG_M_TOT ; 
TSORT . 'uzg_m' = UZG_M_TOT ; 

ncolexce = ncolexce + 3 ;

* CDR manchette :
tsort . 'UXcdr' = table ; 
tsort . 'UYcdr' = table ;
tsort . 'UZcdr' = table ;
tsort . 'UXcdr' = uxcrot ;
tsort . 'UYcdr' = uycrot ;
tsort . 'UZcdr' = uzcrot ;

ncolexce = ncolexce + 3 ;

*
TSORT . 'uxg_tot_ad'  = TABLE ; 
TSORT . 'uyg_tot_ad'  = TABLE ; 
TSORT . 'uzg_tot_ad'  = TABLE ; 
TSORT . 'uxscone_tot' = TABLE ;
TSORT . 'uyscone_tot' = TABLE ;
TSORT . 'uzscone_tot' = TABLE ;
*
TSORT . 'uxg_tot_ad' = UXG_AD_TOT ; 
TSORT . 'uyg_tot_ad' = UYG_AD_TOT ; 
TSORT . 'uzg_tot_ad' = UZG_AD_TOT ; 
TSORT . 'uxscone_tot' = UXSCONE_TOT ;
TSORT . 'uyscone_tot' = UYSCONE_TOT ;
TSORT . 'uzscone_tot' = UZSCONE_TOT ;

ncolexce = ncolexce + 6 ;

si (lplam) ;
TSORT . 'uxplam_h' = TABLE ;
TSORT . 'uyplam_h' = TABLE ;
TSORT . 'uzplam_h' = TABLE ;
TSORT . 'uxplam_b' = TABLE ;
TSORT . 'uyplam_b' = TABLE ;
TSORT . 'uzplam_b' = TABLE ;

TSORT . 'uxplam_h' = UXPLAMH_TOT ;
TSORT . 'uyplam_h' = UYPLAMH_TOT ;
TSORT . 'uzplam_h' = UZPLAMH_TOT ;

TSORT . 'uxplam_b' = UXPLAMB_TOT ;
TSORT . 'uyplam_b' = UYPLAMB_TOT ;
TSORT . 'uzplam_b' = UZPLAMB_TOT ;

ncolexce = ncolexce + 6 ;
finsi ;

si (non lpion) ;
* on ne sort le depl du point bas que si il n'y a pas de pions :
TSORT . 'uxplow' = TABLE ;
TSORT . 'uyplow' = TABLE ;
TSORT . 'uzplow' = TABLE ;
TSORT . 'uxplow_ad' = TABLE ;
TSORT . 'uyplow_ad' = TABLE ;
TSORT . 'uzplow_ad' = TABLE ;

TSORT . 'uxplow' = UXPLOW ;
TSORT . 'uyplow' = UYPLOW ;
TSORT . 'uzplow' = UZPLOW ;

TSORT . 'uxplow_ad' = UXPLOW_AD ;
TSORT . 'uyplow_ad' = UYPLOW_AD ;
TSORT . 'uzplow_ad' = UZPLOW_AD ;

ncolexce = ncolexce + 6 ;

finsi ;

* centre du cercle adapter :
TSORT . 'uxce_ad' = TABLE ;
TSORT . 'uyce_ad' = TABLE ;
TSORT . 'uzce_ad' = TABLE ;
TSORT . 'uxce_ad' = UXce_AD ;
TSORT . 'uyce_ad' = UYce_AD ;
TSORT . 'uzce_ad' = UZce_AD ;

ncolexce = ncolexce + 3 ;

* si (lpion) ;
TSORT . 'uxph' = TABLE ;
TSORT . 'uyph' = TABLE ;
TSORT . 'uzph' = TABLE ;
TSORT . 'uxpb' = TABLE ;
TSORT . 'uypb' = TABLE ;
TSORT . 'uzpb' = TABLE ;
TSORT . 'uxpb_ad' = TABLE ;
TSORT . 'uypb_ad' = TABLE ;
TSORT . 'uzpb_ad' = TABLE ;
TSORT . 'uxph_ad' = TABLE ;
TSORT . 'uyph_ad' = TABLE ;
TSORT . 'uzph_ad' = TABLE ;
TSORT . 'uxpb' = UXPB ;
TSORT . 'uypb' = UYPB ;
TSORT . 'uzpb' = UZPB ;
TSORT . 'uxph' = UXPH ;
TSORT . 'uyph' = UYPH ;
TSORT . 'uzph' = UZPH ;
TSORT . 'uxpb_ad' = UXPB_AD ;
TSORT . 'uypb_ad' = UYPB_AD ;
TSORT . 'uzpb_ad' = UZPB_AD ;
TSORT . 'uxph_ad' = UXPH_AD ;
TSORT . 'uyph_ad' = UYPH_AD ;
TSORT . 'uzph_ad' = UZPH_AD ;

ncolexce = ncolexce + 12 ;
* finsi ;

* force tansmise au systeme ie. mesuree par le cellule de force :
si (ltrans) ;
  fprog3 = prog ; 
* repe bfpr (Nt - 1) ;
  repe bfpr (Nt) ;
*   fprog3 = fprog3 et (extr fprog2 ((&bfpr)*nsort)) ;
    si (&bfpr ega 1) ;
      fprog3 = fprog3 et (extr fprog2 1) ;
    sinon ;
      fprog3 = fprog3 et (extr fprog2 ((&bfpr-1)*nsort)) ;
    finsi ;
  fin bfpr ;
* force d'excitation :
  Fexc  = Fext * Fprog3 ;
* reponse du systeme :
  Frep  = Mtot_ad * azg_ad ;
  Ftrans = (Fexc - Frep) ;

  TSORT . 'fexc'  = TABLE ; 
  TSORT . 'ftrans'  = TABLE ; 
  TSORT . 'fexc'  = Fexc ; 
  TSORT . 'ftrans'  = Ftrans ; 
  ncolexce = ncolexce + 2 ;
finsi ;

si (lraidtimo) ;
  TSORT . 'WX_AD'  = table ;
  TSORT . 'WY_AD'  = table ;
  TSORT . 'WZ_AD'  = table ;
  TSORT . 'AX_AD'  = table ;
  TSORT . 'AY_AD'  = table ;
  TSORT . 'AZ_AD'  = table ;
  TSORT . 'PIX_AD' = table ;
  TSORT . 'PIY_AD' = table ;
  TSORT . 'PIZ_AD' = table ;
  TSORT . 'EC_AD'  = table ;

  TSORT . 'WX_AD'  = W1_AD ;
  TSORT . 'WY_AD'  = W2_AD ;
  TSORT . 'WZ_AD'  = W3_AD ;
  TSORT . 'AX_AD'  = A1_AD ;
  TSORT . 'AY_AD'  = A2_AD ;
  TSORT . 'AZ_AD'  = A3_AD ;
  TSORT . 'PIX_AD' = PI1_AD ;
  TSORT . 'PIY_AD' = PI2_AD ;
  TSORT . 'PIZ_AD' = PI3_AD ;
  TSORT . 'EC_AD'  = EC1_AD ;
  ncolexce = ncolexce + 10 ;
sinon ;
* sauvegarde des coord modales :
  repe bsauvqad (nmad) ;
    ptrpi = tmode_ad . modes . &bsauvqad . point_repere ;  
    tsort . (chai 'q'&bsauvqad'ad')  = table ; 
    tsort . (chai 'q'&bsauvqad'vad') = table ;
    tsort . (chai 'q'&bsauvqad'aad') = table ;
    tsort . (chai 'q'&bsauvqad'ad')  = tresu . deplacement . ptrpi ; 
    tsort . (chai 'q'&bsauvqad'vad') = tresu . vitesse . ptrpi ; 
    tsort . (chai 'q'&bsauvqad'aad') = tresu . acceleration . ptrpi ; 
    ncolexce = ncolexce + 3 ;
  fin bsauvqad ;
finsi ; 

SI (CCONE) ;
  TSORT . 'FN_CCONE' = table ;
  TSORT . 'FT_CCONE' = table ;
  TSORT . 'MX_CCONE' = table ;
  TSORT . 'MY_CCONE' = table ;
  TSORT . 'MZ_CCONE' = table ;
  TSORT . 'FN_CCONE' = TRESU . TL1 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_CCONE' = TRESU . TL1 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'MX_CCONE' = TRESU . TL1 . 'MX_POINT_FIBRE_NEUTRE' ;
  TSORT . 'MY_CCONE' = TRESU . TL1 . 'MY_POINT_FIBRE_NEUTRE' ;
  TSORT . 'MZ_CCONE' = TRESU . TL1 . 'MZ_POINT_FIBRE_NEUTRE' ;
  TSORT . 'FX_CCONE' = table ;
  TSORT . 'FY_CCONE' = table ;
  TSORT . 'FZ_CCONE' = table ;
  TSORT . 'FX_CCONE' = TRESU . TL1 . 'FX_BASE_B' ;
  TSORT . 'FY_CCONE' = TRESU . TL1 . 'FY_BASE_B' ;
  TSORT . 'FZ_CCONE' = TRESU . TL1 . 'FZ_BASE_B' ;

  TSORT . 'NUT'   = table ; 
  TSORT . 'RCINC' = table ; 
  TSORT . 'DIMP'  = table ; 
  TSORT . 'THMAX' = table ; 
  TSORT . 'INCID' = table ; 
  TSORT . 'NUT'   = TRESU . TL1 . 'NUTATION' ;
  TSORT . 'RCINC' = TRESU . TL1 . 'RAYON_COURBURE' ;
  TSORT . 'DIMP'  = TRESU . TL1 . 'PENETRATION_NORMALE' ;
  TSORT . 'THMAX' = TRESU . TL1 . 'LARGEUR_PROFILE' ;
  TSORT . 'INCID' = TRESU . TL1 . 'ANGLE_INCIDENCE' ;

  TSORT . 'VX_PINCID' = table ;
  TSORT . 'VY_PINCID' = table ;
  TSORT . 'VZ_PINCID' = table ;
  TSORT . 'VX_PINCID' = TRESU . TL1 . 'VX_POINT_CONTACT' ;
  TSORT . 'VY_PINCID' = TRESU . TL1 . 'VY_POINT_CONTACT' ;
  TSORT . 'VZ_PINCID' = TRESU . TL1 . 'VZ_POINT_CONTACT' ;

  TSORT . 'UXpincid' = table ;
  TSORT . 'UYpincid' = table ;
  TSORT . 'UZpincid' = table ;
  TSORT . 'UXpincid' = TRESU . TL1 . 'UX_POINT_DE_CONTACT' ;
  TSORT . 'UYpincid' = TRESU . TL1 . 'UY_POINT_DE_CONTACT' ;
  TSORT . 'UZpincid' = TRESU . TL1 . 'UZ_POINT_DE_CONTACT' ;

  TSORT . 'pusure_ccone' = table ;
  TSORT . 'pusure_ccone' = TRESU . TL1 . 'PUISSANCE_USURE_INSTANTANEE' ;

  TSORT . 'pctg_glis_ad' = TABLE ; 
  TSORT . 'pctg_glis_ad' = TRESU . TL1 . 'POURCENTAGE_GLISS_ADH' ;

  ncolexce = ncolexce + 21 ;
FINSI ; 

SI (lpion) ;
  TSORT . 'FN_pb1' = table ;
  TSORT . 'FT_pb1' = table ;
  TSORT . 'pusure_pb1' = table ;
  TSORT . 'FN_pb1' = TRESU . TLpb1 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pb1' = TRESU . TLpb1 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pb1' = TRESU . TLpb1 . 'PUISSANCE_USURE_INSTANTANEE' ;
  TSORT . 'FN_pb2' = table ;
  TSORT . 'FT_pb2' = table ;
  TSORT . 'pusure_pb2' = table ;
  TSORT . 'FN_pb2' = TRESU . TLpb2 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pb2' = TRESU . TLpb2 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pb2' = TRESU . TLpb2 . 'PUISSANCE_USURE_INSTANTANEE' ;
  TSORT . 'FN_pb3' = table ;
  TSORT . 'FT_pb3' = table ;
  TSORT . 'pusure_pb3' = table ;
  TSORT . 'FN_pb3' = TRESU . TLpb3 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pb3' = TRESU . TLpb3 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pb3' = TRESU . TLpb3 . 'PUISSANCE_USURE_INSTANTANEE' ;
  TSORT . 'FN_ph1' = table ;
  TSORT . 'FT_ph1' = table ;
  TSORT . 'pusure_ph1' = table ;
  TSORT . 'FN_ph1' = TRESU . TLph1 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_ph1' = TRESU . TLph1 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_ph1' = TRESU . TLph1 . 'PUISSANCE_USURE_INSTANTANEE' ;
  TSORT . 'FN_ph2' = table ;
  TSORT . 'FT_ph2' = table ;
  TSORT . 'pusure_ph2' = table ;
  TSORT . 'FN_ph2' = TRESU . TLph2 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_ph2' = TRESU . TLph2 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_ph2' = TRESU . TLph2 . 'PUISSANCE_USURE_INSTANTANEE' ;
  TSORT . 'FN_ph3' = table ;
  TSORT . 'FT_ph3' = table ;
  TSORT . 'pusure_ph3' = table ;
  TSORT . 'FN_ph3' = TRESU . TLph3 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_ph3' = TRESU . TLph3 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_ph3' = TRESU . TLph3 . 'PUISSANCE_USURE_INSTANTANEE' ;
*
  ncolexce = ncolexce + 18 ;
FINSI ; 

SI (lpcirc) ;
  TSORT . 'FN_pcirch1' = table ;
  TSORT . 'FT_pcirch1' = table ;
  TSORT . 'pusure_pcirch1' = table ;
  TSORT . 'FN_pcirch1' = TRESU . TLpcirch1 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pcirch1' = TRESU . TLpcirch1 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pcirch1' = TRESU . TLpcirch1 . 'PUISSANCE_USURE_INSTANTANEE' ;

  TSORT . 'FN_pcirch2' = table ;
  TSORT . 'FT_pcirch2' = table ;
  TSORT . 'pusure_pcirch2' = table ;
  TSORT . 'FN_pcirch2' = TRESU . TLpcirch2 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pcirch2' = TRESU . TLpcirch2 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pcirch2' = TRESU . TLpcirch2 . 'PUISSANCE_USURE_INSTANTANEE' ;

  TSORT . 'FN_pcirch3' = table ;
  TSORT . 'FT_pcirch3' = table ;
  TSORT . 'pusure_pcirch3' = table ;
  TSORT . 'FN_pcirch3' = TRESU . TLpcirch3 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pcirch3' = TRESU . TLpcirch3 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pcirch3' = TRESU . TLpcirch3 . 'PUISSANCE_USURE_INSTANTANEE' ;

  TSORT . 'FN_pcircb1' = table ;
  TSORT . 'FT_pcircb1' = table ;
  TSORT . 'pusure_pcircb1' = table ;
  TSORT . 'FN_pcircb1' = TRESU . TLpcircb1 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pcircb1' = TRESU . TLpcircb1 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pcircb1' = TRESU . TLpcircb1 . 'PUISSANCE_USURE_INSTANTANEE' ;

  TSORT . 'FN_pcircb2' = table ;
  TSORT . 'FT_pcircb2' = table ;
  TSORT . 'pusure_pcircb2' = table ;
  TSORT . 'FN_pcircb2' = TRESU . TLpcircb2 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pcircb2' = TRESU . TLpcircb2 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pcircb2' = TRESU . TLpcircb2 . 'PUISSANCE_USURE_INSTANTANEE' ;

  TSORT . 'FN_pcircb3' = table ;
  TSORT . 'FT_pcircb3' = table ;
  TSORT . 'pusure_pcircb3' = table ;
  TSORT . 'FN_pcircb3' = TRESU . TLpcircb3 . 'FORCE_DE_CHOC_NORMALE' ;
  TSORT . 'FT_pcircb3' = TRESU . TLpcircb3 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
  TSORT . 'pusure_pcircb3' = TRESU . TLpcircb3 . 'PUISSANCE_USURE_INSTANTANEE' ;
*
  ncolexce = ncolexce + 18 ;
FINSI ; 
****************************************************************************
*
rep_sauv = './data/' ;
*
OPTI 'SORT' (CHAI rep_sauv script) ;
SORT 'EXCE' (TSORT) 'NCOL' ncolexce 'SEPA' 'VIRG' 'DIGI' 10 ;
*
****************************************************************************
*           VTK
****************************************************************************
SI (FLVTK) ;
*
* Creation des maillages fictifs :
opti oeil (2*r_tete*ez) ;

p1c = p2 plus (r_tete*ex) ;
p2c = p2 plus  (((cos 45.) * (R_TETE))*ex) plus (((sin 45.) * (R_TETE))*ey)  ;
p3c = p2 plus  ((R_TETE)*ey) ;
p4c = p2 plus  (((cos 135.) * (R_TETE))*ex) plus (((sin 135.) * (R_TETE))*ey)  ;
p5c = p2 plus  (((-1.)*R_TETE)*ex) ;
p6c = p2 plus  (((cos 225.) * (R_TETE))*ex) plus (((sin 225.) * (R_TETE))*ey)  ;
p7c = p2 plus  (((cos 270.) * (R_TETE))*ex) plus (((sin 270.) * (R_TETE))*ey)  ;
p8c = p2 plus  (((cos 315.) * (R_TETE))*ex) plus (((sin 315.) * (R_TETE))*ey)  ;

* "rayons" de la roue :
l1c = d 1 p2 p1c ;
l2c = d 1 p2 p2c ;
l3c = d 1 p2 p3c ;
l4c = d 1 p2 p4c ;
l5c = d 1 p2 p5c ;
l6c = d 1 p2 p6c ;
l7c = d 1 p2 p7c ;
l8c = d 1 p2 p8c ;
rayons = l1c et l2c et l3c et l4c et l5c et l6c et l7c et l8c ;

c1  = cerc 100 'ROTA' 180. p1c p2 p1 ;
c2  = cerc 100 'ROTA' 180. p5c p2 p1 ;
ctot = c1 et c2 et rayons ; 

* cercles interieurs de la roue :
p1cint = p2 plus ((2./3.)*r_tete*ex) ;
p2cint = p2 plus ((-1.)*(2./3.)*r_tete*ex) ;
cint1  = cerc 100 'ROTA' 180. p1cint p2 p1 ;
cint2  = cerc 100 'ROTA' 180. p2cint p2 p1 ;

p11cint = p2 plus ((1./3.)*r_tete*ex) ;
p22cint = p2 plus ((-1.)*(1./3.)*r_tete*ex) ;
cint11  = cerc 100 'ROTA' 180. p11cint p2 p1 ;
cint22  = cerc 100 'ROTA' 180. p22cint p2 p1 ;

ctot = ctot et cint1 et cint2 et cint11 et cint22 ; 

elim ctot 1.e-10 ;

TRAC 'QUAL' ((ctot COUL roug)) ;

***** maillage generale :
manchette_vtk = manchette et ctot ;
tmode_tot . ind_m  . modes . maillage = manchette_vtk ;
tmode . modes . maillage = manchette_vtk ;
*
**** modes elastiques :
* repe brig (6+ntronq) ;
repe bflex n_tronq ;
*    normalement : il suffit d'introduire MESHAD dans le 1er mode!!
  def_mod = Tmode_tot . ind_m . modes . &bflex . deformee_modale ;
*    on donne a tous les points de MESHAD la valeurs des DDL au niveau du cercle
*    (seules les rotas rigides nous interessent visuellement!)
  ux_p2 = extr def_mod 'VALE' 'UX' p2 ;
  uy_p2 = extr def_mod 'VALE' 'UY' p2 ;
  uz_p2 = extr def_mod 'VALE' 'UZ' p2 ;
  rx_p2 = extr def_mod 'VALE' 'RX' p2 ;
  ry_p2 = extr def_mod 'VALE' 'RY' p2 ;
  rz_p2 = extr def_mod 'VALE' 'RZ' p2 ;

  def_circ = manu chpo ctot 6 ux_p2 'UX' uy_p2 'UY' uz_p2 'UZ' rx_p2 'RX' ry_p2 'RY' rz_p2 'RZ';
  def_mod  = chan 'ATTRIBUT' def_mod  'NATURE' 'DIFFUS' ;
  def_circ = chan 'ATTRIBUT' def_circ 'NATURE' 'DIFFUS' ;

  Tmode_tot . ind_m . modes . &bflex . deformee_modale = (def_mod et def_circ) ;
  Tmode . modes . &bflex . deformee_modale = (def_mod et def_circ) ;
fin bflex ; 
* translations + rotations rigides :
* repe btrig 6 ;
repe btrig (nmode - n_tronq) ;
  def_mod = Tmode_tot . ind_m . modes . (n_tronq + &btrig) . deformee_modale ;

  ux_p2 = extr def_mod 'VALE' 'UX' p2 ;
  uy_p2 = extr def_mod 'VALE' 'UY' p2 ;
  uz_p2 = extr def_mod 'VALE' 'UZ' p2 ;
  rx_p2 = extr def_mod 'VALE' 'RX' p2 ;
  ry_p2 = extr def_mod 'VALE' 'RY' p2 ;
  rz_p2 = extr def_mod 'VALE' 'RZ' p2 ;

  def_circ = manu chpo ctot 6 ux_p2 'UX' uy_p2 'UY' uz_p2 'UZ' rx_p2 'RX' ry_p2 'RY' rz_p2 'RZ';
  def_mod  = chan 'ATTRIBUT' def_mod  'NATURE' 'DIFFUS' ;
  def_circ = chan 'ATTRIBUT' def_circ 'NATURE' 'DIFFUS' ;

  Tmode_tot . ind_m . modes . &btrig . deformee_modale = (def_mod et def_circ) ;
  Tmode . modes . &btrig . deformee_modale = (def_mod et def_circ) ;
fin btrig ; 

* quaternions :
repe brota 3 ;
  def_mod = Tmode_tot . ind_m . rotas . &brota . deformee_modale ;

  ux_p2 = extr def_mod 'VALE' 'UX' p2 ;
  uy_p2 = extr def_mod 'VALE' 'UY' p2 ;
  uz_p2 = extr def_mod 'VALE' 'UZ' p2 ;
  rx_p2 = extr def_mod 'VALE' 'RX' p2 ;
  ry_p2 = extr def_mod 'VALE' 'RY' p2 ;
  rz_p2 = extr def_mod 'VALE' 'RZ' p2 ;

  def_circ = manu chpo ctot 6 ux_p2 'UX' uy_p2 'UY' uz_p2 'UZ' rx_p2 'RX' ry_p2 'RY' rz_p2 'RZ';
  def_mod  = chan 'ATTRIBUT' def_mod  'NATURE' 'DIFFUS' ;
  def_circ = chan 'ATTRIBUT' def_circ 'NATURE' 'DIFFUS' ;

  Tmode_tot . ind_m . rotas . &brota . deformee_modale = (def_mod et def_circ) ;
  Tmode . rotas . &brota . deformee_modale = (def_mod et def_circ) ;
fin brota ; 

**** adaptateur : maillage fictif
* cylindre 
dcyl  = L_CYL_AD / 10. ;
ncyl  = (enti (L_CYL_AD / dcyl)) + 1 ;
ccyl = vide 'MAILLAGE' ;
dcone = L_CONE_AD / 10. ;
ncone = (enti (L_Cone_AD / dcone)) + 1 ;
ccone = vide 'MAILLAGE' ;
repe bcylad ncyl ;
  pcyl1 = (p1_ad moins (((flott (&bcylad-1))*dcyl)*ez)) plus (r_cone_a * ex) ;
  pcyl2 = (p1_ad moins (((flott (&bcylad-1))*dcyl)*ez)) plus (((-1.)*r_cone_a) * ex) ;
  circ1 = cerc 100 'ROTA' 180. pcyl1 pr1 pr2 ;
  circ2 = cerc 100 'ROTA' 180. pcyl2 pr1 pr2 ;
  circ3 = circ1 et circ2 ;
  elim circ3 1.e-10 ;
  ccyl = ccyl et circ3 ;  
fin bcylad ;
plc1 = p1_ad plus (R_CONE_A*ex) ; 
plc2 = p1_ad plus (((-1.)*l_cyl_ad)*ez) plus (R_CONE_A*ex) ; 
lfc1 = d 1 plc1 plc2 ; 
sfc1 = lfc1 rota 72 360. pr1 pr2 ;

* cone  
pdeb_cone = p1_ad plus (L_cyl_ad 0. 0.) ;
repe bconead ncone ;
  pcyl1 = (pdeb_cone moins (((flott (&bconead-1))*dcone)*ez)) plus ((r_cone_a+((-1.)*(&bconead-1)*dcone)) * ex) ;
  pcyl2 = (pdeb_cone moins (((flott (&bconead-1))*dcone)*ez)) plus (((-1.)*(r_cone_a+((-1.)*(&bconead-1)*dcone))) * ex) ;
  circ1 = cerc 100 'ROTA' 180. pcyl1 pr1 pr2 ;
  circ2 = cerc 100 'ROTA' 180. pcyl2 pr1 pr2 ;
  circ3 = circ1 et circ2 ;
  elim circ3 1.e-10 ;
  ccone = ccone et circ3 ;  
fin bconead ;
* on rajoute des lignes dans la partie conique :
pl1 = pdeb_cone plus (r_cone_a*ex) ;
pl2 = pdeb_cone plus (((-1.)*l_cone_ad)*ez) plus ((dint_a/2.)*ex) ;
lf1 = d 1 pl1 pl2 ;
sf1 = lf1 rota 72 360. pr1 pr2 ;

* trac 'QUAL' (ccyl et ccone) ;
* trac 'QUAL' (ccyl et sf1) ;
mesh_ad = ccyl et ccone et sfc1 et sf1 ;
elim mesh_ad 1.e-10 ;
trac 'QUAL' (mesh_ad) ;

***** maillage generale :
adaptateur_vtk = ADAPTATEUR et MESH_AD ;
tmode_ad . modes . maillage = adaptateur_vtk ;
tmode_tot . ind_ad . modes . maillage = adaptateur_vtk ;
* ici chaque mode compte car l'adaptateur ne bouge qu'en modes elastiques.
*   on donne les dofs au niveau du sommet du cone.
repe bela nmode_ad ;
  def_mod = tmode_ad . modes . &bela . deformee_modale ;

  ux_scone_ad = extr def_mod 'VALE' 'UX' scone_ad ;
  uy_scone_ad = extr def_mod 'VALE' 'UY' scone_ad ;
  uz_scone_ad = extr def_mod 'VALE' 'UZ' scone_ad ;
  rx_scone_ad = extr def_mod 'VALE' 'RX' scone_ad ;
  ry_scone_ad = extr def_mod 'VALE' 'RY' scone_ad ;
  rz_scone_ad = extr def_mod 'VALE' 'RZ' scone_ad ;
  def_ad = manu chpo MESH_AD 6 ux_scone_ad 'UX' uy_scone_ad 'UY' uz_scone_ad 'UZ' rx_scone_ad 'RX' ry_scone_ad 'RY' rz_scone_ad 'RZ';

  def_mod = chan 'ATTRIBUT' def_mod  'NATURE' 'DIFFUS' ;
  def_ad  = chan 'ATTRIBUT' def_ad 'NATURE' 'DIFFUS' ;

  tmode_ad . modes . &bela . deformee_modale = (def_mod et def_ad) ;
fin bela ;

   N_DEF = 1 ;
*  REPE BVTK (Nt - 2);
   REPE BVTK (enti ((flott Nt)/(flott N_def))) ;
* RECO:
    D1 =  RECO  TRESU  Tmode_tot (extr tprog (N_def*&BVTK)) 'DEPL';
* EXTR:
    DEP1 = D1 exco (mots 'UX' 'UY' 'UZ') ;
* INSTANT VTK:
    T_I = (extr tprog &BVTK) ;
* SORTIE VTK:  
*   adaptateur :
    OPTI 'SORT'  (chai 'VTK/manchadela_adaptateur');
    SORT 'VTK' (adaptateur_vtk) 'MAIL' DEP1 'DEPL' 'TEMP' T_I;
*   manchette :
    OPTI 'SORT'  (chai 'VTK/manchadela_manchette');
    SORT 'VTK' (manchette_vtk) 'MAIL' DEP1 'DEPL' 'TEMP' T_I;
*
*   FPLAM_H = EXTR (tresu . TLHORIZ_H . 'FORCE_DE_CHOC_POINT_A') (&BVTK) ;
*   PLAMH_vtk = (VIDE 'MAILLAGE') ET PLAM_H ; 
*   CHFPLAMH = MANU CHPO PLAMH_vtk 3 0. 'UX' 0. 'UY' FPLAM_H 'UZ' ;
*   OPTI 'SORT' 'VTK/VFH' ;
*   SORT 'VTK' PLAMH_vtk 'MAIL' CHFPLAMH 'DEPL' 'TEMP' T_I ;
   FIN BVTK;
* FIN SI FLVTK:
FINSI;
****************************************************************************
*           FIN VTK
****************************************************************************

* opti donn 5 ;

fin ; 