      SUBROUTINE cmrth(Q1,KTROT,NA1,NB1M,IB,ind,na3,ina1) 
*     SUBROUTINE cmrth(Q1,KTROT,NA1,NB1M,IB,mrth,mthr,ind,na3,ina1) 
     
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
******************************************************************
*         BRAS de levier : seulement si le centred rotation n'est pas confondu avec le centre de gravite
******************************************************************
*   consistent mass  : shabana p 272 :
*   mrth = - A * int_V rho chap(X + u_f) dV 
*   lumped masses : shabana p 320 :
*   mthr = sum_j m_ij * B^T , i = mode , j = node, B = - A chap(X+u_f)
*   tous les modes ne sont pas pris en compte, on divise en :
*     - une partie statique : la masse totale du solide qui est egale en th. a la somme de toutes les lumped masses si on les prenaient toutes en compte
*     mrth_stat = - Mtot * A * chap(X_j) , j = node 
*     - une partie corrective :  
*     mrth_corr = - sum_i sum_j m_ij * A * chap(phi_ij * qf_i), i = mode , j = node 
*
*   Rq partie corrective : on saute les translations rigides
******************************************************************

      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EDEF(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XMNO(NA2,NSB),QVTH(3,NSB),QVR(3,NSB),QVF(NA2,NSB)
         REAL*8 MRTH(3,3,NSB),MTHTH(3,3,NSB)
         REAL*8 MFTH(NA2,3,NSB),MFR(NA2,3,NSB),MTOT(NTOT,NTOT,NSB)
         REAL*8 SKL(3,3,NA2,NA2,NSB),IKL(3,3,NA2,NSB)
         REAL*8 BL0(3,NSB),BLF(3,NA2,NSB)
         REAL*8 XMPOI(NPDEF,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT
*
      REAL*8 Q1(NA1,*)
*      REAL*8 xcgcha(3,3)
      real*8 xt(3),xtcha(3,3)
*
******************************************************************
      mtrot = ktrot
******************************************************************
      npdef = xtphi(/2)
******************************************************************
*      write(*,*)'cmrth : arguments :'
*      write(*,*)'ib = ',ib 
*      write(*,*)'na1 = ',na1 
*      write(*,*)'ind = ',ind 
*      write(*,*)'ina1 = ',ina1 
*      write(*,*)'na3 = ',na3 
*      write(*,*)'npdef = ',npdef 
*      write(*,*)'ktrot = ',ktrot 

*      write(*,*)'cmrth : avant calcul :'
*      write(*,*)'       mrth :'
*       do id=1,3
*          write(*,'(3(1X,F8.5))') , (mrth(id,j,ib),j=1,3)
*       enddo
*     write(*,*)'       mthr :'
*      do id=1,3
*         write(*,'(3(1X,F8.5))') , (mthr(id,j),j=1,3)
*      enddo
******************************************************************
*     nbr de modes elastiques dans la sous bases :
******************************************************************
*     na3 = inmsb(ib)
*     1er mode elast ou transl rigi de la sous base ib ds l'ensemble des modes elast + trans rigis
*     ina1 = iorsb(ib) - 1
******************************************************************
*   Partie statique
******************************************************************
*      call chap(XCG(1,ib),XCGcha(1,1)) 
**      write(*,*)'cmrth : xcgcha :'
**      write(*,*)'mtsb = ',mtsb(ib)
**       do id=1,3
**          write(*,'(3(1X,F8.5))') , (xcgcha(id,j),j=1,3)
**       enddo
**      write(*,*)'cmrth : rot :'
**       do id=1,3
**          write(*,'(3(1X,F8.5))') , (rot(id,j,ind,ib),j=1,3)
**       enddo
*      do id=1,3
*        do j=1,3
*          mrth(id,j,ib) = 0.d0
*          do k=1,3
*           mrth(id,j,ib) = mrth(id,j,ib)-(rot(id,k,ind,ib)*XCGcha(k,j))
*          enddo
*          mrth(id,j,ib) = mtsb(ib) * mrth(id,j,ib)
**         mthr(id,j) = 0.d0
**         do k=1,3
**           mthr(id,j) = mthr(id,j) + XCGcha(id,k) * rot(j,k,ind,ib)
**         enddo
**         mthr(id,j) = mtsb(ib) * mthr(id,j)
*        enddo
*      enddo
**      write(*,*)'cmrth : partie statique :'
**      do id=1,3
**        do j=1,3
**          write(*,*) , mrth(id,j,ib)
**        enddo
**      enddo
*******************************************************************
**     Partie corrective :
*******************************************************************
*      do ip=1,npdef
*******************************************************************
*        do 1 in = 1,na3
*          if (itrig(ib,in)) goto 1
*          i2 = ina1 + in
*          do id=1,3
*            Xt(id) = xtphi(id,ip,in,ib) * q1(i2,ind) 
*          enddo
*          call chap(Xt(1),Xtcha(1,1)) 
**         mrth :
*          do id=1,3
*            do j=1,3
*              do k=1,3
*                mrth(id,j,ib) = mrth(id,j,ib) - 
*     &          (xmpoi(ip,ib)*rot(id,k,ind,ib)*Xtcha(k,j))
*              enddo
**             mrth(id,j) =  xmpoi(ip,ib) * mrth(id,j)
**             write(*,*)'xmpoi(',ip,in,ib,') : '
**             write(*,*),xmpoi(ip,ib)
**             write(*,*)'mrth(id,j,ib) : '
**             write(*,*),mrth(id,j,ib)
*            enddo
*          enddo
**         mthr :
**         do id=1,3
**           do j=1,3
**             do k=1,3
**               mthr(id,j) = mthr(id,j) + Xtcha(id,k) * rot(j,k,ind,ib)
**             enddo
**             mthr(id,j) =  xmpoi(ip,ib) * mthr(id,j)
**           enddo
**         enddo
* 1      continue
****** fin boucle sur les points 
*      enddo

*     NEW : AVEC LES BRAS DE LEVIER CALCULES DANS DYNE26 :      
*     le bras de levier est egal a la partie statique ...
*     ... plus la partie dynamique :
      do id=1,3
        xt(id) = bl0(id,ib) 
        do in=1,na3
          i2 = ina1 + in
          if (.not.itrig(ib,in)) then
            xt(id) = xt(id) + blf(id,in,ib)*q1(i2,1) 
          endif
        enddo
      enddo
*     on fait le produit vectoriel
      xtcha(1,1) = 0.d0
      xtcha(2,2) = 0.d0
      xtcha(3,3) = 0.d0
      xtcha(1,2) = -xt(3)
      xtcha(1,3) = xt(2)
      xtcha(2,3) = -xt(1)
      xtcha(2,1) = -xtcha(1,2)
      xtcha(3,1) = -xtcha(1,3)
      xtcha(3,2) = -xtcha(2,3)
*     on mutliplie a gauche par -R(t) :
      do id=1,3
        do j=1,3
          do k=1,3
            mrth(id,j,ib) = mrth(id,j,ib) - rot(id,k,1,ib)*xtcha(k,j)
          enddo
        enddo
      enddo
* done
*      write(*,*)'MRTH tot :'
*      do id=1,3
*         do j=1,3
*         write(*,*) , (mrth(id,j,ib))
*         enddo
*      enddo
*
      END