c  spinextr  SOURCE MS264315  23/09/23  11:17:00  10718          
c  la 1ere subroutine en lower case de l'histoire !!!!
      SUBROUTINE spinextr(ib,nsb,rot,quat,kspin,tspin)
     
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*     but : extraire le spin (en radians) de l'adaptateur de la matrice 
*           de rotation,
*           en deduire le torque resistant sachant que Kspin est en 
*           N . m^-1 . rad^-1
*     ib    : indice de la ss base de l'adaptateur
*     kspin : raideur en rotation autour de l'axe propre de l'adaptateur
*     tspin : torque resistant au spin de l'adaptateur 
*--------------------------------------------------------------------*
      real*8 rot(3,3,2,nsb),kspin,tspin(3),tspinu(3)
*     variables locales : 
      real*8 quat(4,2,nsb),rot1(3,3),rot2(3,3),rp(3,3)
      real*8 tspinl(3),tspin1(3)
      real*8 quat2(4)
      real*8 exu(3),eyu(3),ezu(3)
*     pour test : 
*     real*8 ex(3),ey(3),ez(3)
*     real*8 thprec(3),thnut(3),thspin(3)
*     real*8 thexu(3),theyu(3),thezu(3)
*     real*8 rexu(3,3),reyu(3,3),rezu(3,3)
*     real*8 rprec(3,3),rnut(3,3),rspin(3,3),r1(3,3),r2(3,3)

      exu(1) = 0.d0
      exu(2) = -1.d0
      exu(3) = 0.d0
      eyu(1) = 0.d0
      eyu(2) = 0.d0
      eyu(3) = 1.d0
      ezu(1) = -1.d0
      ezu(2) = 0.d0
      ezu(3) = 0.d0
*     matrice de rotation pour passer dans le repere observateur 
*     dont les lignes sont les vect. de la base observateur.
*     x^i' = (e_i' . e_j) x^j
      rp(1,1) = exu(1)
      rp(1,2) = exu(2)
      rp(1,3) = exu(3)
      rp(2,1) = eyu(1)
      rp(2,2) = eyu(2)
      rp(2,3) = eyu(3)
      rp(3,1) = ezu(1)
      rp(3,2) = ezu(2)
      rp(3,3) = ezu(3)
*      write(*,*)'mat. passage rp :'
*      do id=1,3
*        write(*,'(3(1X,F8.5))') , (rp(id,j),j=1,3)
*      enddo
*     on passe la matrice de rotation dans la base observateur : 
*       etape 1 : rot1 = rot*rp^T
      do id=1,3
        do j=1,3
          rot1(id,j) = 0.d0
          do k=1,3
            rot1(id,j) = rot1(id,j) + rot(id,k,1,ib)*rp(j,k)
          enddo
        enddo
      enddo
*       etape 2 : rot2 = rp * rot * rp^T
      do id=1,3
        do j=1,3
          rot2(id,j) = 0.d0
          do k=1,3
            rot2(id,j) = rot2(id,j) + rp(id,k) * rot1(k,j) 
          enddo
        enddo
      enddo
*      write(*,*)'mat. rot. reprere global :'
*      do id=1,3
*        write(*,'(3(1X,F8.5))') , (rot(id,j,2,ib),j=1,3)
*      enddo
*      write(*,*)'mat. rot2 dans le repere observateur :'
*      do id=1,3
*        write(*,'(3(1X,F8.5))') , (rot2(id,j),j=1,3)
*      enddo
*     on extrait de la nouvelle matrice theta et psi (repere utilisateur)
*       method 1 : en passant par le quaternion : 
*      call mat2quat(rot2(1,1),quat2(1))

*      theta = sign(1.,rot2(3,2)) * 
*     &        acos((2.*((quat2(1)**2)+(quat2(4)**2))) - 1.d0)
*      write(*,*)'theta method 1 = ',theta
*      if (theta.gt.1.e-3) then
*        phi   = acos(-2.*((quat2(3)*quat2(4)) -
*     &                  (quat2(1)*quat2(2))) / sin(theta) )
*        psi   = acos(2.*((quat2(3)*quat2(4)) +
*     &                  (quat2(1)*quat2(2))) / sin(theta) )
*        theta = sign(1.,rot2(3,2))*theta
*        psi   = sign(1.,rot2(3,1))*sign(1.,theta)*psi
*        phi   = sign(1.,rot2(1,3))*sign(1.,theta)*phi
*        write(*,*)'test Method 1 :'
*        write(*,*)'precession phi = ',phi 
*        write(*,*)'nutation theta = ',theta 
*        write(*,*)'spin psi = ',psi 
*        write(*,*)'theta0 = ',cos(theta/2.)*cos((psi+phi)/2.)
*        write(*,*)'quat0 = ',quat2(1)
*        write(*,*)'theta1 = ',sin(theta/2.)*cos((phi-psi)/2.)
*        write(*,*)'quat1 = ',quat2(2)
*        write(*,*)'theta2 = ',sin(theta/2.)*sin((phi-psi)/2.)
*        write(*,*)'quat2 = ',quat2(3)
*        write(*,*)'theta3 = ',cos(theta/2.)*sin((psi+phi)/2.)
*        write(*,*)'quat3 = ',quat2(4)
*      endif

*     Method 2 : en extrayant directement de la matrice rot2 :
*     preventing float error : 
      if (abs(rot2(3,3)).gt.1.d0) rot2(3,3) = dsign(1.d0,rot2(3,3))
*     nutatioin extraction : 
      theta =  dsign(1.d0,rot2(3,2))*acos(rot2(3,3))
*      write(*,*)'theta method 2 = ',theta
      if (abs(theta).le.1.e-3) then
*        write(*,*)'spinextr : theta <= 1.e-3'
*       on considere que l'adaptateur est reste vertical :
        psi = atan2(rot(3,2,1,ib),rot(2,2,1,ib))
        tspin(1) = -kspin*psi
        tspin(2) = 0.
        tspin(3) = 0.
      endif
      if (abs(theta).gt.1.e-3) then
*        write(*,*)'spinextr : theta > 1.e-3'
        psi = asin(rot2(3,1)/sin(theta))
*       dans le repere local le couple resistant aura pour expr. :
*         Tspin = (0 0 -kspin*psi)^T
*       dans le repere de l'observateur :
*         tspinu = rot2 * Tspin
*       dans le repere global : 
*         tspin = rp^T * rot2 * Tspin = rot * rp^T * Tspin
        tspinl(1) = 0.
        tspinl(2) = 0.
        tspinl(3) = (-1.d0)*kspin*psi
*       resistive torque in the observer reference frame :
        do id=1,3
          tspinu(id) = 0.d0
          do j=1,3
            tspinu(id) = tspinu(id) + rot2(id,j)*tspinl(j)
          enddo
        enddo
*       resistive torque in the global reference frame :
        do id=1,3
          tspin(id) = 0.d0
          do j=1,3
            tspin(id) = tspin(id) + rp(j,id)*tspinu(j)
          enddo
        enddo
*        write(*,*)'psi = ',psi
*       write(*,*)'tspin=rp^T*rot2*tspinl : tspin(1) = ',tspin(1)
*       write(*,*)'tspin=rp^T*rot2*tspinl : tspin(2) = ',tspin(2)
*       write(*,*)'tspin=rp^T*rot2*tspinl : tspin(3) = ',tspin(3)
      endif

      end

*     passage dans le repere utilisateur 
*     ex' = 0 -1 0
*     ey' = 0 0 1
*     ez' = -1 0 0 
*     ex(1) = 1.d0
*     ex(2) = 0.d0
*     ex(3) = 0.d0
*     ey(1) = 0.d0
*     ey(2) = 1.d0
*     ey(3) = 0.d0
*     ez(1) = 0.d0
*     ez(2) = 0.d0
*     ez(3) = 1.d0

*     thprec(1) = phi*ez(1)
*     thprec(2) = phi*ez(2)
*     thprec(3) = phi*ez(3)

*     thnut(1) = theta*ex(1)
*     thnut(2) = theta*ex(2)
*     thnut(3) = theta*ex(3)

*     thspin(1) = psi*ez(1)
*     thspin(2) = psi*ez(2)
*     thspin(3) = psi*ez(3)

*     call expthr(thprec,rprec)
*     call expthr(thnut,rnut)
*     call expthr(thspin,rspin)

*     write(*,*)'rprec :'
*     do id=1,3
*       write(*,'(3(1X,F8.5))') , (rprec(id,j),j=1,3)
*     enddo
*     write(*,*)'rnut :'
*     do id=1,3
*       write(*,'(3(1X,F8.5))') , (rnut(id,j),j=1,3)
*     enddo
*     write(*,*)'rspin :'
*     do id=1,3
*       write(*,'(3(1X,F8.5))') , (rspin(id,j),j=1,3)
*     enddo
*     do id=1,3
*       do j=1,3
*         r2(id,j) = 0.d0
*         do k=1,3
*           r2(id,j) = r2(id,j) + rnut(id,k)*rspin(k,j) 
*         enddo
*       enddo
*     enddo
*     do id=1,3
*       do j=1,3
*         r1(id,j) = 0.d0
*         do k=1,3
*           r1(id,j) = r1(id,j) + rprec(id,k)*r2(k,j) 
*         enddo
*       enddo
*     enddo
*     write(*,*)'rprec x rnut x rspin :'
*     do id=1,3
*       write(*,'(3(1X,F8.5))') , (r1(id,j),j=1,3)
*     enddo
*     matrice de rotation autour de ex' = 0 -1 0
*     xphi = 0.5
*     xtheta = 0.5
*     xpsi = 0.5
*     thexu(1) = thtest*exu(1)
*     thexu(2) = thtest*exu(2)
*     thexu(3) = thtest*exu(3)

*     theyu(1) = thtest*eyu(1)
*     theyu(2) = thtest*eyu(2)
*     theyu(3) = thtest*eyu(3)

*     thezu(1) = thtest*ezu(1)
*     thezu(2) = thtest*ezu(2)
*     thezu(3) = thtest*ezu(3)

*     call expthr(thexu,rexu)
*     call expthr(theyu,reyu)
*     call expthr(thezu,rezu)
*     write(*,*)'cos(thtest) = ',cos(thtest)
*     write(*,*)'sin(thtest) = ',sin(thtest)
*     write(*,*)'mat. rot. autour de exu'
*     do id=1,3
*       write(*,'(3(1X,F8.5))') , (rexu(id,j),j=1,3)
*     enddo
*     write(*,*)'mat. rot. autour de eyu'
*     do id=1,3
*       write(*,'(3(1X,F8.5))') , (reyu(id,j),j=1,3)
*     enddo
*     write(*,*)'mat. rot. autour de ezu'
*     do id=1,3
*       write(*,'(3(1X,F8.5))') , (rezu(id,j),j=1,3)
*     enddo

        
