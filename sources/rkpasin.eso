      SUBROUTINE RKPASIN(Q1,Q2,Q3,NA1,NPC1,XK,XASM,XM,PDT,T,NPAS,
     &   FTOTA,FEXA,NPFEXA,NLIAA,NLSA,IPALA,IPLIA,XPALA,XVALA,
     &   NLIAB,NLSB,NPLB,IDIMB,IPALB,IPLIB,JPLIB,XPALB,XVALB,FTOTB,
     &   FTOTBA,XPTB,FEXPSM,
     &   FINERT,IERRD,FTEST,FTEST2,WEXT,WINT,
     &   XABSCI,XORDON,NIP,FTEXB,FEXB,KTROT,KTPHI,XCHPFB,
     &   XOPM1,NB1,NB1K,NB1C,NB1M,NSB,NTOT) 
     
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*                                                                    *
*     Op�rateur DYNE : algorithme des DIFFERENCES CENTREES           *
*     ________________________________________________               *
*                                                                    *
*     Calcul d'un pas de temps, appel aux s-p sp�cifiques.           *
*                                                                    *
*     Param�tres:                                                    *
*                                                                    *
* es  Q1(,)   Vecteur des d�placements g�n�ralis�s                   *
* es  Q2(,)   Vecteur des vitesses g�n�ralis�es                      *
* es  Q3(,)   Vecteur des acc�l�rations g�n�ralis�es                 *
* es  NA1     Nombre total d'inconnues en base A                     *
* es  NPC1    Nombre de pas de calcul - 1                            *
* es  XK      Vecteur des raideurs g�n�ralis�es                      *
* es  XASM    Vecteur des amortissements g�n�ralis�s                 *
* es  XM      Vecteur des masses g�n�ralis�es                        *
* e   PDT     pas de temps courant                                   *
* e   T       temps courant                                          *
* e   NPAS    Num�ro du pas de temps                                 *
* es  FTOTA   Forces ext�rieures totalis�es, sur la base A           *
* es  FEXA    Evolution des forces ext�rieures en base A             *
* e   FTEXB   Evolution des forces ext�rieures en base B             *
* e   FEXB    Forces ext�rieures sur la base B, servant au calcul    *
*             des moments pour les corps rigides.                    *
* e   RIGIDE  Vrai si corps rigide, faux sinon                       *
* es  IFEXA   Num�ro du mode correspondant au point de chargement    *
*             (supprime le 2018-12-14 par bp)                        *
* es  NPFEXA  Nombre de points de chargement                         *
* e   NLIAA   Nombre de liaisons sur la base A                       *
* e   NLSA    Nombre de liaisons A en sortie                         *
* e   IPALA   Tableau renseignant sur le type de liaison (base A)    *
* e   IPLIA   Tableau contenant les num�ros "DYNE" des points        *
* e   XPALA   Tableau contenant les param�tres des liaisons          *
* es  XVALA   Tableau contenant les variables internes de liaison A  *
*     XPHILB  Vecteur des deformees modales                          *
* e   NLIAB   Nombre de liaisons sur la base B                       *
* e   NLSB    Nombre de liaisons base B en sortie                    *
* e   NPLB    Nombre total de points de liaisons (base B)            *
* e   IDIMB   Nombre de directions                                   *
* e   IPALB   Tableau renseignant sur le type de liaison             *
* e   IPLIB   Tableau contenant les numeros "DYNE" des points        *
* e   JPLIB   Tableau contenant les numeros "GIBI" des points        *
* e   XPALB   Tableau contenant les parametres des liaisons (base B) *
* es  XVALB   Tableau contenant les variables internes de liaison B  *
*     FTOTB   Forces exterieures totalisees sur la base B            *
* e   XABSCI  Tableau contenant les abscisses de la loi plastique    *
* e   XORDON  Tableau contenant les ordonnees de la loi plastique    *
* e   NIP     Nbr de points dans l'evolution de la loi plastique     *
*     FTOTBA  Forces totales base B projetees base A                 *
*     XPTB    Deplacements des points de liaison                     *
*     IBASB   Appartenance des points de liaison a une sous-base     *
*     IPLSB   Position du point de liaison dans la sous-base         *
*     INMSB   Nombre de modes dans la sous-base                      *
*     IORSB   Position du 1er mode de la sous-base dans ens. modes   *
*     IAROTA  Indique la position des modes de rotation              *
*     NSB     Nombre de sous-bases                                   *
*     NPLSB   Nombre de points de liaison par sous base              *
*     IERRD   Indicateur d'erreur                                    *
* -   FTEST   Tableau local FTEST de la subroutine D2VLFA            *
* -   FTEST2  Tableau local FTEST de la subroutine DEVLB1            *
* e,s WEXT   travail des forces exterieures                          *
* e,s WINT   travail des forces interieures (rigidite et             *
*            amortissement et forces de liaison )                    *
*                                                                    *
*     fmomtot : couple exterieur dans le body frame pour la phase rk4!!
*--------------------------------------------------------------------*
*
-INC CCREEL
*
      SEGMENT,MTPHI
         INTEGER IBASB(NPLB),IPLSB(NPLB),INMSB(NSB),IORSB(NSB)
         INTEGER IAROTA(NSB)
         REAL*8 XPHILB(NSB,NPLSB,NA2,IDIMB)
      ENDSEGMENT
      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EDEF(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XMNO(NA2,NSB),QVTH(3,NSB),QVR(3,NSB),QVF(NA2,NSB)
         REAL*8 MRTH(3,3,NSB),MTHTH(3,3,NSB)
         REAL*8 MFTH(NA2,3,NSB),MFR(NA2,3,NSB),MTOT(NTOT,NTOT,NSB)
         REAL*8 SKL(3,3,NA2,NA2,NSB),IKL(3,3,NA2,NSB)
         REAL*8 BL0(3,NSB),BLF(3,NA2,NSB)
         REAL*8 XMPOI(NPDEF,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT
      
*
*      INTEGER IFEXA(*),IPALA(NLIAA,*),IPLIA(NLIAA,*)
      INTEGER IPALA(NLIAA,*),IPLIA(NLIAA,*)
      INTEGER IPALB(NLIAB,*),IPLIB(NLIAA,*),JPLIB(*)
      REAL*8 Q1(NA1,*),Q2(NA1,*),Q3(NA1,*)
* Matt: ligne parmetres corps rigide:
      REAL*8 DYN2(3),DQUAT(4)
*
      REAL*8 XVALA(NLIAA,4,*),XPALA(NLIAA,*),XM(NA1,*),XK(NA1,*)
      REAL*8 XPALB(NLIAB,*),XVALB(NLIAB,4,*),FEXPSM(NPLB,NPC1,2,*)
      REAL*8 XASM(NA1,*),FTOTA(NA1,*),FEXA(NPFEXA,NPC1,*)
      REAL*8 FTOTB(NPLB,*),FTOTBA(*),XPTB(NPLB,2,*),FINERT(NA1,*)
      REAL*8 WEXT(NA1,2),WINT(NA1,2)
      REAL*8 XABSCI(NLIAB,*),XORDON(NLIAB,*),FEXB(NPLB,3,*)
      REAL*8 FTEST(NA1,4), FTEST2(NPLB,6)
      REAL*8 FTEXB(NPLB,NPC1,2,*),XCHPFB(2,NLIAB,4,NPLB)
cbp,2020-09      REAL*8 XOPM1(NB1,NB1,*),Q2DEMI(NA1),FAMOR(NA1)
      REAL*8 XOPM1(NB1,NB1,*),FAMOR(NA1)
      
*     TODO : KTOTXA et KTOTVA a allouer dans le segment LOCLFA ?
      REAL*8 KTOTXA(NA1,NA1), KTOTVA(NA1,NA1) 
*     TODO : KTOTXB et KTOTVB a allouer dans le segment LOCLFB ?
      REAL*8 KTOTXB(NPLB,IDIMB,IDIMB),KTOTVB(NPLB,IDIMB,IDIMB) 
*
c     LOGICAL LWRITE
      LOGICAL RIGIDE,lxpinv,linert,methJ1,methJ2
* CMS : 
      REAL*8 FAMO1(NA1),FAMO2(NA1)
cms : pour le couple resistant "hard code" : 
      real*8 tspin(3)
*     pour le calcul des forces d'inerties :
      logical lrspin,lbt,lcb 
*     vecteurs de rotations incrementaux :
      real*8 th1(3), th2(3), th3(3), th4(3) 
*      real*8 mdexp(3,3)
*     accelerations translations rigides + couple inertiel base A (body frame): 
      real*8 atrans(3),ginea(3)
      real*8 ftrans(3)
      real*8 rtgex(3),jw(3),wjw(3)
*     Pour le calcul des energies cinetiques dues aux termes nn-diagonaux :
      real*8 x(3)
*      real*8 ine(3,3),invine(3,3)

*     resistance au spin ?
      lrspin = .false.
*     correction dexpinv ?
      lxpinv = .false.
*     method de calcul de la MAJ du tenseur d'inertie J ?
      methJ1 = .false.
      methJ2 = .true.
*     book toss ?
      lbt = .false.
*     coulombic soft wall ?
      lcb = .false.

*     le cas echeant, base modale de l'adaptateur : 
      ibad = 1

      RIGIDE = (KTROT.NE.0)
      IF (RIGIDE) THEN
        MTROT = KTROT
        npdef = xtphi(/2)
      ENDIF
      MTPHI  = KTPHI
      NSB = XPHILB(/1)
      NPLSB = XPHILB(/2)
      NA2 =  XPHILB(/3)
*      IF (IIMPI.EQ.555) THEN 
cmsw        WRITE(*,*)'D2VPAS: KTROT = ',KTROT
cmsw        WRITE(*,*)'        RIGIDE = ',RIGIDE
cmsw        WRITE(*,*)'        NSB =',NSB
cmsw        WRITE(*,*)'        IDIMB = ',IDIMB
cmsw        WRITE(*,*)'        NLIAA = ',NLIAA
cmsw        WRITE(*,*)'        NLIAB = ',NLIAB
*      ENDIF
* Calcul de IDIM pour le calcul de l energie cinetique :
      IF (IDIMB.EQ.6) THEN
        IDIM=3
      ELSEIF (IDIMB.EQ.3) THEN
        IDIM=2
      ENDIF
C     Parametres d'affichage (pour debuggage) 
c     LWRITE=.false.
c     LWRITE=(NPAS.LE.20).OR.(MOD(NPAS,1000).EQ.0)
c     if(LWRITE) write(*,*) '-------- NPAS =',NPAS

************************************************************************
*     Parametres temporels locaux
************************************************************************
      tdeb = T
      tfin = T + PDT
      dt = PDT
      dt2 = dt/2.D0
      dt22 = dt*dt2

*     write(*,*)'rkpas : indice 5 :'
*     write(*,*)'        mat. inertie :'
*     do id=1,3
*        write(*,'(3(1X,F8.5))') , (inertie(id,j,1),j=1,3)
*     enddo
*     write(*,*)'         omeg2 :'
*     WRITE(*,'(3(1X,F8.5))')((omeg2(id,5,1),id=1,3),isb=1,nsb)
************************************************************************
*     remplissage de fexb(ip,1,id) et ftota(i,1) : "les deux extremites du pas de temps"
************************************************************************
***** court-circuit : prediction diff centrees :
*     rotations :
      do iib=1,nsb
      if (.not.(iarota(iib).eq.0)) then
      do i=1,3
        dtheta(i,iib) = omeg2(i,2,iib)*dt + omeg3(i,2,iib)*dt22
      enddo
*      calcul de EXPTH pour eq. dynamique:
      call expthr(dtheta(1,iib),expth(1,1,1,iib))
*       increment de rotation --> quaternion
      call vect2quat(dtheta(1,iib),dquat)
*       maj quaternion omeg1:
      call pquat(omeg1(1,2,iib),dquat,omeg1(1,1,iib))
      call quat2mat(omeg1(1,1,iib),rot(1,1,1,iib)) 
      endif
*      fin boucle prediction sur les ss bases
      enddo
*     ddls flexibles 
      do  i = 1,na1
       q1(i,1) = q1(i,2) + q2(i,2)*dt + q3(i,2)*dt22
      enddo
*     remplissage de ftota avec fexa :
      CALL D2VFXA(FEXA,FTOTA,NPFEXA,NA1,NPC1,NPAS,FTEXB,FEXB,
     &              NPLB,IDIMB,RIGIDE)
*     rotations : vitesse au 1/2 pas de temps
      do i=1,3
        omeg2(i,1,iib) = dtheta(i,iib)/dt
      enddo
*     flexibles : vitesse au 1/2 pas de temps
      do i=1,na1
       q2(i,1)=(q1(i,1)-q1(i,2))/dt
      enddo
*     pas de condition sur l'appel a d2vfxa.
*      CALL RKFXA(FEXA,FTOTA,NPFEXA,NA1,NPC1,NPAS,FTEXB,FEXB,
*     &              NPLB,IDIMB,RIGIDE)
************************************************************************
*     Calcul des forces de liaisons
************************************************************************
**     Totalisation des forces ext�rieures pour la base A a la fin du pas
**     rq : rkfxa ne perturbe pas l'implementation des forces exterieures 
*      CALL RKFXA(FEXA,FTOTA,NPFEXA,NA1,NPC1,NPAS,FTEXB,FEXB,
*     &              NPLB,IDIMB,RIGIDE)
*     Ajout des forces de liaison
      IF (NLIAA.NE.0) THEN
         CALL D2VLFA(Q1,Q2,FTOTA,NA1,IPALA,IPLIA,XPALA,XVALA,
     &               NLIAA,dt,tfin,NPAS,1,FINERT,0,FTEST,
     &               KTOTXA,KTOTVA,.FALSE.)
      ENDIF
      IF (IIMPI.EQ.333) WRITE(IOIMP,*)'D2VPAS: NLIAB = ',NLIAB
      IF (NLIAB.NE.0) THEN
         IF (IIMPI.EQ.333) THEN
cmsw           WRITE(IOIMP,*)'D2VPAS : appel au sous-programme D2VLFB'
         ENDIF      
*        WRITE(*,*)'rkpas : appel au sous-programme D2VLFB'
*        dernier arg = .false. --> calcul du moment au pas t_n+1 via rkmom
*        differences centrees mais pas simo et wong --> rkmom  
*        couple exterieur estime a l'instant tn+1 <--> ind = 1
         CALL D2VLFB(Q1,Q2,FTOTA,NA1,IPALB,IPLIB,XPALB,XVALB,NLIAB,
     &               XPHILB,JPLIB,NPLB,IDIMB,FTOTB,FTOTBA,XPTB,dt,tfin,
     &               NPAS,IBASB,IPLSB,INMSB,IORSB,NSB,NPLSB,NA2,1,
     &               FEXPSM,NPC1,IERRD,FTEST2,XABSCI,XORDON,NIP,
     &               FEXB,KTROT,IAROTA,XCHPFB,
     &               KTOTXA,KTOTVA,KTOTXB,KTOTVB,.FALSE.,.false.)
*     &               KTOTXA,KTOTVA,KTOTXB,KTOTVB,.FALSE.,.false.)
         IF (IERRD.NE.0) RETURN
      ENDIF
      if (lrspin) then 
*       achtung!! hard code : pour l'adaptateur : 
*       on impose une raideur en rotation
        xkspin = 5538.73
        call spinextr(ibad,nsb,rot,omeg1,xkspin,tspin)
        fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + tspin(1)
        fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + tspin(2)
        fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + tspin(3)
      endif
*     hard coded external torques :
      if (lbt) then 
        nd = floor(2.d0/pdt)
        if (t.le.(2.-pdt)) then 
          fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 20.
          fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 0.
          fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
        endif
        if ((npas.eq.nd).or.(npas.eq.(nd+1))) then 
          fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 0.
          fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + (2.d-1/pdt)
          fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
        endif
        if (t.ge.(2.+pdt)) then 
          fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 0.
          fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 0.
          fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
        endif
      endif
      if (lcb) then 
        xcgex = ((1.d-2*((1.1+rot(3,3,1,ibad))**(-11.d0))) -
     &                    ((1.1+rot(3,3,1,ibad))**(-2.d0)))
        fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 
     &                       -xcgex*rot(2,3,1,ibad)
        fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 
     &                       xcgex*rot(1,3,1,ibad)
        fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 
     &                        0.
      endif
******************************************************************
*     force de raideur / d'amortissement :
******************************************************************
*     ajout des forces de raideurs :
*      CALL RKLK0(Q1,XK,FTOTA,NA1,NB1K,1,1)
      CALL DEVLK0(Q1,XK,FTOTA,NA1,NB1K,1)
*     ajout des forces d'amortissement :
      IF (NB1C.GT.1) THEN
        DO I=1,NA1
           FAMOR(I) = 0.D0
          DO J=1,NB1
            FAMOR(I) = FAMOR(I) + XASM(I,J) * Q2(J,1)
          enddo
        enddo
      ELSE
        DO I=1,NA1
           FAMOR(I) = XASM(I,1) * Q2(I,1)
        enddo
      ENDIF
************************************************************************
*     EquilibreS DynamiqueS (separes)
************************************************************************
************************************************************************
* ROTATIONS RIGIDES: calcul des matrices necessaires au calcul des forces d'inertie 
*     dans le repere spatial --> on prend le quaternion omeg1 (orientation dans le repere spatial).
******************************************************************
      if (rigide) then
******************************************************************
        do 1 iib=1,nsb
**        na3 : nombre de modes elastiques + translations rig
**              dans la ss base iib.
        na3 = inmsb(iib)
*        premier mode elast ou transl rigi de la sous base iib ds l'ensemble des modes elast + trans rigis
        ina1 = iorsb(iib) - 1
*        initialisation des forces d'inertie, pour ttes les ss bases!
*         --> apparaissent apres dans l'equilibre dynamique
        do id=1,3
          qvr(id,iib) = 0.d0
          qvth(id,iib) = 0.d0
          do j=1,3
            mrth(id,j,iib) = 0.d0
            mthth(id,j,iib) = 0.d0
          enddo
        enddo
        do in=1,na2
          qvf(in,iib) = 0.d0
          do id=1,3
            mfr(in,id,iib) = 0.d0
            mfth(in,id,iib) = 0.d0
          enddo
        enddo
        do i1=1,ntot
          do i2=1,ntot
            mtot(i1,i2,iib) = 0.d0
          enddo
        enddo
*       maintenant on peut sauter les ss bases ss rotas rigides :
        if (iarota(iib).eq.0) goto 1
*       on repere le nombre de translations rigides a retirer de la  
*       dimension pour inverser.
        ntrig = 0
        do in=1,na3
          if (itrig(iib,in)) then 
            ntrig = ntrig + 1
          endif
        enddo
*        write(*,*)'rkpasin : ntrig = ',ntrig
******************************************************************
*       indice auquel sont calculees les forces d'inertie :
******************************************************************
        ind1=1
******************************************************************
*     M_{Rth} : couplage rotas-trnaslas shabana p 320
******************************************************************
        if (ntrig.gt.0) then
          call cmrth(Q1,KTROT,NA1,NB1M,IIB,ind1,na3,ina1) 
        endif
******************************************************************
******************************************************************
*     M_{fR} (dim : nmodes x 3) : couplage elas-translas shabana p 320
******************************************************************
        if (ntrig.gt.0) then
          call cmfr(Q1,KTROT,NA1,NB1M,IIB,ind1,na3,ina1) 
        endif
******************************************************************
******************************************************************
*     M_{fth} (dim : nmodes x 3) : couplage elas-rotas shabana p 320
******************************************************************
        call cmfth(Q1,XM,KTROT,NA1,NB1M,IIB,ind1,na3,ina1) 
*******************************************************************
******************************************************************
*    M_{thth} (dim : 3 x 3) : modif tenseur d'inertie du aux defo elastiques.
*                          (shabana p 320)
******************************************************************
        call cmthth(Q1,KTROT,NA1,NB1M,IIB,ind1,na3,ina1) 
*******************************************************************
* remplissage mtot :  
*******************************************************************
*     objecif : dans la matrice mtot(ntot,ntot,nsb), squizzer en haut a 
*     gauche les parties pleines (necessaire pour inversion via invalm).
*     initialisation :
*       write(*,*)'tenseur d inertie :'
*       do id=1,3
*          write(*,'(3(1X,F8.5))') , (inertie(id,j,iib),j=1,3)
*       enddo
*      write(*,*)'ntrig = ',ntrig
****** blocs diagonaux :
*     lignes 1-3 : translations
*     bloc (1,1) : mRR a 
      if (ntrig.gt.0) then
      id=1
      do in=1,na3
        i2=ina1+in
        if (itrig(iib,in)) then
          mtot(id,id,iib) = xm(i2,1)  
          id = id + 1
          write(*,*)'trans rig : xm = ',xm(i2,1)
        endif
      enddo
      endif
*     lignes ntrig+1 -> ntrig+3 : rotations
*     bloc (2,2) du milieu : cmthth
      do id=1,3  
        id2 = id + ntrig
        do j=1,3
          j2= j + ntrig
*         mtot(id2,j2,iib) = mthth(id,j,iib)
          mtot(id2,j2,iib) = inertie(id,j,iib) + mthth(id,j,iib)
*          write(*,*)'rempl. mthth = ',mtot(id2,j2,iib)
        enddo
      enddo
*     lignes 7-na2 : flexible
*     bloc (3,3) : cmff cas diagonal 
      in1 = 3 + ntrig + 1
      do in=1,na3
        i2 = ina1 + in
        if (.not.itrig(iib,in)) then 
          mtot(in1,in1,iib) = xm(i2,1) + dt2*XASM(I2,1) - FINERT(I2,1)  
          in1 = in1 + 1
        endif
      enddo
****** blocs non-diagonaux :
*     bloc (1,2) : mRth 
      if (ntrig.gt.0) then
      do id=1,ntrig
        do j=1,3
          j2 = j + ntrig
          mtot(id,j2,iib) = mrth(id,j,iib)
          mtot(j2,id,iib) = mrth(id,j,iib)
*          write(*,*)'mrth coeff'
*          write(*,*)'          id',id
*          write(*,*)'          j2',j2
        enddo
      enddo
      endif
*     bloc (1,3) : mRf = mfR^T
      if (ntrig.gt.0) then
      in1 = 3 + ntrig + 1
      do in=1,na3
        if (.not.itrig(iib,in)) then
          do id=1,ntrig 
            mtot(in1,id,iib) = mfr(in,id,iib)
            mtot(id,in1,iib) = mfr(in,id,iib)
*            write(*,*)'mfr coeff'
*            write(*,*)'          id',id
*            write(*,*)'          in1',in1
          enddo
          in1 = in1 + 1
        endif
      enddo
      endif
*     bloc (2,3) : cmthf = cmfth^T
      in1 = 3 + ntrig + 1
      do in=1,na3  
        if (.not.itrig(iib,in)) then
          do id=1,3
            id2 = id + ntrig
            mtot(in1,id2,iib) = mfth(in,id,iib)
            mtot(id2,in1,iib) = mfth(in,id,iib)
          enddo
          in1 = in1 + 1 
        endif
      enddo

*       write(*,*)'matrices totale :'
*       write(*,*)'MFF mtot :'
*       do i1=1,(na3-ntrig)
*          write(*,'(20F15.5)') , 
*     &    (mtot(i1+3+ntrig,i2+3+ntrig,iib),i2=1,(na3-ntrig))
*       enddo
*       write(*,*)'MRTH :'
*       do id=1,3
*          write(*,'(20F15.5)') , (mrth(id,j,iib),j=1,3)
*       enddo
*       write(*,*)'MRTH mtot :'
*       do id=1,3
*          write(*,'(20F15.5)') , (mtot(id,j+ntrig,iib),j=1,3)
*       enddo
*       write(*,*)'MRF :'
*       do id=1,3
*          write(*,'(20F15.5)') , (mfr(in,id,iib),in=1,(na3-ntrig))
*       enddo
*       write(*,*)'MRF mtot :'
*       do id=1,3
*          write(*,'(20F15.5)') , 
*     &    (mtot(id,3+ntrig+in,iib),in=1,(na3-ntrig))
*       enddo
      write(*,*)'        matrice totale :'
      do in=1,ntot
         write(*,'(5(1X,F8.5))') , (mtot(in,in1,iib),in1=1,ntot)
      enddo
*      write(*,'(20F15.5)')((mtot(k,j),j= 1,3),k= 1,3)
*     inversion de mtot : on part du principe qu'il y a 3 rotas rigides 
*         (nbr de modes flexibles = in1 - 7)
*      write(*,*)'rkpas : ntrig = ',ntrig
*      write(*,*)'        in1 = ',in1
*      write(*,*)'        na2 = ',na2
      write(*,*)'   3 + ntrig    ntot = ',ntot
      write(*,*)'        ninv = ',ninv
      ninv = 3 + na3 
      call invalm(mtot(1,1,iib),ntot,ninv,kerre,1.d-18)
      write(*,*)'        matrice inversee :'
      do i1=1,ntot
         write(*,*)'line :',i1
         do i2=1,ntot
          write(*,*) , mtot(i1,i2,iib)
         enddo
      enddo
*      write(*,*)'        matrice inversee :'
*      do in=1,ntot
*         write(*,'(5(1X,F15.8))') , (mtot(in,in1,iib),in1=1,ntot)
*      enddo
      do in=1,ntot
         do in2=1,ntot
         if (mtot(in,in2,iib).ne.mtot(in,in2,iib)) then
            write(*,*)'mtot(in,in2) = nan !!'
            call exit(1)
         endif
         enddo
      enddo
*      call invalm(mtot(1,1,iib),ntot,ninv,kerre,1.d-10)
*      write(*,*)'        matrice inversee :'
*      do i1=1,ntot
*         do i2=1,ntot
*          write(*,*) , mtot(i1,i2,iib)
*         enddo
*      enddo

*******************************************************************
*       Quadratic velocity vector : coriolis, centrifuge ...
********************3 + ntrig*********************************************
*       translation : 
      if (ntrig.gt.0) then
        call cqvr(Q1,q2,KTROT,NA1,IIB,ind1,na3,ina1) 
      endif
******************************************************************
*       rotation : 
      call cqvth(Q1,q2,KTROT,NA1,IIB,ind1,na3,ina1) 
******************************************************************
*       coordonnees modales : 
      call cqvf(Q1,q2,KTROT,NA1,IIB,ind1,na3,ina1) 
******************************************************************
******************************************************************
*      on implemente les forces d'inertie d'entrainement
*      dues aux blocs non diagonnaux de la matrice de masse ET
*      au "quadratic velocity vector" :
*      * mthr, mrth, mthf, mfth, mrf, mfr
*      * qvr, qvth, qvf
******************************************************************
      ftrans(1) = 0.d0
      ftrans(2) = 0.d0
      ftrans(3) = 0.d0
      id = 1
      do in=1,na3
        i2 = ina1 + in
*       QVF : ajout a ftota --> nn maintenant on le met dans l'eq dyn separement
*        if (.not.itrig(iib,in)) then 
*          ftota(i2,ind1) = ftota(i2,ind1) + qvf(in,iib)
*        endif
*       QVR : 
        if (itrig(iib,in)) then
          ftota(i2,1) = ftota(i2,1) + qvr(id,iib)
          write(*,*)' id = ',id
          write(*,*)' qvr = ',qvr(id,iib)
          ftrans(id) = ftota(i2,1) 
          id = id + 1
        endif
      enddo
      write(*,*)'rkpasin : ftrans : '
      write(*,'(3(1X,F15.10))') ,(ftrans(i),i=1,3)
*     passage du couple exterieur resultant dans le body frame :
      do id=1,3
        rtgex(id) = 0.d0
        do j=1,3
          rtgex(id) = rtgex(id) + rot(j,id,1,iib)*fmomtot(j,1,iib)
        enddo
      enddo
*      write(*,*)'         rtgex : '
*      write(*,'(3(1X,F15.10))') ,(rtgex(i),i=1,3)
*     DEJA inclu dans qvth !!! : terme convectif 
*     terme convectif wjw car j a change :
*      do id=1,3
*        jw(id) = 0.d0
*        do j=1,3
*          jw(id) = jw(id) + 
*     &    (inertie(id,j,iib)+mthth(id,j,iib))*omeg2(j,1,iib)
*        enddo
*      enddo
*      wjw(1) = omeg2(2,1,iib)*jw(3) - omeg2(3,1,iib)*jw(2) 
*      wjw(2) = omeg2(3,1,iib)*jw(1) - omeg2(1,1,iib)*jw(3) 
*      wjw(3) = omeg2(1,1,iib)*jw(2) - omeg2(2,1,iib)*jw(1) 
************************************************************************
*       NEW MTOT : equilibre dynamique a t_n+1
************************************************************************
*       translations :
*       M^{-1}(1,1) * F_R
        id = 1
        write(*,*)'trans :'
        do in=1,na3
          i2 = ina1 + in
          q3(i2,1) = 0.d0
          if (itrig(iib,in)) then
            do j=1,ntrig
              write(*,*)'m^-1 : ',mtot(id,j,iib)
              q3(i2,1) = q3(i2,1) + mtot(id,j,iib)*ftota(i2,1)
            enddo
            write(*,*)'trans mode ',in
            write(*,*)'      q3 = ',q3(i2,1)
*           M^{-1}(1,2) * F_th
            do j=1,3
              j2 = j + ntrig
              q3(i2,1) = q3(i2,1) +
     &         mtot(id,j2,iib)*(rtgex(j) + qvth(j,iib))
*     &         mtot(id,j2,iib)*(rtgex(j) - wjw(j))
            enddo
*           M^{-1}(1,3) * F_f
            in1 = ntrig + 3 + 1
            do inf=1,na3
              i3 = ina1 + inf
              if (.not.itrig(iib,inf)) then
                q3(i2,1) = q3(i2,1) +
     &          mtot(id,in1,iib)*(FTOTA(i3,1)-FAMOR(i3)+qvf(inf,iib))
                in1 = in1 + 1
              endif
            enddo
            id = id + 1
          endif
        enddo
*       rotations :
        do id=1,3 
          id2 = id + ntrig
          omeg3(id,1,iib) = 0.d0
          do j=1,ntrig
*           M^{-1}(2,1) * F_R
            omeg3(id,1,iib) = omeg3(id,1,iib) +
     &                         mtot(id2,j,iib) * ftrans(j)
          enddo
          do j=1,3
            j2 = j + ntrig
*           M^{-1}(2,2) * F_th
            omeg3(id,1,iib) = omeg3(id,1,iib) +
     &      mtot(id2,j2,iib)*(rtgex(j) + qvth(j,iib))
          enddo
*         M^{-1}(2,3) * F_f
          in1 = 3 + ntrig + 1
          do in=1,na3
            i2 = ina1 + in
            if (.not.itrig(iib,in)) then
              omeg3(id,1,iib) = omeg3(id,1,iib) +
     &        mtot(id2,in1,iib)*(FTOTA(i2,1)-FAMOR(i2)+qvf(in,iib))  
              in1 = in1 + 1
            endif
          enddo
        enddo
*       flexible :
        in1 = 3 + ntrig + 1
        do in=1,na3
          i2 = ina1 + in
          if (.not.itrig(iib,in)) then
*           M^{-1}(3,1) * F_R
            do j=1,ntrig
              q3(i2,1) = q3(i2,1) + mtot(in1,j,iib) * ftrans(j)
            enddo
*           M^{-1}(3,2) * F_th
            do j=1,3
              j2 = j + ntrig
              q3(i2,1) = q3(i2,1) +
     &        mtot(in1,j2,iib) * (rtgex(j) + qvth(j,iib))
            enddo
*           M^{-1}(3,3) * F_f
            in2 = 3 + ntrig + 1
            do inf=1,na3
              i3 = ina1 + inf
              if (.not.itrig(iib,inf)) then 
                q3(i2,1) = q3(i2,1) +
     &          mtot(in1,in2,iib)*(FTOTA(i3,1)-FAMOR(i3)+qvf(inf,iib))
                in2 = in2 + 1
              endif
            enddo
            in1 = in1 + 1
          endif
        enddo

******       test : vieux eq dyn pour les ddls flexibles
**        flexible :
*        write(*,*)'old eq dyn. :'
*        do in=1,na3
*          i = ina1 + in
*          unsm = 1.d0 / ( xm(i,1) + dt2*xasm(i,1) - finert(i,1) )
*          q3(i,1) = (ftota(i,1)-famor(i)) * unsm
*        enddo
**        rotation :
*        do id=1,3
*          jw(id) = 0.d0
*          do j=1,3
*            jw(id) = jw(id) + inertie(id,j,iib)*omeg2(j,1,iib)
*          enddo
*        enddo
*        wjw(1) = omeg2(2,1,iib)*jw(3) - omeg2(3,1,iib)*jw(2)
*        wjw(2) = omeg2(3,1,iib)*jw(1) - omeg2(1,1,iib)*jw(3)
*        wjw(3) = omeg2(1,1,iib)*jw(2) - omeg2(2,1,iib)*jw(1)
*        do id = 1,3
*          omeg3(id,1,iib) = 0.d0
*          do j = 1,3
*            omeg3(id,1,iib) = omeg3(id,1,iib) + 
*     &      invinert(id,j,iib)*(rtgex(j) - wjw(j))
*          enddo
*        enddo
******       
*       maj des vitesses (differences centrees) :
        do in=1,na3
          i2 = ina1 + in
          q2(i2,1) = q2(i2,2) + (q3(i2,2) + q3(i2,1))*dt2
        enddo
        do i=1,3
          omeg2(i,1,iib) = omeg2(i,2,iib) +
     &    (omeg3(i,2,iib) + omeg3(i,1,iib))*dt2
        enddo
***********************************************************************
*     FIN boucle sur les ss bases
***********************************************************************
 1    continue
***********************************************************************
*     FIN IF RIGIDE
***********************************************************************
      endif
***********************************************************************
*     Energies
************************************************************************
      IF (RIGIDE) THEN
       DO 8 IIB=1,NSB
          na3  = inmsb(iib)
          ina1 = iorsb(iib) - 1
CMS :     pour l'energie de deformation et cinetique (xec), on a calule pour ttes les ss bases, rots rigides ou non : 
          xec = 0.d0
          edef(iib) = 0.d0
          do in=1,na3
            i2 = in + ina1
            wint(i2,1) = 0.d0
            wext(i2,1) = 0.d0
            if (.not.itrig(iib,in)) then
             edef(iib) = edef(iib) + (xk(i2,1) * (q1(i2,1)**2)/2.d0)
*            estimation des forces :
             FAMO2(I2) = XASM(I2,1)*Q2(I2,1)
             FAMO1(I2) = XASM(I2,1)*Q2(I2,2)
             F1 = FEXA(I2,NPAS,2)
             F2 = FEXA(I2,NPAS,1)
             F1 = FTOTA(I2,2) - F1
             F2 = FTOTA(I2,1) - F2
             F1 = F1 - FAMO2(I2)
             F2 = F2 - FAMO1(I2)
             DQ1 = Q1(I2,1) - Q1(I2,2)
             DWIN = -(F1 + F2)/2D0 * DQ1
*
*             WINT(I2,1) = WINT(I2,2) + DWIN
             wint(i2,1) = (xk(i2,1)*(q1(i2,1)**2))/2.d0
*             wint(i2,1) = wint(i2,2) +
*     &       (xk(i2,1)*(5.d-1*(q1(i2,1)+q1(i2,5))*DQ1))
*            energie cinetique associee au mode i2 :
             wext(i2,1) = (xm(i2,1)*(q2(i2,1)**2))/2.d0
             xec = xec + wext(i2,1)
            endif
          enddo
*         les slots wext et wint sont libres car on appelle pas d2vene.
*         --> on les utilise pour edef et ecin qu'ons stock dans les premiers modes.
*          if (iarota(iib).eq.0) then
*            wint(1,1) = edef(iib)
**           old : energie cinetique :
*            xec = 0.d0
*            do in=1,na3
*              IF (.not. (ITRIG(IIB,IN))) THEN
*                i2 = in + ina1
*                xec = xec + (5.d-1 * xm(i2,1) * (q2(i2,1)**2))
*                xec = xec + wext(i2,1)
*              endif
*            enddo
*            wext(1,1) = xec
*          endif
*          if (lcb) then 
**           energie potentielle magnetique :
*            edef(iib) = edef(iib) - (- ((1.1+rot(3,3,1,ibad))**(-1.d0))
*     &               + (1.d-3*((1.1+rot(3,3,1,ibad))**(-10.d0))))
*          endif
*         write(*,*)'rkpas : edef = ',edef(iib)
CMS :     Rotas rigides ssi il y a une grande rota ds la ss base en question !!
          IF (IAROTA(IIB).EQ.0) GOTO 8
***       Calcul du moment cinetique : 
          DO I=1,3
            PICIN(IIB,I) = 0.D0
            DO J=1,3
              DYN2(J) = 0.D0
              DO K=1,3
                DYN2(J) = DYN2(J) +
     &          ROT(I,K,1,IIB)*(inertie(k,j,iib)+mthth(K,J,IIB))
*     &                    ROT(I,K,1,IIB)*mthth(K,J,IIB)
              ENDDO
              PICIN(NSB,I) = PICIN(IIB,I)+DYN2(J)*OMEG2(J,1,IIB)
            ENDDO
          ENDDO
***       Calcul de l energie cinetique en rotation : 
*          TCIN(IIB) = 0.D0
*         on va rajouter a l'energie cinetique sous forme de vribrations elastiques :
*          TCIN(IIB) = xec
          TCIN(IIB) = 0.d0
*         write(*,*)'xec = ',xec
          DO I=1,3
            DYN2(I) = 0.D0
            DO J=1,3
              DYN2(I) = DYN2(I) + 
     &        (inertie(i,j,iib) + mthth(I,J,IIB))*OMEG2(J,1,IIB)
*     &        (mthth(I,J,IIB))*OMEG2(J,1,IIB)
            ENDDO
            TCIN(IIB) = TCIN(IIB) + (OMEG2(I,1,IIB)*DYN2(I)/2.d0) 
          ENDDO
*          NA3  = INMSB(IIB)
*              = nbr de modes elasiques ds la ss base (incluant les transl. rigides)
*          INA2 = IORSB(IIB) - 1
          XTC = 0.D0
          DO IN = 1,NA3
            IN2 = INA2 + IN
            IF ((ITRIG(IIB,IN))) THEN
*             Energie cinetique translation : 
              DO ID=1,IDIM
                XTC = XTC + 
     &            0.5*MTSB(IIB)*((XPHILB(IIB,1,IN,ID)*Q2(IN2,1))**2.d0) 
              ENDDO
*            ELSE
          write(*,*)'rkpasin : ener cin TR'
              write(*,*)'TR mode in ',in
**             Energie cinetique modes flexibles : 
*              XTC = XTC + (0.5 * (Q2(IN2,2)**2) * XM(IN,1))
            ENDIF 
          ENDDO
          TCIN(IIB) = TCIN(IIB) + XTC
*         energies dues aux termes nn diagonaux de la matrice de masse :
*         dxc/dt^T mrth dxc/dt : 
          xerth = 0.d0
          do id=1,3
            x(id) = 0.d0
            do j=1,3
              x(id) = x(id) + mrth(id,j,iib)*omeg2(j,1,iib)
            enddo
          enddo
          id = 1
          do in=1,na3
            i2 = in + ina1
            if (itrig(iib,in)) then
              xerth = xerth + q2(i2,1)*x(id)
              id = id + 1
            endif
          enddo
*         dxc/dt^T mrf dq_f/dt : 
          xerf = 0.d0
          do id=1,3
            x(id) = 0.d0
            do in=1,na3
              i2 = ina1 + in
              if (.not.itrig(iib,in)) then
                x(id) = x(id) + mfr(in,id,iib)*q2(i2,1)
              endif
            enddo
          enddo
          id = 1
          do in=1,na3
            i2 = in + ina1
            if (itrig(iib,in)) then
              xerf = xerf + q2(i2,1)*x(id)
              id = id + 1
            endif
          enddo
*         dq_f/dt^T mfth W : 
          xefth = 0.d0
          do id=1,3
            x(id) = 0.d0
            do in=1,na3
              i2 = ina1 + in
              if (.not.itrig(iib,in)) then
                x(id) = x(id) + mfth(in,id,iib)*q2(i2,1)
              endif
            enddo
          enddo
          do id=1,3
            xefth = xefth + omeg2(id,1,iib)*x(id)
          enddo
*         chacun des 3 termes non diagonaux calcules precedemment
*         intervient 2 fois dans l'energie cinetique totale (q^t M q) :         
          tcin(iib) = tcin(iib) + 2.d0*xerf + 2.d0*xerth + 2.d0*xefth
*          write(*,*)'Energie cinetique due aux termes nn-diagonaux : ',
*     &    (2.d0*xerf + 2.d0*xerth + 2.d0*xefth)
*
 8     CONTINUE
* fin boucle ss bases
      ENDIF
*
      END

 
 
 
 
