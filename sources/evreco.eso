C EVRECO    SOURCE    CB215821  20/11/25    13:28:21     10792          
      SUBROUTINE EVRECO(LCOUL)
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
C=======================================================================
C   OPTION RECO DE L'OPERATEUR EVOL
C
C.1.EVOLUTION D'UN DDL DANS L'OBJET SOLUTION:
C       MEVOL = EVOL COUL RECO MSOLUT BASE TYPE  PT1 COMP (INSTANTS) ;
C               ----      ----             ----      ----
C
C.2.EVOLUTION DE PLUSIEURS DDL DANS L'OBJET SOLUTION:
C       MEVOL = EVOL COUL RECO MSOLUT BASE TYPE CHP1      (INSTANTS) ;
C
C.3.EVOLUTION DE PLUSIEURS DDL DANS L'OBJET TABLE
C       MEVOL = EVOL COUL RECO TRESU TBASE TYPE PT1 COMP  (INSTANTS) ;
C               ----      ----             ----     ----
C
C         COUL   : COULEUR DE LA (OU DES) COURBE(S)
C         MEVOL  : OBJET DE TYPE EVOLUTION
C         MSOLUT : OBJET SOLUTION
C         TYPE   : MOT CLE:TYPE DE LA VARIABLE (DEPL,VITE,ACCE,CONT..)
C         COMP   : NOM DE LA COMPOSANTE CHOISIE
C        INSTANTS: PROCEDURE FACULTATIVE POUR CHOISIR LES CAS DE SORTIE
C              PROGX :OBJET LISTREEL, LISTE DES TEMPS A SORTIR
C              LECTC :OBJET LISTENTI, LISTE DES CAS A SORTIR
C              RIEN  :L'OBJET EVOLUTION PORTE SUR TOUS LES CAS PRESENTS
C                     DANS LE MSOLUT
C
C         BASE   : BASE ELEMENTAIRE
C                  BASE STRU N
C
C         PT1    : POINT OU MELEME A EXTRAIRE
C         CHP1   : CHPOINT CONTENANT LES POINTS ET DDL (FABRIQUE PAR
C                  EXEMPLE PAR MANU CHPO )
C
C         LES OBJETS PT1,CHP1 SERVENT A REPERER DANS LES CHAMPS
C         CHOISIS, LE(S) POINT(S) QUI INTERESSENT L'EVOLUTION.
C
C   CREATION    : 16/10/85, FARVACQUE
C
C=======================================================================

-INC PPARAM
-INC CCOPTIO
-INC SMSOLUT
-INC SMTABLE
-INC SMBASEM
-INC SMEVOLL
-INC SMELEME
-INC SMLENTI
-INC SMLREEL
-INC SMLMOTS
-INC SMCHPOI
      LOGICAL L0,L1,RECOELA,LTRIG
      SEGMENT NUMOO
       INTEGER NUMO(N),KLIST(N)
       CHARACTER*4 NUDDL(N)
      ENDSEGMENT
      CHARACTER*4 TI1,CHA4
      CHARACTER*8 ITYPE,ITYP1,CTYP,TYPRET,CHARRE
      CHARACTER*72 TI,MCHA,NOMCO,MTIT1
      PARAMETER(NCLE=5)
      CHARACTER*4  MOTIT1(1),MOCLE(NCLE)
      CHARACTER*12 MOCLE2(NCLE),MODYN
      INTEGER      IPTROT(4),ITRIG(3,2)
      DATA MOTIT1/'LEGE'/
      DATA MOCLE/'DEPL','VITE','ACCE','CONT','REAC'/
      DATA MOCLE2/'DEPLACEMENT','VITESSE','ACCELERATION',
     &            'DEPLACEMENT','DEPLACEMENT'/
*
      POINTEUR LCOUL.MLENTI
C
C  LECTURE OPTIONNELLE DU TITRE DE LA SOUS EVOLUTION DE LA COURBE (LEGE) :
      MTIT1=' '
      ITIT1=0
      CALL LIRMOT(MOTIT1,1,ITIT1,0)
      IF(ITIT1.EQ.1) THEN
         CALL LIRCHA(MTIT1,1,IRETOU)
         IF(IERR.NE.0) RETURN
      ENDIF

C=======================================================================
      ICONT=0
      KPSMO=0
      ISOLU=0
      ITABL=0
*     RECOELA: presence de rotas rigides ?
      RECOELA = .false.      
*
*---- type du prochain objet a lire ( TABLE ou SOLUTION )
*
      CALL QUETYP (CTYP,1,IRETOU)
      IF (IERR.NE.0) RETURN
      
c-----------------------------------------------------------------------
c     SYNTAXE AVEC LISTCHPO
c-----------------------------------------------------------------------
      IF (CTYP.EQ.'LISTCHPO') THEN
*
*         LISTCHPO DES COEFFICIENTS DE PROJECTION
*         =======================================
          CALL LIROBJ('LISTCHPO',ILCHP1,1,IRET)
          CALL ACTOBJ('LISTCHPO',ILCHP1,1)
          IF (IERR.NE.0) RETURN
*
*         LISTE DES INSTANTS
*         ==================
          CALL LIROBJ('LISTREEL',ILREE1,1,IRET)
          CALL ACTOBJ('LISTREEL',ILREE1,1)
          IF (IERR.NE.0) RETURN
*
*         TABLE DE MODES
*         ==============
          CALL LIRTAB('BASE_MODALE',ITBAS1,1,IRET)
          IF (IERR.NE.0) RETURN
*
*         NOMBRE DE MODES
*         ===============
          CALL LIRENT(NMOD1,0,IRET)
          IF (IRET.EQ.0) NMOD1=0
*
*         LISTE DES COMPOSANTES
*         =====================
          ILMOT1=0
          CALL LIROBJ('LISTMOTS',ILMOT1,0,IRET)
          IF (IRET.EQ.0) THEN
              CALL LIRCHA(CHA4,0,IRETOU)
              IF (IRETOU.GT.0) THEN
                  JGN=4
                  JGM=1
                  SEGINI,MLMOTS
                  MOTS(1)=CHA4
                  ILMOT1=MLMOTS
              ENDIF
          ENDIF
*
*         GEOMETRIE
*         =========
          CALL LIROBJ('POINT   ',IPO1,0,IRET)
          IF (IRET.NE.0) THEN
             NBNN=1
             NBELEM=1
             NBSOUS=0
             NBREF=0
             SEGINI,MELEME
             ITYPEL=1
             NUM(1,1)=IPO1
             IMA1=MELEME
          ELSE
             CALL LIROBJ('MAILLAGE',IMA1,1,IRET)
             CALL ACTOBJ('MAILLAGE',IMA1,1)
          ENDIF
*
*         CALCUL DE LA RECOMBINAISON MODALE
*         =================================
          CALL RECLCH(ILCHP1,ITBAS1,NMOD1,ILCHP2)
          IF (IERR.NE.0) RETURN
*
*         CREATION DE L'OBJET EVOLUTION
*         =============================
          CALL CREVLC(ILREE1,ILCHP2,IMA1,ILMOT1,LCOUL,MTIT1,IEVOL1)
          IF (IERR.NE.0) RETURN
          CALL ACTOBJ('EVOLUTIO',IEVOL1,1)
          CALL ECROBJ('EVOLUTIO',IEVOL1)
*
          RETURN

      ENDIF

      
c-----------------------------------------------------------------------
c     SYNTAXE AVEC TABLE ou SOLUTION
c-----------------------------------------------------------------------
      SEGACT,LCOUL
      ICOUL=LCOUL.LECT(1)
      SEGDES,LCOUL

*
* --- on lit le type du champ a traiter et le nom de la composante
cbp  -deb-
c      CALL LIRCHA(MCHA,1,IRETOU)
      CALL LIRMOT(MOCLE,NCLE,ICLE,1)
      IF(IERR.NE.0) RETURN
      MCHA=' '
      MCHA(1:4)=MOCLE(ICLE)
      LCHALU=4
      MODYN=MOCLE2(ICLE)
cbp  -fin-
      IF (MCHA.EQ.'CONT') ICONT = 1
      IF (MCHA.EQ.'REAC') ICONT = 2
cbp      LCHALU=IRETOU
      CALL LIRCHA(NOMCO,0,IRETOU)
      IF(IRETOU.EQ.0) NOMCO=' '
*
* --- on recupere le point ou le maillage ou le chpoint
      CALL LIROBJ('POINT   ',IRET,0,IRETOU)
      IF (IRETOU.EQ.0) THEN
         CALL LIROBJ('MAILLAGE',IRET,0,IRETOU)
         IF (IRETOU.EQ.0) THEN
            CALL LIROBJ('CHPOINT ',IRET,0,IRETOU)
            IF (IRETOU.EQ.0) THEN
*              on ne trouve pas le support qui contient les points
               CALL ERREUR(248)
               RETURN
            ELSE
               ITYPE='CHPOINT'
               CALL ACTOBJ('CHPOINT ',IRET,1)
            ENDIF
         ELSE
            ITYPE='MAILLAGE'
            CALL ACTOBJ('MAILLAGE',IRET,1)
         ENDIF
      ELSE
        ITYPE='POINT'
      ENDIF
      iptu = iret
      
*--------------------------------------------
*---cas d'un objet de type TABLE ------------
*--------------------------------------------

*------ sous cas d'une table PASAPAS --------

        call lirtab('PASAPAS',ITAP,0,iretou)
        if (iretou.gt.0) then
          call lirobj('MMODEL  ', IPMODE,1,iretou)
          call actobj('MMODEL  ', IPMODE,1)
          if (ierr.ne.0) return
          
          CALL LIROBJ('MCHAML  ',IPIN,1,IRETOU)
          CALL ACTOBJ('MCHAML  ',IPIN,1)
          if (ierr.ne.0) return
          CALL REDUAF(IPIN,IPMODE,IPCHA1,0,IR,KER)
          IF(IR   .NE. 1) CALL ERREUR(KER)
          IF(IERR .NE. 0) RETURN
          
          if (iretou.gt.0) call EVREC6(itap,ipmode,ipcha1,mcha,nomco,
     &itype,iptu,ipevo)
           if (ierr.ne.0) return
          if (ipevo.gt.0) then
            call actOBJ('EVOLUTION',ipevo,1)
            call ECROBJ('EVOLUTION',ipevo)
          endif
          return
        endif

*------ sous cas d'une table DYNE --------

      IF (CTYP(1:5).EQ.'TABLE') THEN
        ITABL = 1
        CALL LIRTAB ('RESULTAT_DYNE',ISTA,1,IRETOU)
        IF (IERR.NE.0) RETURN
        CALL LIRTAB ('BASE_MODALE',ISBM,0,IRETOU)
        IF (IRETOU.EQ.0) THEN
           CALL LIRTAB ('ENSEMBLE_DE_BASES',ISEB,1,IRETOU)
           IF (IERR.NE.0) RETURN
*          On cherche la sous base a laquelle appartient le point
*          de recombinaison:
           IT = 0
 56        CONTINUE
           IT = IT + 1
           TYPRET = ' '
           CALL ACCTAB (ISEB,'ENTIER',IT,X0,' ',L0,IRET0,
     &                         TYPRET,I1,X1,CHARRE,L1,ISBM)
           IF (ISBM.NE.0 .AND. TYPRET.EQ.'TABLE   ') THEN
              CALL ACCTAB (ISBM,'MOT',I0,X0,'MODES',L0,IRET0,
     &                        'TABLE',I1,X1,' ',L1,ISTB)
              CALL ACCTAB (ISTB,'MOT',I0,X0,'MAILLAGE',L0,IRET0,
     &                        'MAILLAGE',I1,X1,' ',L1,IMAIL)
              CALL EXTR12(IMAIL,IRET,IRE12)
*              WRITE(*,*)'EVRECO: IRE12 = ',IRE12
c             => avec un ENSEMBLE_DE_BASES seule la syntaxe avec 1 point
              IF (IRE12.EQ.0) GOTO 56
*              IF (IRE12.NE.0) WRITE(*,*)
*     &          'EVRECO: pt reco ',IRET,' trouve dans la ss base: ',IT
              TYPRET = ' '
              CALL ACCTAB (ISBM,'MOT',I0,X0,'PSEUDO_MODES',L0,IRET0,
     &                         TYPRET,I1,X1,CHARRE,L1,ITPS)
              IF (ITPS.NE.0 .AND. TYPRET.EQ.'TABLE   ') KPSMO = 1
           ELSE
              RETURN
           ENDIF
        ELSE
           CALL ACCTAB (ISBM,'MOT',I0,X0,'MODES',L0,IRET0,
     &                     'TABLE',I1,X1,' ',L1,ISTB)
           TYPRET = ' '
           CALL ACCTAB (ISBM,'MOT',I0,X0,'PSEUDO_MODES',L0,IRET0,
     &                      TYPRET,I1,X1,CHARRE,L1,ITPS)
           IF (ITPS.NE.0 .AND. TYPRET.EQ.'TABLE   ') KPSMO = 1
        ENDIF
      ENDIF
      
*--------------------------------------------
*---cas d'un objet de type SOLUTION ---------
*--------------------------------------------

      IF  (CTYP(1:8).EQ.'SOLUTION') THEN
        CALL LIROBJ('SOLUTION',KSOLU,1,IRETOU)
        IF(IERR.NE.0) RETURN
        ISOLU = 1
        MSOLUT=KSOLU
C       lecture de la base elementaire
        CALL LIRBAS(1,IBOBAS,IBOSEM)
        MSOBAS=IBOBAS
C        MBASEM=IBOSEM
        IF(IERR.NE.0) RETURN
      ENDIF
      
*----------------------------------------------------------
*-------  fin des cas TABLE/SOLUTION 
*         et sous cas TABLE PASAPAS / TABLE DYNE  ---------
*----------------------------------------------------------


C---- lecture du chargement pour les pseudo-modes
      KCHAR = 0
      CALL LIROBJ('CHARGEME',KCHAR,0,IRETOU)
      IF(IRETOU .EQ. 1)CALL ACTOBJ('CHARGEME',KCHAR,1)
      
C---- lecture des instants
      IPX=0
      ITOUS=0
      ILX=0
      CALL LIROBJ('LISTREEL',IPX,0,IRETOU)
      IF(IRETOU.EQ.0) CALL LIROBJ('LISTENTI',ILX,0,IRETOU)
      IF(IRETOU.EQ.0) ITOUS=1
*      WRITE(*,*)'EVRECO: lecture d une listreel de PDTs de sortie',
*     &                   ITOUS
C----------------------------------------------------
c     remplissage des tableaux de NUMOO
C----------------------------------------------------
c     sortie : NUMOO.NUMO(i) = numero de noeud du i^eme ddl a traiter
c              NUMOO.NUDDL(i)= composante du i^eme ddl a traiter
*      WRITE(*,*)'EVRECO: appel UMO'
      CALL EVNUMO(ITYPE,IRET,NOMCO,IBOO)
      NUMOO=IBOO
      IF(IERR.NE.0) RETURN
      
      
*--------------------------------------------
*---cas d'un objet de type SOLUTION ---------
*--------------------------------------------
      IF (ISOLU.EQ.1) THEN
      
         SEGACT MSOLUT
         IF (MCHA.EQ.'CONT') MCHA = 'DEPL'
         MOTERR(1:8)=ITYSOL
         CALL CHRCHA(MCHA,MOTERR(1:8),ICHA,ISOLIT)
         IF(ICHA.EQ.0) THEN
*           erreur dans le type du champ
            MOTERR(1:8)='SOLUTION'
            MOTERR(9:26)=ITYSOL
            MOTERR(30:38)=MCHA
            CALL ERREUR(235)
            RETURN
         ENDIF
         MSOLEN=MSOLIS(ICHA)
         IF(MSOLEN.EQ.0) THEN
*           ce type de champ est vide dans le MSOLUT
            MOTERR(1:8)='SOLUTION'
            MOTERR(9:26)=ITYSOL
            MOTERR(30:38)=MCHA
            CALL ERREUR(235)
            RETURN
         ENDIF
         IF (ITYSOL.NE.'DYNAMIQU') THEN
*           option non disponible
            MOTERR(1:8)='SOLUTION'
            MOTERR(9:16)=ITYSOL
            CALL ERREUR(131)
            RETURN
         ENDIF
         IF (MSOLIT(ICHA).NE.2) THEN
*           la sortie porte sur des CHAMELEM
*           option non disponible
            CALL ERREUR(19 )
            RETURN
         ENDIF
         IBOS=MSOLUT
*        verification des instants de sortie
*        dans IPX le LISTREEL a mettre dans IPROGX
*        dans ILEX le LISTENTI qui contient les numeros des champs
         CALL VERIDY(IBOS,IPX,ICHA,ITOUS,ILEX,ITYP1)
         IF(IERR.NE.0) RETURN
         MSOLUT=IBOS
*
         IBOBAS=MSOBAS
         IBOO=NUMOO
         CALL EVOL2(IBOO,ILEX,IBOBAS,ICONT)
         IF(IERR.NE.0) RETURN
         MSOBAS=IBOBAS
         NUMOO=IBOO
         MLENTI=ILEX
         SEGSUP MLENTI
*
*        prise en compte des pseudo-modes
*
         SEGACT MSOBAS
         IMODE = IBSTRM(2)
         ILIAI = IBSTRM(4)
         KPSMO = IBSTRM(5)
         SEGDES MSOBAS
         IF (KPSMO.NE.0) THEN
            IF (ILIAI.NE.0) THEN
               MSOLUT = KSOLU
               SEGACT MSOLUT
               MOTERR(1:8) = ITYSOL
               MCHA = 'LIAI'
               CALL CHRCHA(MCHA,MOTERR(1:8),ICHA,ISOLIT)
               IF (ICHA.EQ.0) THEN
                  MOTERR(1:8)='SOLUTION'
                  MOTERR(9:26)=ITYSOL
                  MOTERR(30:38)=MCHA
                  CALL ERREUR(235)
                  RETURN
               ENDIF
               MSOLEN = MSOLIS(ICHA)
               IF (MSOLEN.EQ.0) THEN
                  MOTERR(1:8)='SOLUTION'
                  MOTERR(9:26)=ITYSOL
                  MOTERR(30:38)=MCHA
                  CALL ERREUR(235)
                  RETURN
               ENDIF
               SEGDES MSOLUT
               ITOU2 = 0
               IBOS = KSOLU
               CALL VERIDY(IBOS,IPX,ICHA,ITOU2,ILEX2,ITYP1)
               IF (IERR.NE.0) RETURN
            ELSE
               ILEX2 = 0
            ENDIF
            IBOO = NUMOO
            CALL PSEVO1(IMODE,KPSMO,IBOO,IPX,ILEX2,KCHAR,ICONT)
            NUMOO = IBOO
         ENDIF
         
      ENDIF
            
*-------------------------------------------------
*---cas d'un objet de type TABLE DYNE ------------
*-------------------------------------------------

      IF (ITABL.EQ.1) THEN
*          Initialisation rotas rigides:       
           ICDR = 0
           IPTROT(1) = 0
           IPTROT(2) = 0
           IPTROT(3) = 0
           IPTROT(4) = 0 
           
*
cbp      QUEL TYPE DE SORTIE DE LA TABLE DYNE (CHPOINT OU LISTREEEL)?

* ------ sous cas d'un LISTREEL 
*        dans la table . 'DEPLACEMENT' . ptalfa --------

c        existe-t-il le LISTREEL dans la table . 'DEPLACEMENT' ?
         TYPRET=' '
         CALL ACCTAB (ISTA ,'MOT',I0,X0,MODYN,L0,IRET0,
     &                      TYPRET,I1,X1,' ',L1,IDYN1) 
     
         IF(TYPRET.EQ.'TABLE'.AND.IDYN1.NE.0) THEN
         
*          sortie : ILEN1 = liste des deformees modales [phi_j]
*                   ILEN2 = liste des points reperes
*           WRITE(*,*)'EVRECO: appel CHCHA2'
           CALL CHCHA2(ISTB,ILEN1,ILEN2,ICONT,ICDR,
     &                  IPTROT,IDEFROT,RECOELA,LTRIG,ITRIG,ISBM)
*           WRITE(*,*)'EVRECO: RECOELA = ',RECOELA
           IF(IERR.NE.0) RETURN 
           
c          ILEN3 =liste des LISTREEL des alpha_j(t)
           MLENT2=ILEN2
           SEGACT,MLENT2
           JG=MLENT2.LECT(/1)
           SEGINI,MLENT3
           ILEN3=MLENT3
           DO I=1,JG
             IPREP2=MLENT2.LECT(I)
             CALL ACCTAB (IDYN1,'POINT',I0,X0,' ',L0,IPREP2,
     &                          'LISTREEL',I1,X1,' ',L1,IRET1)     
             MLENT3.LECT(I)=IRET1
           ENDDO
claisse actif            SEGDES,MLENT2,MLENT3
           
c          creation d'une listenti des indices a sortir pour l'evolution
*           WRITE(*,*)'VERIT3: listreel des PDTs de sortie: IPX = ',IPX
           CALL VERIT3(ISTA,IPX,ITOUS,ILEX,ITYP1)
           
*          Travail effectif (= Recombinaison modale)
*          sortie : NUMOO.KLIST(k) = pointeur vers le k^ieme listreel resultat
           IBOO=NUMOO
           CALL EVOL23(IBOO,ILEX,ILEN1,ILEN3)
           SEGDES,MLENT2,MLENT3
           GOTO 2001
           
         ENDIF         
         
* ------ sous cas de CHPOINTS dans la table . I . 'DEPL' --------

         ICHA =0
*        on prend l'indice 1 de la table (IRET1 = table du pas 1)
         CALL ACCTAB (ISTA ,'ENTIER',1,X0,' ',L0,IRET0,
     &                       'TABLE',I1,X1,' ',L1,IRET1)     
c        recherche de l'indice MCHA dans la table du pas 1
         IF (ICONT.EQ.1) MCHA = 'DEPL'
         IF (ICONT.EQ.2) MCHA = 'DEPL'
         IBOBO=IRET1
         CALL CHTCHA (MCHA,LCHALU,IBOBO,ICHA)
         IF (ICHA.EQ.0) THEN
*           erreur dans le type du champ :
cbp            MOTERR(1:8)= MCHA(1:8)
            MOTERR(1:8)='TABLE   '
            MOTERR(9:26)='RESULTAT_DYNE   '
            MOTERR(30:38)=MCHA
            CALL ERREUR(235)
c Dans l'objet solution de type DEPL on ne trouve pas la liste des DEPL
            RETURN
         ENDIF
         
*        verification des instants de sortie
*        entree : IPX = LISTREEL des instants (a mettre dans IPROGX)
*                 ITOUS = 1 si IPX non fourni (on recherche alors tous 
*                         les instants), =0 sinon
*        sortie : ILEX = LISTENTI des pointeurs vers les champs 
*                        aux temps souhaites { alpha(t_1) ... }
         CALL VERITA(ISTA,IPX,ICHA,ITOUS,ILEX,ITYP1)
         IF (IERR.NE.0) RETURN
*         
*        sortie : ILEN1 = liste des deformees modales [phi_j]
*                 ILEN2 = liste des points reperes
         CALL CHCHA2(ISTB,ILEN1,ILEN2,ICONT,ICDR,
     &                  IPTROT,IDEFROT,RECOELA,LTRIG,ITRIG,ISBM)
*         DO I=1,4
*           WRITE(*,*)'EVRECO: IPTROT(',I,') = ',IPTROT(I)
*         ENDDO
*         WRITE(*,*)'EVRECO: ICDR = ',ICDR
         IF(IERR.NE.0) RETURN
*         
*        Travail effectif (= Recombinaison modale)
*        sortie : NUMOO.KLIST(k) = pointeur vers le k^ieme listreel resultat
         IBOO=NUMOO
         CALL EVOL22 (IBOO,ILEX,ILEN1,ILEN2)
         IF(IERR.NE.0) RETURN
         NUMOO=IBOO
         
         
* ------ partie commune aux 2 sous cas --------
 2001    CONTINUE
*        On libere l emplacement MLENT3 dans l include SMLENTI:
*         (On a a plus besoin des listreel des alpha_i(t))
*        + On va utiliser l'emplcement MLENT3 dans evorig2.
*
*       prise en compte de la rotation des corps rigides
*        
         IF (MCHA(1:4).EQ.'DEPL') ITYP = 0
         IF (MCHA(1:4).EQ.'VITE') ITYP = 1
         IF (MCHA(1:4).EQ.'ACCE') ITYP = -1
*  On regarde si on a une base de corps rigide
         CALL VERRIG(ISTB,IROT,ICDR,ILEN1,ILEN2,IDEFO)
         IF (IROT.NE.0) THEN
*            IBOO = NUMOO
*           Recombinaison des deplacements
* old:      CALL EVORIG(IROT,ICDR,IBOO,ILEX,0,0,0,IDEFO)
*            WRITE(*,*)'Evreco: appel evorig2'
            CALL EVORIG2(ISTA,IBOO,ILEX,ILEN1,ILEN2,ITYP,
     &              ICDR,IPTROT,IDEFROT,RECOELA,LTRIG,ITRIG)
*            NUMOO = IBOO
         ENDIF

         MLENTI=ILEN1
         SEGSUP MLENTI
         MLENTI=ILEN2
         SEGSUP MLENTI
         MLENTI=ILEX
         SEGSUP MLENTI
*
*        prise en compte des pseudo-modes
*
         IF (KPSMO.EQ.1) THEN
            IF (KCHAR.NE.0) THEN
               IBOO = NUMOO
               CALL PSEVRC(ICONT,ITPS,ISTB,IBOO,IPX,KCHAR)
               NUMOO = IBOO
            ELSE
               CALL ERREUR(430)
            ENDIF
         ENDIF
*     fin IF (ITABL.EQ.1):
      ENDIF

*--------------------------------------------
*   initialisation du MEVOLL resultat
*--------------------------------------------
* 
      IF (ICONT.EQ.1) MCHA='CONT'
      IF (ICONT.EQ.2) MCHA='REAC'
      N=NUMO(/1)
      SEGINI MEVOLL
      ITYEVO='REEL'
      TI(1:72)=TITREE
      IEVTEX=TI
      DO 2080 I=1,N
         SEGINI KEVOLL
         TYPX='LISTREEL'
         TYPY='LISTREEL'
         IPROGX=IPX
         IPROGY=KLIST(I)
         NOMEVX=ITYP1
         NOMEVY(1:4)=MCHA
         WRITE (NOMEVY(5:8),FMT='(I4)') NUMO(I)
         NOMEVY(9:12)=NUDDL(I)
c          KEVTEX=TI
         IF(ITIT1.EQ.0) MTIT1(1:12)=NOMEVY(1:12)
         KEVTEX=MTIT1
         NUMEVY='REEL'
         NUMEVX=ICOUL
         SEGDES KEVOLL
         IEVOLL(I)=KEVOLL
 2080 CONTINUE
      SEGDES MEVOLL
      SEGSUP NUMOO
      CALL ACTOBJ('EVOLUTIO',MEVOLL,1)
      CALL ECROBJ('EVOLUTIO',MEVOLL)
*
      END

 
 
 
 
