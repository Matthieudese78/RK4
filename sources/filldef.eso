      SUBROUTINE filldef(itbas,ib,ktphi,ktrot,ktkam,npts)

      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
************************************************************************
*                             ACCDEF
************************************************************************
* FONCTION:
* ---------
* Compte les points de composantes 'UX' 'UY' 'UZ'
*   de toutes les deformees modales d'une base / ss base
*   (via ctdef) et prend le maximal. 
************************************************************************
-INC PPARAM
* pour avoir ierr : include ccoptio
-INC CCOPTIO
-INC CCREEL
-INC SMCHAML
-INC SMELEME
-INC SMMODEL
-INC SMCOORD

      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EDEF(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XMNO(NA2,NSB),QVTH(3,NSB),QVR(3,NSB),QVF(NA2,NSB)
         REAL*8 MRTH(3,3,NSB),MTHTH(3,3,NSB)
         REAL*8 MFTH(NA2,3,NSB),MFR(NA2,3,NSB),MTOT(NTOT,NTOT,NSB)
         REAL*8 SKL(3,3,NA2,NA2,NSB),IKL(3,3,NA2,NSB)
         REAL*8 XMPOI(NPDEF,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT

      SEGMENT,MTKAM
         REAL*8 XK(NA1,NB1K),XASM(NA1,NB1C),XM(NA1,NB1M)
         REAL*8 XOPER(NB1,NB1,NOPER)
      ENDSEGMENT

      SEGMENT,MTPHI
         INTEGER IBASB(NPLB),IPLSB(NPLB),INMSB(NSB),IORSB(NSB)
         INTEGER IAROTA(NSB)
         REAL*8 XPHILB(NSB,NPLSB,NA2,IDIMB)
      ENDSEGMENT

      logical l0,l1,lcoo,lnortot,lnorcomp
      character*8  typret,charre,monmot,cmot,morigi
      integer lpoi(npts)
*
      mtrot = ktrot
      mtkam = ktkam
      mtphi = ktphi
*
      na1 = xm(/1)
      na2 = itrig(/2)
      nsb = itrig(/1)
      npdef = xtphi(/2)
*
*     write(*,*)'filldef : START'
*     write(*,*)'filldef : npdef = ',npdef
*     write(*,*)'          nsb = ',nsb
*     write(*,*)'          na1 = ',na1
*
      lcoo = .false.
      lnortot = .true.
      lnorcomp = .false.
*     initialisation list :
      do ip=1,npdef
        lpoi(ip) = 0
      enddo
*

*     write(*,*)'filldef : xm'
*     do in = 1,na1
*      write(*,'(1X,F8.5)') , (xm(in,1))
*     enddo
*     write(*,*)'filldef : xcoophi'
*     do ip = 1,npdef
*      write(*,'(3(1X,F8.5))') , (xcoophi(id,ip,ib),id=1,3)
*     enddo
*     write(*,*)'filldef : xtphi'
*     do ip = 1,npdef
*      do in=1,na2
*      write(*,'(3(1X,F8.5))') , (xtphi(id,ip,in,ib),id=1,3)
*      enddo
*     enddo
*
*     write(*,*)'     itbas = ',itbas
*     pour utiliser itrig, on est oblige de compter 
*     les modes elastiques de la base / ss base ib quand on la parse :
      inel = 0
      in = 0
*     on boucle sur le nbr maxi de modes / ss base : na2
 1    continue
        in = in + 1
*       valeur max des composantes :
        xcmax = 0.d0
*       acquisition du mode :
        typret = ' '
*       write(*,*)'1er acctab :'
        call acctab(itbas,'ENTIER',in,x0,' ',l0,ip0,
     &              typret,i1,x1,charre,l1,imod)
        write(*,*)'imod = ',imod
        if (ierr.ne.0) return
*       write(*,*)'acquisition mode reussie'
        if ((imod.ne.0).and.(typret.eq.'TABLE   ')) then
          write(*,*)'typret = table'
*         on saute les rotations rigides :
          morigi = ' '
          call acctab(imod,'MOT',i0,x0,'ROTATION_RIGIDE',l0,ip0,
     &                      morigi,i1,x1,cmot,l1,ip1)
          if (ierr.ne.0) return
          if (morigi(1:3).eq.'MOT') then
            if (cmot(1:4).eq.'VRAI') then 
              write(*,*)'filldef : rota rigide sautee'
              goto 1
            endif
          endif
          inel = inel + 1
*         write(*,*)'mode elastique : ',inel
*         on prend la deformee modale :
          call acctab(imod,'MOT',i0,x0,'DEFORMEE_MODALE',l0,ip0,
     &                        'CHPOINT',i1,x1,' ',l1,icdm)
          if (ierr.ne.0) return
*         write(*,*)'acquisistion def modale : ',icdm
          if (.not.lcoo) then
            lcoo = .true.
*           write(*,*)'call findpo'
            call findpo(icdm,lpoi,npdef)
*           write(*,*)'end findpo'
*           write(*,*)'liste de pts : '
*           write(*,*)'idim = ',idim
*           donne lpoi : liste des noeuds de la def modale comportant une composante 'UX'
            do ip=1,npdef
*             write(*,*)'point : ',lpoi(ip)
              ipoin = lpoi(ip)
              if (.not.(ipoin.eq.0)) then
                do id=1,idim
                  xcoophi(id,ip,ib)=xcoor((ipoin-1)*(idim+1)+id)
*                 write(*,*)'coor = ',xcoophi(id,ip,ib)
                enddo
              endif
            enddo
          endif
*         on saute les translations rigides : itrig vient d'etre remplie dans dyne26
          if (itrig(ib,inel)) then 
            write(*,*)'filldef : translation rigide sautee'
            goto 1
          endif
*         sinon on rempli xtphi :
*         write(*,*)'boucle sur xtphi'
          xnortot = 0.d0
          do ip=1,npdef
            ipoin = lpoi(ip)
*           write(*,*)'ipoin = ',ipoin
            if (.not.(ipoin.eq.0)) then
              call extra9(icdm,ipoin,'UX',0,.false.,xval,iret)
              xtphi(1,ip,inel,ib) = xval
*             MAJ max des composantes :
              xcmax = max(xcmax,dabs(xval))
*             write(*,*)'ux = ',xval
              call extra9(icdm,ipoin,'UY',0,.false.,xval,iret)
              xtphi(2,ip,inel,ib) = xval
*             MAJ max des composantes :
              xcmax = max(xcmax,dabs(xval))
*             write(*,*)'uy = ',xval
              call extra9(icdm,ipoin,'UZ',0,.false.,xval,iret)
              xtphi(3,ip,inel,ib) = xval
*             MAJ max des composantes :
              xcmax = max(xcmax,dabs(xval))
*             write(*,*)'uz = ',xval
              xnortot = xnortot + ((xtphi(1,ip,inel,ib)**2) +
     &                             (xtphi(2,ip,inel,ib)**2) +
     &                             (xtphi(3,ip,inel,ib)**2))
            endif
          enddo
          xnortot = dsqrt(xnortot)
          if (lnortot) then
            xalpha = xnortot
          endif
          if (lnorcomp) then
            xalpha = xcmax
          endif
          write(*,*)'xalpha = ',xalpha
          write(*,*)'xnortot = ',xnortot
          write(*,*)'xcmax = ',xcmax
*         on rempli xtphin avec la base modale normee / comp max : 
*                    ou / norme euclidienne du mode.
          ina1 = iorsb(ib) - 1
          i2 = ina1 + inel
          if (xalpha.gt.1.d-4) then
*           normalisation de la masse modale :
            xmno(inel,ib) = xm(i2,1)/(xalpha**2)
*           normalisation des modes :
            xnortot = 0.d0
            do ip=1,npdef
*             on norme par rapport a la plus grande composante :
              xtphi(1,ip,inel,ib) = xtphi(1,ip,inel,ib)/xcmax
              xtphi(2,ip,inel,ib) = xtphi(2,ip,inel,ib)/xcmax
              xtphi(3,ip,inel,ib) = xtphi(3,ip,inel,ib)/xcmax
*             on recalcule la norme si norm largest comp : 
              xnortot = xnortot + ((xtphi(1,ip,inel,ib)**2) +
     &                             (xtphi(2,ip,inel,ib)**2) +
     &                             (xtphi(3,ip,inel,ib)**2))
            enddo
            xnortot=dsqrt(xnortot)
*
            write(*,*)'  masse totale solide ib ',ib
            write(*,*)'                   ',mtsb(ib)
            write(*,*)'  masse modale d origine : xm inel ',inel
            write(*,*)'                   ',xm(i2,1)
            if (lnortot) then
              write(*,*)'  eucl. norm normalization : xmno inel ',inel
              write(*,*)'                    ',xmno(inel,ib)
              write(*,*)'  npdef X xmno inel',float(npdef)*xmno(inel,ib)
*             si normalisation / norme du mode : xmno = mtot / npdef
*               = massse a attribuer a chacun des points.
              do ip=1,npdef
                xmpoi(ip,inel,ib) = xmno(inel,ib)
              enddo
            endif
*
            if (lnorcomp) then
              write(*,*)'  largest comp normalization : xmno inel ',inel
              write(*,*)'                     ',xmno(inel,ib)
              write(*,*)'  4 X xmno inel ',4.d0*xmno(inel,ib)
*             largest comp : masses ponctuelles individuelles : 
              do ip=1,npdef
                xnor = dsqrt((xtphi(1,ip,inel,ib)**2) + 
     &                       (xtphi(2,ip,inel,ib)**2) +
     &                       (xtphi(3,ip,inel,ib)**2))
                xmpoi(ip,inel,ib) = xmno(inel,ib) * (xnor/xnortot)
              enddo
            endif
*           warning : 
            if (xmno(inel,ib).gt.(1.05*mtsb(ib))) then
              write(*,*)'filldef : '
              write(*,*)'masse mode norme > 1.05*masse tot ss base!!!'
              call exit(1)
            endif
          else 
*           pour une torsion, tout est nul 
            xmno(inel,ib) = 0.d0
            do ip = 1,npdef
              do id=1,3
                xtphi(id,ip,inel,ib) = 0.d0
              enddo
              xmpoi(ip,inel,ib) = 0.d0
            enddo
          endif
*           
          goto 1
* si typret n'est pas table, la boucle s'arrete
        endif
*       write(*,*)'filldef : pause'
*       call exit(1)
*
      END

 
 
 
