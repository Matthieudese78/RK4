      SUBROUTINE filldef(itbas,ib,ktphi,ktrot,ktkam,npts)

      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
************************************************************************
*                             ACCDEF
************************************************************************
* FONCTION:
* ---------
* Compte les points de composantes 'UX' 'UY' 'UZ'
*   de toutes les deformees modales d'une base / ss base
*   (via ctdef) et prend le maximal. 
************************************************************************
-INC PPARAM
* pour avoir ierr : include ccoptio
-INC CCOPTIO
-INC CCREEL
-INC SMCHAML
-INC SMELEME
-INC SMMODEL
-INC SMCOORD

      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EPOT(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XTPHIN(3,NPDEF,NA2,NSB),XMNO(NA2,NSB)
         REAL*8 XMPOI(NPDEF,NA2,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT

      SEGMENT,MTKAM
         REAL*8 XK(NA1,NB1K),XASM(NA1,NB1C),XM(NA1,NB1M)
         REAL*8 XOPER(NB1,NB1,NOPER)
      ENDSEGMENT

      SEGMENT,MTPHI
         INTEGER IBASB(NPLB),IPLSB(NPLB),INMSB(NSB),IORSB(NSB)
         INTEGER IAROTA(NSB)
         REAL*8 XPHILB(NSB,NPLSB,NA2,IDIMB)
      ENDSEGMENT

      logical l0,l1,lcoo
      character*8  typret,charre,monmot,cmot,morigi
      integer lpoi(npts)
*
      mtrot = ktrot
      mtkam = ktkam
      mtphi = ktphi
*
      na1 = xm(/1)
      na2 = itrig(/2)
      nsb = itrig(/1)
      npdef = xtphi(/2)
*
      write(*,*)'filldef : START'
      write(*,*)'filldef : npdef = ',npdef
      write(*,*)'          nsb = ',nsb
      write(*,*)'          na1 = ',na1
*
      lcoo = .false.
*     initialisation list :
      do ip=1,npdef
        lpoi(ip) = 0
      enddo
*

*     write(*,*)'filldef : xm'
*     do in = 1,na1
*      write(*,'(1X,F8.5)') , (xm(in,1))
*     enddo
*     write(*,*)'filldef : xcoophi'
*     do ip = 1,npdef
*      write(*,'(3(1X,F8.5))') , (xcoophi(id,ip,ib),id=1,3)
*     enddo
*     write(*,*)'filldef : xtphi'
*     do ip = 1,npdef
*      do in=1,na2
*      write(*,'(3(1X,F8.5))') , (xtphi(id,ip,in,ib),id=1,3)
*      enddo
*     enddo
*
      write(*,*)'     itbas = ',itbas
*     pour utiliser itrig, on est oblige de compter 
*     les modes elastiques de la base / ss base ib quand on la parse :
      inel = 0
      in = 0
*     on boucle sur le nbr maxi de modes / ss base : na2
 1    continue
        in = in + 1
*       valeur max des composantes :
        xcmax = 0.d0
*       acquisition du mode :
        typret = ' '
        write(*,*)'1er acctab :'
        call acctab(itbas,'ENTIER',in,x0,' ',l0,ip0,
     &              typret,i1,x1,charre,l1,imod)
        write(*,*)'imod = ',imod
        if (ierr.ne.0) return
        write(*,*)'acquisition mode reussie'
        if ((imod.ne.0).and.(typret.eq.'TABLE   ')) then
          write(*,*)'typret = table'
*         on saute les rotations rigides :
          morigi = ' '
          call acctab(imod,'MOT',i0,x0,'ROTATION_RIGIDE',l0,ip0,
     &                      morigi,i1,x1,cmot,l1,ip1)
          if (ierr.ne.0) return
          if (morigi(1:3).eq.'MOT') then
            if (cmot(1:4).eq.'VRAI') then 
              write(*,*)'filldef : rota rigide sautee'
              goto 1
            endif
          endif
          inel = inel + 1
          write(*,*)'mode elastique : ',inel
*         on prend la deformee modale :
          call acctab(imod,'MOT',i0,x0,'DEFORMEE_MODALE',l0,ip0,
     &                        'CHPOINT',i1,x1,' ',l1,icdm)
          if (ierr.ne.0) return
          write(*,*)'acquisistion def modale : ',icdm
          if (.not.lcoo) then
            lcoo = .true.
            write(*,*)'call findpo'
            call findpo(icdm,lpoi,npdef)
            write(*,*)'end findpo'
            write(*,*)'liste de pts : '
            write(*,*)'idim = ',idim
*           donne lpoi : liste des noeuds de la def modale comportant une composante 'UX'
            do ip=1,npdef
              write(*,*)'point : ',lpoi(ip)
              ipoin = lpoi(ip)
              if (.not.(ipoin.eq.0)) then
                do id=1,idim
                  xcoophi(id,ip,ib)=xcoor((ipoin-1)*(idim+1)+id)
                  write(*,*)'coor = ',xcoophi(id,ip,ib)
                enddo
              endif
            enddo
          endif
*         on saute les translations rigides : itrig vient d'etre remplie dans dyne26
          if (itrig(ib,inel)) then 
            write(*,*)'filldef : translation rigide sautee'
            goto 1
          endif
*         sinon on rempli xtphi :
          write(*,*)'boucle sur xtphi'
          do ip=1,npdef
            ipoin = lpoi(ip)
            write(*,*)'ipoin = ',ipoin
            if (.not.(ipoin.eq.0)) then
              call extra9(icdm,ipoin,'UX',0,.false.,xval,iret)
              xtphi(1,ip,inel,ib) = xval
*             MAJ max des composantes :
              xcmax = max(xcmax,dabs(xval))
              write(*,*)'ux = ',xval
              call extra9(icdm,ipoin,'UY',0,.false.,xval,iret)
              xtphi(2,ip,inel,ib) = xval
*             MAJ max des composantes :
              xcmax = max(xcmax,dabs(xval))
              write(*,*)'uy = ',xval
              call extra9(icdm,ipoin,'UZ',0,.false.,xval,iret)
              xtphi(3,ip,inel,ib) = xval
*             MAJ max des composantes :
              xcmax = max(xcmax,dabs(xval))
              write(*,*)'uz = ',xval
            endif
          enddo
*         on rempli xtphin avec la base modale normee / comp max : 
          if (xcmax.gt.xzprec) then
            xnortot = 0.d0
            do ip=1,npdef
              xtphin(1,ip,inel,ib) = xtphin(1,ip,inel,ib)/xcmax
              xtphin(2,ip,inel,ib) = xtphin(2,ip,inel,ib)/xcmax
              xtphin(3,ip,inel,ib) = xtphin(3,ip,inel,ib)/xcmax
              xnortot = xnortot + ((xtphi(1,ip,inel,ib)**2) +
     &                             (xtphi(2,ip,inel,ib)**2) +
     &                             (xtphi(3,ip,inel,ib)**2))
            enddo
            xnortot = dsqrt(xnortot)
*           on remplit xmno avec la masse modale normee / comp max : 
            ina1 = iorsb(ib) - 1
            i2 = ina1 + inel
            xmno(inel,ib) = xm(i2,1) / (xcmax**2)
            write(*,*)'  xmno mode inel ',inel
            write(*,*)'                 ',xmno(inel,ib)
*           masses ponctuelles individuelles : 
            do ip=1,npdef
              xnor = dsqrt((xtphi(1,ip,inel,ib)**2) + 
     &                     (xtphi(2,ip,inel,ib)**2) +
     &                     (xtphi(3,ip,inel,ib)**2))
              xmpoi(ip,inel,ib) = xmno(inel,ib) * (xnor/xnortot)
            enddo
          else 
            xmno(inel,ib) = 0.d0
            do ip = 1,npdef
              do id=1,3
                xtphin(id,ip,inel,ib) = 0.d0
              enddo
              xmpoi(ip,inel,ib) = 0.d0
            enddo
          endif
*           
          goto 1
* si typret n'est pas table, la boucle s'arrete
        endif
*       write(*,*)'filldef : pause'
*       call exit(1)
*
      END

 
 
 
