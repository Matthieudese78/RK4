C DYNDIF    SOURCE    BP208322  18/12/20    21:15:41     10048          
C DYNDEV    SOURCE    LAVARENN  96/10/30    21:23:28     2349
      SUBROUTINE DYNRK(IALGO)
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*                                                                    *
*     Operateur DYNE : algorithme differences centrees (IALGO=2)     *
*                      et ACCELERATION_MOYENNE (IALGO=3)             *
*                      et FOX_GOODWIN (IALGO=4)                      *
*     ________________________________________________               *
*                                                                    *
*     Appel aux sous-programmes                                      *
*                                                                    *
*     Remarque : les segments de travail sont laisses actifs durant  *
*     l'execution de l'algorithme.                                   *
*                                                                    *
*--------------------------------------------------------------------*

-INC PPARAM
-INC CCOPTIO
*
      LOGICAL REPRIS,RIGIDE,LMODYN
*
      write(*,*)'DYNRK : start'
*     on laisse ichain qui est utilise dans l'appel a dyne15 :
      ICHAIN = 0
*
*     Lecture et coherence des operandes:
*
      IF (IIMPI.EQ.333) THEN
         WRITE(IOIMP,*)'DYNDIF : appel au sous-programme DEVLIR'
      ENDIF
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
      WRITE(IOIMP,*)'DYNDIF : avant lappel au sous-programme DEVLIR'
      ENDIF
      CALL DEVLIR(ITBAS,ITKM,ITA,ITLIA,ITCHAR,ITINIT,NP,PDT,NINS,
     &            ITSORT,ITREDU,KPREF,KCPR,ITCARA,LMODYN,ITDYN,
     &            KCPRIG)
      IF (IERR.NE.0) RETURN
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
      WRITE(IOIMP,*)'DYNDIF : apres lappel au sous-programme DEVLIR'
      ENDIF
      RIGIDE = (KCPRIG.ne.0)
      IF ((IALGO.NE.2).AND.(RIGIDE)) THEN
        WRITE(*,*)'DYNDIF: D3VALG incompatible avec rotations rigides'
        CALL ERREUR(272)
        RETURN
      ENDIF
*     Allocation de l'espace de travail:
*
      IF (IIMPI.EQ.333) THEN
         WRITE(IOIMP,*)'DINDIF : appel au sous-programme DEVALO'
      ENDIF
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DINDIF : avant lappel au sous-programme DEVALO'
      ENDIF
      CALL RKMKALO(ITBAS,ITKM,ITA,ITLIA,ITCHAR,ITINIT,NP,PDT,NINS,
     &            ITSORT,ITREDU,KPREF,KTQ,KTKAM,KTPHI,KTLIAA,KTLIAB,
     &            KTFEX,KTPAS,KTRES,KTNUM,IPMAIL,REPRIS,ICHAIN,
     &            KOCLFA,KOCLB1,ITCARA,LMODYN,KTROT)
      IF (IERR.NE.0) RETURN
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DINDIF : apres lappel au sous-programme DEVALO'
      ENDIF
*
*     Remplissage des tableaux des liaisons:
*
      IF (ITLIA.NE.0) THEN
         IF (IIMPI.EQ.333) THEN
            WRITE(IOIMP,*)'DYNDIF : appel au sous-programme DEVLIA'
         ENDIF
         IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : avant lappel au sous-programme DEVLIA'
         ENDIF
         CALL DEVLIA(ITLIA,KCPR,PDT,KTLIAA,KTLIAB,ITCARA,LMODYN,2)
         IF (IERR.NE.0) RETURN
         IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : apres lappel au sous-programme DEVLIA'
         ENDIF
      ENDIF
*
*     Transposition du contenu d'objets CASTEM2000 dans des tableaux:
*
      IF (IIMPI.EQ.333) THEN
         WRITE(IOIMP,*)'DYNDIF : appel au sous-programme D2VTRA'
      ENDIF
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : avant lappel au sous-programme D2VTRA'
      ENDIF
      CALL RKVTRA(ITBAS,ITKM,ITA,KTKAM,IPMAIL,KTRES,KTNUM,KPREF,KTPHI,
     &            KTLIAB,KTROT,ITCARA,LMODYN,IALGO,BETA,KCPRIG)
      IF (IERR.NE.0) RETURN
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : apres lappel au sous-programme D2VTRA'
      ENDIF
*
*     Remplissage du tableau des chargements exterieurs:
*
      IF (ITCHAR.NE.0) THEN
         IF (IIMPI.EQ.333) THEN
            WRITE(IOIMP,*)'DYNDIF : appel au sous-programme D2VFX0'
         ENDIF
         IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : avant lappel au sous-programme D2VFX0'
         ENDIF
* D2VFX0: Remplissage FEXA(ptrep,pdt,2 et 1) = chargmt en base A
         CALL D2VFX0(ITCHAR,KTNUM,KPREF,KTFEX,REPRIS,RIGIDE)
cms : on liste 
         IF (IERR.NE.0) RETURN
         IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : apres lappel au sous-programme D2VFX0'
         ENDIF
        IF (IIMPI.EQ.333) THEN
            WRITE(IOIMP,*)'DYNDIF : appel au sous-programme DEVSPM'
         ENDIF
         IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : avant lappel au sous-programme DEVPSM'
         ENDIF
*
* DEVPSM n'a pas ete modifie pour differences centrees, mais de toutes
* facons les pseudomodes ne sont pas correctes en non lineaire
         CALL DEVPSM(ITCHAR,ITBAS,KTLIAB,KTNUM,KTPHI,KTFEX,REPRIS)
         IF (IERR.NE.0) RETURN
         IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : apres lappel au sous-programme DEVPSM'
         ENDIF
      ENDIF
*
*     Lecture des chargements en Base B, pour les corps rigides
*
      IF (RIGIDE) THEN
         IF (IIMPI.EQ.333) THEN
               WRITE(IOIMP,*)'DYNDIF : appel au sous-programme D2VRIG'
         ENDIF
         IF (IIMPI.EQ.444) THEN
           CALL GIBTEM(XKT)
           INTERR(1)=INT(XKT)
           CALL ERREUR(-259)
           WRITE(IOIMP,*)'DYNDIF :avant lappel au sous-programme
     &  D2VRIG'
         ENDIF
* D2VRIG: Remplissage FTEXB(ptrep,pdt,1ou2,composante):
* Pour l'instant remplissage que si:
*    -La sous base du pt de liaison comporte une rota rigide
*               IAROTA(IBASB(pt liaison))).NE.0
         CALL D2VRIG(ITCHAR,KTNUM,KTPHI,KTFEX,KTLIAB,REPRIS)
         IF (IERR.NE.0) RETURN
         IF (IIMPI.EQ.444) THEN
            CALL GIBTEM(XKT)
            INTERR(1)=INT(XKT)
            CALL ERREUR(-259)
            WRITE(IOIMP,*)'DYNDIF :apres lappel au sous-programme
     &  D2VRIG'
         ENDIF
      ENDIF
*
*     Initialisation de l'algorithme, ou reprise de calcul:
*
      IF (IIMPI.EQ.333) THEN
         WRITE(IOIMP,*)'DYNDIF : appel au sous-programme D2VINI'
      ENDIF
      WRITE(*,*)'DYNDIF : appel au sous-programme D2VINI'
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : avant lappel au sous-programme D2VINI'
      ENDIF
      CALL D2VINI(ITINIT,KTKAM,KTQ,KTFEX,KTPAS,KTNUM,KTLIAA,KTLIAB,
     &            KTPHI,KCPR,KOCLFA,KOCLB1,REPRIS,lmodyn,KTROT,
     &            KCPRIG)
      IF (IERR.NE.0) RETURN
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : apres lappel au sous-programme D2VINI'
      ENDIF
*
*     Mise en oeuvre de l'algorithme:
*
      IF (IIMPI.EQ.333) THEN
         WRITE(IOIMP,*)'DYNDIF : appel au sous-programme D2VALG'
      ENDIF
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : avant lappel au sous-programme D2VALG'
      ENDIF
      IF(IALGO.EQ.2) THEN
        CALL D2VALG(KTQ,KTKAM,KTPHI,KTLIAA,KTLIAB,KTFEX,KTPAS,KTRES,
     &              KTNUM,KPREF,NINS,KOCLFA,KOCLB1,REPRIS,KTROT)
      ELSEIF(IALGO.GE.3) THEN
        CALL D3VALG(KTQ,KTKAM,KTPHI,KTLIAA,KTLIAB,KTFEX,KTPAS,KTRES,
     &              KTNUM,KPREF,NINS,KOCLFA,KOCLB1,REPRIS,RIGIDE,BETA)
      ENDIF
      IF (IERR.NE.0) RETURN
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : apres lappel au sous-programme D2VALG'
      ENDIF
*
*     Creation de la table resultat et nettoyage memoire:
*
      IF (IIMPI.EQ.333) THEN
         WRITE(IOIMP,*)'DYNDIF : appel au sous-programme DEVSOR'
      ENDIF
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : avant lappel au sous-programme DEVSOR'
      ENDIF
      CALL DEVSOR(KPREF,KTQ,KTKAM,KTPHI,KTLIAA,KTLIAB,KTFEX,KTPAS,
     &            KTRES,KTNUM,NINS,IPMAIL,REPRIS,ICHAIN,
     &            KOCLFA,KOCLB1,LMODYN,ITDYN,KTROT)
      IF (IERR.NE.0) RETURN
      IF (IIMPI.EQ.444) THEN
         CALL GIBTEM(XKT)
         INTERR(1)=INT(XKT)
         CALL ERREUR(-259)
        WRITE(IOIMP,*)'DYNDIF : apres lappel au sous-programme DEVSOR'
      ENDIF
      IF (IIMPI.EQ.333) THEN
         WRITE(IOIMP,*)'DYNDIF : fin presumee normale de ce calcul'
      ENDIF
*
      RETURN
      END



 
 
 
