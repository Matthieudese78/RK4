C DYNE18    SOURCE    CB215821  20/11/25    13:26:25     10792          
      SUBROUTINE DYNE18(ICHP,KTQ,I1,I2,KCPR,KCPRIG,KTROT,NSB)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*                                                                    *
*     Op{rateur DYNE : algorithme de Fu - de Vogelaere               *
*     ________________________________________________               *
*                                                                    *
*     Remplissage du tableau des variables g{n{ralis{es.             *
*                                                                    *
*     Param}tres:                                                    *
*                                                                    *
* e   ICHP  : CHPOINT dans lequel on va chercher les valeurs         *
* es  ITQ   : Segment des variables de mouvement g{n{ralis{es        *
* e   I1    : Indique si l'on travaille sur les d{placements,        *
*             sur les vitesses, ou les acc{l{rations                 *
* e   I2    : Indice du pas                                          *
* e   KCPR  : Segment des points                                     *
*                                                                    *
*     Auteur, date de cr{ation:                                      *
*                                                                    *
*     Lionel VIVAN, le 26 Juillet 1989.                              *
*                                                                    *
*--------------------------------------------------------------------*

-INC PPARAM
-INC CCOPTIO
-INC SMCHPOI
-INC SMCOORD
-INC SMELEME
*
      SEGMENT,ICPR(nbpts)
      SEGMENT,ICPRIG(nbpts)
      SEGMENT,ICOR(NP1)
      SEGMENT,ICORIG(NP1)
      SEGMENT,MTQ
         REAL*8 Q1(NA1,5),Q2(NA1,5),Q3(NA1,5)
         REAL*8 WEXT(NA1,2),WINT(NA1,2)
      ENDSEGMENT
      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EPOT(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XTPHIN(3,NPDEF,NA2,NSB),XMNO(NA2,NSB)
         REAL*8 XMPOI(NPDEF,NA2,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT
*
      LOGICAL RIGIDE
      REAL*8  TSB(NSB),QUATINI(4)
      CHARACTER*4 MOTCOMP
*
      WRITE(*,*)'DYNE18 : START'
*     NB : dyne18 fonctionne pour diffrences_centrees ET RKMK4
*           en implementant a chaque fois les indices 2 ET 5 de certaines tables
*     pour le shema runge kutta :
      i3 = 5
*
      MTQ  = KTQ
      ICPR = KCPR
      RIGIDE = (KTROT.NE.0)
      IF (RIGIDE) THEN
        ICPRIG = KCPRIG
        segact,ICPRIG
        MTROT = KTROT
* Remarque: dans dyne18 DTHETA est utilis√© pour stocker le depl initial 
*           donne sous forme de vecteur rotation (3,1).
        DO IB=1,NSB
          TSB(IB) = 0
          DO I=1,3
            DTHETA(I,IB) = 0.D0
          ENDDO
        ENDDO
        
      ENDIF
*
      segact,ICPR
*
********** Boucle sur le chpoint des CIs:

      MCHPOI = ICHP
      SEGACT,MCHPOI
      NSOUPO = IPCHP(/1)    
      DO 10 II1=1,NSOUPO
         MSOUPO = IPCHP(II1)
         SEGACT,MSOUPO
         MELEME = IGEOC
         SEGACT,MELEME
         NP = NUM(/2)
         WRITE(*,*)'DYNE18: nbr points chpoint ini = ',NP
         NP1 = NP
         SEGINI,ICOR
         IF (RIGIDE) THEN
           SEGINI,ICORIG
         ENDIF
         DO 2 IP = 1,NP
            KNOE = ICPR(NUM(1,IP))
            IF (KNOE.NE.0) ICOR(IP) = KNOE
            IF ((KNOE.NE.0).AND.(IIMPI.EQ.555)) WRITE(IOIMP,*)
     &                             'DYNE18: Noeud: ',NUM(1,IP)
* ICPRIG pointe les ptref originaux des rotas rigides
* (avant remodelage de la base modale par rectmod (dyne25))
            IF (RIGIDE) THEN
              KNOE2 = ICPRIG(NUM(1,IP))
              IF (IIMPI.EQ.555) THEN ;
                WRITE(IOIMP,*)'DYNE18: NUM(1,IP) = ',NUM(1,IP)
                WRITE(IOIMP,*)'DYNE18: ICPRIG(NUM(',1,IP,')) = ',
     &                     ICPRIG(NUM(1,IP))
              ENDIF
              IF (KNOE2.NE.0) THEN 
                ICORIG(IP) = KNOE2
                WRITE(*,*)'        ICORIG(',IP,') = ',ICORIG(IP)
                WRITE(*,*)'        ITCOMP(ICORIG(',IP,') = ',
     &                             ITCOMP(ICORIG(IP))
              ENDIF
            ENDIF
            

 2          CONTINUE
*        end do
         SEGDES,MELEME
         NC = NOCOMP(/2)
         MPOVAL = IPOVAL
         SEGACT,MPOVAL
         N = VPOCHA(/1)
*
         IF (I1.EQ.1) THEN
            WRITE(*,*)'DYNE18 : DEPLACEMENTS.'
            IROT = 0
            DO J=1,N
               DO K=1,NC
                  IA = ICOR(J)
*                -cas modes elastiques
                  IF (IA.NE.0) THEN
                    Q1(IA,I2) = VPOCHA(J,K)
                    Q1(IA,I3) = VPOCHA(J,K)
                    WRITE(*,*)'   Mode flexible IA = ',IA
                    WRITE(*,*)'   Q1(IA,I2) = ',Q1(IA,I2) 
                  ENDIF
*                -cas rotas rigides
                  IF (RIGIDE) THEN
                    IB = ICORIG(J)
                    IF (IB.NE.0) THEN
                      IROT = IROT + 1
                      ISB = IBASR(IB)
                      MOTCOMP = ITCOMP(IB)
                      WRITE(*,*)'DYNE18:  ITCOMP(',IB,') = ',
     &                           ITCOMP(IB)
* Rq: ci-dessous, la condition IF (K.LE.3 est) juste une precaution, normalement K = 1 
*     (1 scalaire par mode).
                      IF (MOTCOMP.EQ.'RX') THEN
                        DTHETA(1,ISB) = VPOCHA(J,K)
                        WRITE(*,*)'DYNE18: DTHETA(',1,ISB,') = ',
     &                                     DTHETA(1,ISB)
                      ELSEIF(MOTCOMP.EQ.'RY') THEN
                        DTHETA(2,ISB) = VPOCHA(J,K)
                        WRITE(*,*)'DYNE18: DTHETA(',2,ISB,') = ',
     &                                     DTHETA(2,ISB)
                      ELSEIF(MOTCOMP.EQ.'RZ') THEN
                        DTHETA(3,ISB) = VPOCHA(J,K)
                        WRITE(*,*)'DYNE18: DTHETA(',3,ISB,') = ',
     &                                     DTHETA(3,ISB)
                      ENDIF
*                     Rq: on peut utiliser DTHETA car il est de tte facon 
*                         ecrase dans d2vpas.
                      TSB(ISB) = TSB(ISB) + 1
                    ENDIF
                  ENDIF
               ENDDO
            ENDDO
            IF ((RIGIDE).AND.(IROT.NE.0)) THEN
*             On implemente dans OMEG1 = orientation du solide dans l espace.
              DO IIB=1,NSB
                ISB = IBASR(IIB)
                IF (TSB(ISB).NE.0) THEN
*                 DO I=1,3
*                   WRITE(*,*)
*     &             'DYNE18: DTHETA(',I,IIB,') = ',DTHETA(I,IIB)
*                 ENDDO
                 CALL VECT2QUAT(DTHETA(1,IIB),OMEG1(1,2,IIB))
*                shema runge-kutta :
                 CALL VECT2QUAT(DTHETA(1,IIB),OMEG1(1,i3,IIB))
*                DO I=1,4
*                   WRITE(*,*)
*     &             'DYNE18: OMEG1(',I,2,IIB,') = ',OMEG1(I,2,IIB)
*                ENDDO
*
                 CALL QUAT2MAT(OMEG1(1,2,IIB),ROT(1,1,2,IIB))
*                shema runge-kutta :
                 CALL QUAT2MAT(OMEG1(1,i3,IIB),ROT(1,1,i3,IIB))
*                DO I=1,3
*                DO J=1,3
*                     WRITE(*,*)
*     &               'DYNE18: ROT(',I,J,2,IIB,') = ',ROT(I,J,2,IIB)
*                ENDDO
*                ENDDO
                ENDIF
              ENDDO
            ENDIF
*              
         ELSE IF (I1.EQ.2) THEN
            WRITE(*,*)'DYNE18 : VITESSES.'
            DO J=1,N
               DO K=1,NC
                  IA = ICOR(J)
                IF (IA.NE.0) then
                  Q2(IA,I2) = VPOCHA(J,K)
                  Q2(IA,I3) = VPOCHA(J,K)
                endif
                  IF (RIGIDE) THEN
                    IB = ICORIG(J)
                    IF (IB.NE.0) THEN
                      ISB = IBASR(IB)
                      MOTCOMP = ITCOMP(IB)
                      IF (MOTCOMP.EQ.'RX') THEN
                        OMEG2(1,I2,ISB) = VPOCHA(J,K)
                        OMEG2(1,I3,ISB) = VPOCHA(J,K)
                        IF (IIMPI.EQ.555) THEN
              WRITE(IOIMP,*)'DYNE18: OMEG2(',1,I2,ISB,') = ',
     &                                OMEG2(1,I2,ISB)
                        ENDIF
                      ELSEIF(MOTCOMP.EQ.'RY') THEN
                        OMEG2(2,I2,ISB) = VPOCHA(J,K)
                        OMEG2(2,I3,ISB) = VPOCHA(J,K)
                        IF (IIMPI.EQ.555) THEN
              WRITE(IOIMP,*)'DYNE18: OMEG2(',2,I2,ISB,') = ',
     &                                OMEG2(2,I2,ISB)
                        ENDIF
                      ELSEIF(MOTCOMP.EQ.'RZ') THEN
                        OMEG2(3,I2,ISB) = VPOCHA(J,K)
                        OMEG2(3,I3,ISB) = VPOCHA(J,K)
                        IF (IIMPI.EQ.555) THEN
              WRITE(IOIMP,*)'DYNE18: OMEG2(',3,I2,ISB,') = ',
     &                                OMEG2(3,I2,ISB)
                        ENDIF

                      ENDIF
                    ENDIF
                  ENDIF
               ENDDO    
             ENDDO

*
         ELSE IF (I1.EQ.3) THEN
            WRITE(*,*)'DYNE18 : ACCELERATIONS.'
            DO J=1,N
               DO K=1,NC
                  IA = ICOR(J)
                  IF (IA.NE.0) Q3(IA,I2) = VPOCHA(J,K)
                  IF (RIGIDE) THEN
                    IB = ICORIG(J)
                    IF (IB.NE.0) THEN
                      ISB = IBASR(IB)
                      MOTCOMP = ITCOMP(IB)
                      IF (MOTCOMP.EQ.'RX') THEN
                        OMEG3(1,I2,ISB) = VPOCHA(J,K)
                        OMEG3(1,I3,ISB) = VPOCHA(J,K)
*                        WRITE(*,*)'DYNE18: OMEG3(1,I2,ISB) = ',
*     &                                     OMEG3(1,I2,ISB)
                      ELSEIF(MOTCOMP.EQ.'RY') THEN
                        OMEG3(2,I2,ISB) = VPOCHA(J,K)
                        OMEG3(2,I3,ISB) = VPOCHA(J,K)
*                        WRITE(*,*)'DYNE18: OMEG3(2,I2,ISB) = ',
*     &                                     OMEG3(2,I2,ISB)
                      ELSEIF(MOTCOMP.EQ.'RZ') THEN
                        OMEG3(3,I2,ISB) = VPOCHA(J,K)
                        OMEG3(3,I3,ISB) = VPOCHA(J,K)
*                        WRITE(*,*)'DYNE18: OMEG3(3,I2,ISB) = ',
*     &                                     OMEG3(3,I2,ISB)
                      ENDIF
                    ENDIF
                  ENDIF
              ENDDO
            ENDDO
*
         ELSE IF (I1.EQ.4) THEN
            DO J=1,N
               DO K=1,NC
                  IA = ICOR(J)
                  IF (IA.NE.0) WEXT(IA,I2) = VPOCHA(J,K)
               ENDDO
            ENDDO

         ELSE IF (I1.EQ.5) THEN
            DO J=1,N
               DO K=1,NC
                  IA = ICOR(J)
                  IF (IA.NE.0) WINT(IA,I2) = VPOCHA(J,K)
               ENDDO
            ENDDO
*
         ENDIF

         SEGDES,MPOVAL,MSOUPO
         SEGSUP,ICOR
         IF (RIGIDE) THEN
           SEGSUP,ICORIG
         ENDIF
 10      CONTINUE
*     end do
      SEGDES,MCHPOI
*
      END


 
 
