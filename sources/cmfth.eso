      SUBROUTINE cmfth(Q1,XM,KTROT,NA1,NB1M,IB,ind,na3,ina1) 
     
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
******************************************************************
*         BRAS de levier : seulement si le centred rotation n'est pas confondu avec le centre de gravite
******************************************************************
*   consistent mass  : shabana p 321 : mthf = Ithf
*                    : shabana p 276 : Ithf = int_V rho chpa(X + u_f) * phi
*   lumped masses : shabana p 320 :
*   mfth_i = sum_j m_ij * phi_ij^T * A^T * B_ij , i = mode , j = node, B = - A chap(X+u_f)
*     - une partie time-invariant : 
*     mfth_stat_ij = - m_ij * phi_ij^T * chap(X_j) , j = node 
*     - une partie corrective :  
*     mfth_corr_ij = - m_ij * phi_ij^T * chap(u_f^ij) , i = mode, j = node 
*     chap est associatif donc on calcule les 2 en mm temps 
*
*   Rq : on saute les translations rigides
******************************************************************

      SEGMENT,MTROT
        REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
        REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
        REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
        REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
        REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
        REAL*8 PICIN(NSB,3),TCIN(NSB),EDEF(NSB),XCG(3,NSB)
        REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
        REAL*8 XMNO(NA2,NSB),QVTH(3,NSB),QVR(3,NSB),QVF(NA2,NSB)
        REAL*8 MRTH(3,3,NSB),MTHTH(3,3,NSB)
        REAL*8 MFTH(NA2,3,NSB),MFR(NA2,3,NSB),MTOT(NTOT,NTOT,NSB)
        REAL*8 SKL(3,3,NA2,NA2,NSB),IKL(3,3,NA2,NSB)
        REAL*8 BL0(3,NSB),BLF(3,NA2,NSB)
        REAL*8 XMPOI(NPDEF,NSB)
        INTEGER IBASR(NSB2)
        CHARACTER*4 ITCOMP(NSB2)
        LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT
      
*
      REAL*8 Q1(NA1,*)
      REAL*8 XM(NA1,*)
      REAL*8 xtcha(3,3),xt(3)
******************************************************************
      mtrot = ktrot
******************************************************************
      npdef = xtphi(/2)
******************************************************************
*     nbr de modes elastiques dans la sous bases :
******************************************************************
*     na3 = inmsb(ib)
*     1er mode elast ou transl rigi de la sous base ib ds l'ensemble des modes elast + trans rigis
*     ina1 = iorsb(ib) - 1
*******************************************************************
*      do ip=1,npdef
*******************************************************************
*        do 1 in = 1,na3
*          if (itrig(ib,in)) goto 1
*          i2 = ina1 + in
*          do id=1,3
*            Xt(id) = xcoophi(id,ip,ib) - xcent(id,ib) + 
*     &              (xtphi(id,ip,in,ib) * q1(i2,ind)) 
*          enddo
*          call chap(Xt(1),Xtcha(1,1)) 
**         mfth :
*          do id=1,3
*            do j=1,3
*              mfth(in,id,ib) = mfth(in,id,ib) - 
*     &        (xmpoi(ip,in,ib) * xtphi(j,ip,in,ib) * Xtcha(j,id))
*            enddo
**           mfth(in,id) = xmpoi(ip,in,ib) * mfth(in,id)
*          enddo
**          mthf :
**          do id=1,3
**            mthf(id,in) = 0.d0
**            do j=1,3
**                mthf(id,in) = mthf(id,in) +
**     &                        Xtcha(id,j) * xtphi(j,ip,in,ib)
**            enddo
**            mthf(id,in) =  xmpoi(ip,in,ib) * mthf(id,in)
**          enddo
* 1      continue
****** fin boucle sur les points 
*      enddo
* 2eme essai :
*      do in=1,na3
*        i2 = ina1 + in
*        if (.not.itrig(ib,in)) then
*        do ip=1,npdef
*        xt(1) = xcoophi(1,ip,ib) - xcent(1,ib) + 
*     &          xtphi(1,ip,in,ib)*q1(i2,1) 
*        xt(2) = xcoophi(2,ip,ib) - xcent(2,ib) + 
*     &          xtphi(2,ip,in,ib)*q1(i2,2) 
*        xt(3) = xcoophi(3,ip,ib) - xcent(3,ib) + 
*     &          xtphi(3,ip,in,ib)*q1(i2,3) 
*        mfth(in,1,ib) = mfth(in,1,ib) + (xmpoi(ip,in,ib) *
*     &      (xt(2)*xtphi(3,ip,in,ib) - xt(3)*xtphi(2,ip,in,ib))) 
*        mfth(in,2,ib) = mfth(in,2,ib) + (xmpoi(ip,in,ib) *
*     &      (xt(3)*xtphi(1,ip,in,ib) - xt(1)*xtphi(3,ip,in,ib))) 
*        mfth(in,3,ib) = mfth(in,3,ib) + (xmpoi(ip,in,ib) *
*     &      (xt(1)*xtphi(2,ip,in,ib) - xt(2)*xtphi(1,ip,in,ib))) 
*        enddo
*        endif
*      enddo
*
*     cf dyne26 apres appel filldef :
*     partie statique : int_V rho X0 wedge Phi dV
      do in=1,na3 
        mfth(in,1,ib) = mfth(in,1,ib) + ikl(2,3,in,ib) - ikl(3,2,ib)
        mfth(in,2,ib) = mfth(in,2,ib) + ikl(3,1,in,ib) - ikl(1,3,ib)
        mfth(in,3,ib) = mfth(in,3,ib) + ikl(1,2,in,ib) - ikl(2,1,ib)
      enddo
*     partie flexible : int_V rho (Phi q_f) wedge Phi dV
*                       = q_f^T (S23 - S32)
*                         q_f^T (S31 - S13)
*                         q_f^T (S12 - S21)
      do in=1,na3
        if (.not.(itrig(ib,in))) then
          do j=1,na3
            i2 = j + ina1
            mfth(in,1,ib) = mfth(in,1,ib) + 
     &                q1(i2,1)*(skl(2,3,j,in,ib) - skl(3,2,j,in,ib))
            mfth(in,2,ib) = mfth(in,2,ib) + 
     &                q1(i2,1)*(skl(3,1,j,in,ib) - skl(1,3,j,in,ib))
            mfth(in,3,ib) = mfth(in,3,ib) + 
     &                q1(i2,1)*(skl(1,2,j,in,ib) - skl(2,1,j,in,ib))
          enddo
        endif
      enddo
* 
      write(*,*)'MFTH :'
      do in=1,na3
         write(*,'(3(1X,F8.5))') , (mfth(in,id,ib),id=1,3)
      enddo

*
      END