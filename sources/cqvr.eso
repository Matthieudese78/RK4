      SUBROUTINE cqvr(Q1,q2,KTROT,NA1,IB,ind,na3,ina1) 
     
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
******************************************************************
*         BRAS de levier : seulement si le centred rotation n'est pas confondu avec le centre de gravite
******************************************************************
*   consistent mass : shabana p 300 : 
*     qvr = - A * [chap(W)**2 * int_V rho (X + sum_i phi_i q_f) dV + 
*                  2*chap(W) * int_V phi_i dV dot_(q_f) ]
*   lumped masses : formule perso :
*   1ere partie : 
*     - 1.1 : partie statique : 
*     chap(W)*2 * mtot * X
*     - 1.2 : patie corrective : 
*   qvr_i = sum_j m_ij * chap(W)**2 * phi_ij q_f^i , i = mode , j = node
*
*   2nd partie : 
*     - 2. : 2 * chap(W) * sum_j m_ij phi_ij dot(q_f^i) 
*
*   final : qvr = -A * (1.1 + 1.2 + 2.)
*
*   Rq : on saute les translations rigides
******************************************************************

      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EDEF(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XMNO(NA2,NSB),QVTH(3,NSB),QVR(3,NSB),QVF(NA2,NSB)
         REAL*8 MRTH(3,3,NSB),MTHTH(3,3,NSB)
         REAL*8 MFTH(NA2,3,NSB),MFR(NA2,3,NSB),MTOT(NTOT,NTOT,NSB)
         REAL*8 SKL(3,3,NA2,NA2,NSB),IKL(3,3,NA2,NSB)
         REAL*8 BL0(3,NSB),BLF(3,NA2,NSB)
         REAL*8 XMPOI(NPDEF,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT
      
*
      REAL*8 Q1(NA1,*),q2(na1,*)
      REAL*8 qv2(3)
      REAL*8 wchap(3,3),wchap2(3,3)
******************************************************************
      mtrot = ktrot
******************************************************************
      npdef = xtphi(/2)
******************************************************************
*     nbr de modes elastiques dans la sous bases :
******************************************************************
*     na3 = inmsb(ib)
*     1er mode elast ou transl rigi de la sous base ib ds l'ensemble des modes elast + trans rigis
*     ina1 = iorsb(ib) - 1

******************************************************************
*     calcul de chap(W), chap(W)**2 :
******************************************************************
      call chap(omeg2(1,ind,ib),wchap(1,1))
      do id=1,3
        do j=1,3
          wchap2(id,j) = 0.d0
          do k=1,3
            wchap2(id,j) = wchap2(id,j) + wchap(id,k) * wchap(k,j)
          enddo
*          write(*,*)'wchap2(id,j) = ',wchap2(id,j)
        enddo
      enddo
******************************************************************
*     1ere partie :
******************************************************************
*       - 1.1 partie statique : chap(W)**2 * bras de levier
******************************************************************
      do id=1,3
        qvr(id,ib) = 0.d0
        do j=1,3
          qvr(id,ib) = qvr(id,ib) + wchap2(id,j)*XCG(j,ib)
        enddo
        qvr(id,ib) = mtsb(ib) * qvr(id,ib)
*        write(*,*)'1 : qvr(id,ib) = ',qvr(id,ib)
      enddo

******************************************************************
      do ip=1,npdef
******************************************************************
        do 1 in = 1,na3
          if (itrig(ib,in)) goto 1
          i2 = ina1 + in
******************************************************************
*       - 1.2 partie corrective : chap(W)**2 * m_ij * u_f_ij
******************************************************************
          do id=1,3
            do j=1,3
              qvr(id,ib) = qvr(id,ib) +
     &   (wchap2(id,j)*(xtphi(j,ip,in,ib)*q1(i2,ind))*xmpoi(ip,ib))
*              write(*,*)'    xtphi(j,ip,in,ib) = ',xtphi(j,ip,in,ib)
            enddo
*            write(*,*)'2 : q1(i2,ind) = ',q1(i2,ind)
*            write(*,*)'    xmpoi(ip,ib) = ',xmpoi(ip,ib)
*            write(*,*)'2 : qvr(id,ib) = ',qvr(id,ib)
          enddo
******************************************************************
*       - 2. :  2 * chap(W) * sum_j m_ij phi_ij dot(q_f^i) 
******************************************************************
          do id=1,3
            do j=1,3
              qvr(id,ib) = qvr(id,ib) +  
     &   (2.*wchap(id,j)*xtphi(j,ip,in,ib)*q2(i2,ind)*xmpoi(ip,ib))
            enddo
*            write(*,*)'3 : qvr(id,ib) = ',qvr(id,ib)
**           ponderation par la masse ponctuelle :
*            qvr(id,ib) = qvr(id,ib) * xmpoi(ip,ib)
          enddo
 1      continue
***** fin boucle sur les points 
      enddo
******************************************************************
*       final :  - A * (1.1 + 1.2 + 2.)
******************************************************************
      do id=1,3
        qv2(id) = 0.d0
        do j=1,3
          qv2(id) = qv2(id) - (rot(id,j,ind,ib) * qvr(j,ib))
        enddo
        if (qv2(id).ne.qv2(id)) then
         write(*,*)'cqvr : qv2 = NaN!'
         call exit(1)
        endif
      enddo
      qvr(1,ib) = qv2(1) 
      qvr(2,ib) = qv2(2) 
      qvr(3,ib) = qv2(3) 
******************************************************************
*      write(*,*)'QVR :'
*      write(*,'(3(1X,F8.5))') , (qvr(id,ib),id=1,3)
*
      END