C HBMNEWT   SOURCE    BP208322  20/10/05    21:15:17     10742          

      SUBROUTINE HBMNEWT(NT,NHBM,NDDL,NFFT,KTQ,KTKAM,MTPHI,KTEMP,KPARNUM
     &   ,KTLIAA,MTLIAB,KTFEX,MTPAS,LOCLFA,LOCLB1,CHECK,TYPC,ITER)
*
*=======================================================================
*
*                     Methode de Newton-Raphson  
*
* Convergence vers une solution des equations d'equilibre (frequentiel).
* TYPC(1) indique le type de calcul a realiser:
*      = | 'I' : solution initiale 
*        | 'C' : pas correcteur de la continuation 
* TYPC(2) indique le type de calcul a realiser:
*      = | 'F' : reponse Forcee
*        | 'A' : reponse Autonome
*        | 'N' : reponse libre : Non-linear normal modes
*
*=======================================================================     

*----- Declarations ----------------------------------------------------

       IMPLICIT INTEGER(I-N)
       IMPLICIT REAL*8(A-H,O-Z)
       REAL*8 fvec(NT),AVVP(NT),VCTCS(7),LAMBD(NDDL),AiDi(2),Di(2),bi(2)
       REAL*8 J2(NT+1,NT+1), Ja2(NT+2,NT+2)
       LOGICAL check,JANAL2
c        CHARACTER*2 TYPC
       INTEGER INFO
       REAL*8 fref,fref0
       REAL*8 gx(NT)
       
-INC SMLREEL
-INC PPARAM
-INC CCOPTIO
*-INC TMDYNC.INC
************************** debut TMDYNC.INC ****************************

*    TMDYNC : FUTUR INCLUDE POUR LES SEGMENTS DE L'OPERATEUR DYNC
*    TODO   : a extraire dans un include des que stabilise
*
*     Segment des variables generalisees:
*     -----------------------------------
      SEGMENT MTQ
         REAL*8 Q1(NT1)
         REAL*8 OMEG,XPARA
         REAL*8 JAC(NT1,NT1),ZZ(NT1,NT1),RX(NT1,NT1)
         REAL*8 dX(NT1), dw, dv
      ENDSEGMENT
*     Q1   : vecteur des inconnues frequentielles de dimension (2h+1)*n
*            Q1 = {q_0 q_c1 q_s1 ... q_sh}
*            avec q_i vecteur de dimension n ou n=nombre de modes
*     OMEG : frequence fondamentale de l'approximation
*     XPARA: parametre de continuation (par defaut la frequence) 
*            \in [PARINI,PARFIN]
*     RX   : matrice jacobienne = ZZ + dFnl/dX
*     JAC  : jacobienne des efforts non-lineaires  = dFnl/dX
*     ZZ   : matrice dynamique associee aux matrices modales K, M et C 
*            lineaires et constantes
*     {dX,dw,(dv)} : vecteur tangent utilise pour la prediction
*
*
*     Segment contenant les matrices XK, XASM et XM:
*     ---------------------------------------------
      SEGMENT MTKAM
         REAL*8 XK(NA1,NB1K),XASM(NA1,NB1C),XM(NA1,NB1M)
         REAL*8 GAM(NPC1,nl1),IGAM(nl1,NPC1),DL(nl1)
*         REAL*8 GAMFIN(NPC2,nl1)
      ENDSEGMENT
*     XK,XASM et XM : matrices de raideur, amortissement et masse
*     GAM et IGAM : matrices pour la FFT et son inverse
*     GAMFIN      : 
*
*     Segment des deformees modales:
*     ------------------------------
*     (idem DYNE)
      SEGMENT MTPHI
         INTEGER IBASB(NPLB),IPLSB(NPLB),INMSB(NSB),IORSB(NSB)
         INTEGER IAROTA(NSB)
         REAL*8  XPHILB(NSB,NPLSB,NA2,IDIMB)
      ENDSEGMENT
*
*     Segment descriptif des liaisons en base A:
*     ------------------------------------------
*     (idem DYNE)
      SEGMENT MTLIAA
         INTEGER IPALA(NLIAA,NIPALA),IPLIA(NLIAA,NPLAA),JPLIA(NPLA)
         REAL*8  XPALA(NLIAA,NXPALA)
      ENDSEGMENT
*
*     Segment descriptif des liaisons en base B:
*     ------------------------------------------
*     (idem DYNE)
      SEGMENT MTLIAB
         INTEGER IPALB(NLIAB,NIPALB),IPLIB(NLIAB,NPLBB),JPLIB(NPLB)
         REAL*8  XPALB(NLIAB,NXPALB)
         REAL*8  XABSCI(NLIAB,NIP),XORDON(NLIAB,NIP)
      ENDSEGMENT
*
*     Segment representant les chargements exterieurs:
*     -----------------------------------------------
      SEGMENT MTFEX
         REAL*8  FEXA(NT1)
         REAL*8  FEXPSM(NPLB,NPC1,2,IDIMB)
         INTEGER BAL
      ENDSEGMENT
*     FEXA : Vecteur des efforts ext. sous la forme de coefficients de
*            Fourier et exprimes en base A
*     FEXPSM: chargement/deplacement statique lie aux modes negliges
*             (neglige aussi les Fnl). Dans DYNC toujours =0, cree pour
*             compatibilite avec calcul des Fnl.
*     BAL  : indique s'il s'agit d'un chargement de type balourd
*            (cad proportionnel a OMEG**2)
*
*     Segment "local" pour DEVLFA:
*     ----------------------------
      SEGMENT LOCLFA
         REAL*8 FTEST(NA1,4)
      ENDSEGMENT
*      
*     Segment "local" pour DEVLB1:
*     ----------------------------
      SEGMENT LOCLB1
         REAL*8 FTEST2(NPLB,6)
      ENDSEGMENT
*      
*     Segment contenant les variables au cours d un pas de temps:
*     ----------------------------------------------------------
      SEGMENT MTPAS
         REAL*8 FTOTA(NA1,4),FTOTB(NPLB,IDIMB),FTOTBA(NA1)
         REAL*8 XPTB(NPLB,2,IDIMB),FINERT(NA1,4)
         REAL*8 XVALA(NLIAA,4,NTVAR),XVALB(NLIAB,4,NTVAR)
         REAL*8 FEXB(NPLB,3,IDIM),XCHPFB(2,NLIAB,4,NPLB)
         REAL*8 KTOTXA(NA1,NA1),KTOTVA(NA1,NA1)
         REAL*8 KTOTXB(NPLB,IDIMB,IDIMB), KTOTVB(NPLB,IDIMB,IDIMB) 
      ENDSEGMENT
*     FTOTA/B/BA : forces sur base A, B et B projetees sur A
*     XPTB       : deplacement du point d'une liaison en base B
*     XVALA/B    : grandeurs de la liaison en base A/B a stocker
*     FEXB       : forces exterieures en base B (a priori uniquement 
*                  pour les moments appliques aux rotations rigides ?)
*     XCHPFB     : forces de contact en base B (lorsqu'on  considere un
*                  maillage de contact dans certaines liaisons)
*     KTOTXA/XB/VA/VB : Jacobienne par rapport au deplacement/vitesse en
*                       base A/B (= contributions a dFnl/dX)
*
*
*     Segment des points de reference des modes (base A):
*     --------------------------------------------------
      SEGMENT MPREF
         INTEGER IPOREF(NPREF),IPORIG(NPRIG)
      ENDSEGMENT
*
*     Segment des points en base B:
*     -----------------------------
      SEGMENT NCPR(XCOOR(/1)/(IDIM+1))
*     NCRP(#global) = #local dans XPTB (1er indice)      
*
*     Segment des parametres numeriques pour la continuation: 
*     ------------------------------------------------------
      SEGMENT PARNUM
         CHARACTER*4 TYPS
         REAL*8   DS,DSMAX,DSMIN,ANGMIN,ANGMAX,ITERMOY,ISENS,TOLMIN
         REAL*8   PARINI,PARFIN
         INTEGER  ITERMAX,NBPAS
         LOGICAL  JANAL
      ENDSEGMENT
*
*     Segment des resultats:
*     ---------------------
      SEGMENT  PSORT
        REAL*8 QSAVE(NT1,NPAS),WSAVE(NPAS),LSAVE(2,2*NA1,NPAS)
        REAL*8 VSAVE(NPAS)
        LOGICAL ZSAVE(NPAS)
        CHARACTER*2 TYPBIF(NBIFU)
        REAL*8 QBIFU(NT1,NBIFU),WBIFU(NBIFU),WBIF2(NBIFU)
        REAL*8 QPSIR(NT1,NBIFU),QPSII(NT1,NBIFU)
        INTEGER CBIF
      ENDSEGMENT
*     QSAVE(i,j) = Q harmonique i au pas j
*     VSAVE(j)   = parametre de continuation (si non w) au j-eme pas
*     ZSAVE(j)   = stabilite au j-eme pas
*     LSAVE(1,j) : partie reelle de l'exposant de Floquet
*     LSAVE(2,j) : partie imaginaire de l'exposant de Floquet
*     TYPBIF = {LimitPoint, BranchPoint, NeimarkSacker, PeriodDoubling}
*     QBIFU,WBIFU : vecteur Q et w au point de bifurcation
*           WBIF2 : partie imaginaire de l'exposant de Floquet
*     QPSIR,QPSII : vecteur propre au point de bifurcation
      
*     Segment des tableaux de travail:
*     -------------------------------
      SEGMENT  MTEMP
         REAL*8 RW(NT1),A,T0(NT1+1),TP(NT1+1),AMPX,AUX
         REAL*8 T02(NT1+2), TP2(NT1+2)
         INTEGER IPIV(NT1),IPIV2(NT1+1),IPIV3(NT1+2)
         REAL*8 res
         REAL*8 RHS(NT1+1),Ja(NT1+1,NT1+1)
         REAL*8 QOLD(NT1),OMEGOLD
         REAL*8 MATJA(NT1+1,NT1+1),Rw2(NT1)
         REAL*8 Jaa(NT1+2,NT1+2),RHS2(NT1+2),Ra(NT1),VV,VVOLD
      ENDSEGMENT
*     Jacobiennes augmentees 
*     Ja : [ RX  Rw ; dX dw]
*     Jaa: [ RX  Rw Ra; gx 0 0; dX dw da]


*************************** fin TMDYNC.INC *****************************

       CHARACTER*2 TYPC
       REAL*8 ZERO,TWO,ONE
       PARAMETER (ZERO=0.D0, TWO=2.D0,ONE=1.D0)
       LOGICAL   NNM
c        NNM=(TYPC.EQ.'IN').OR.(TYPC.EQ.'CN')
       NNM=TYPC(2:2).EQ.'N'
*
*      Segments
       MTQ   = KTQ
       MTKAM = KTKAM
       MTEMP = KTEMP
       PARNUM = KPARNUM
       MTLIAA= KTLIAA 
c        MTLIAB= KTLIAB
       MTFEX = KTFEX  
       ITER=-1
c        RELAX=1.d0
       JANAL2=JANAL

c *------ Test de convergence pour la solution ------------------
c         test=0.D0
c         DO i=1,NT
c            IF(abs(fvec(i)).GT.test) test=abs(fvec(i))
c         ENDDO
        
        
*------ Calcul de la raideur dynamique tangente des efforts lineaires --

*       Matrice liee a la base modale (avec ou sans terme dissipatif selon NNM)
        CALL HBMZ(NT,NHBM,NDDL,MTQ,MTKAM,.not.NNM)   
        
*       cas Granger-Paidoussis : rajouter raideur de couplage
c       aussi pour cas NNM ? a voir...
        IF(.not.NNM) THEN
          DO J = 1,IPALA(/1)
            IF (IPALA(J,1).EQ.5 .AND. IPALA(J,3).EQ.101) THEN
             DO IJ = 1,7
               VCTCS(IJ) = XPALA(J,IJ)
             ENDDO
             IF (TYPC.EQ.'CA') THEN 
               VCTCS(4) = VV
               XPALA(J,4) = VV
             ENDIF
             JG = NDDL
             MLREE1 = IPALA(J,7)
c              SEGACT, MLREE1
             DO IJ = 1,JG
               LAMBD(IJ) = MLREE1.PROG(IJ)
             ENDDO
             MLREE2 = IPALA(J,4)
             MLREE3 = IPALA(J,8)
c              SEGACT, MLREE2,MLREE3
c *            Nombre de termes fixe, a generaliser si besoin.            
c              JG = 2
*            tentative de generalisation
             JG = MLREE2.PROG(/1)
             DO IJ = 1,JG
               AiDi(IJ) = MLREE2.PROG(IJ)
               Di(IJ)   = MLREE3.PROG(IJ)
             ENDDO
c              SEGDES,MLREE1,MLREE2,MLREE3     
             CALL HBMZZF(NT,NDDL,OMEG,AiDi,Di,LAMBD,VCTCS,ZZ)
            ENDIF
          ENDDO
        ENDIF
        
*------ Calcul du residu initial ---------------------------------------
*       (lie a la prediction par exemple)
        its=0
        CALL funcv(NT,NHBM,NDDL,NFFT,MTQ,MTKAM,MTPHI,MTLIAA,
     &         MTLIAB,MTPAS,MTFEX,LOCLFA,LOCLB1,JANAL2,fvec,fref0,NNM)
     
        IF (IIMPI.GE.2) THEN
          Q1NRM2=dnrm2(NT,Q1,1)
          res=dnrm2(NT,fvec,1)/fref0
          WRITE(IOIMP,990) its,OMEG,Q1NRM2,res,fref0,DS
c           IF (IIMPI.GE.333) THEN
c           WRITE(IOIMP,111) 'Q',its,(Q1(iou),iou=1,NT)
c           WRITE(IOIMP,111) 'R',its,(fvec(iou),iou=1,NT)
c c           do iou=1,NT
c c             WRITE(IOIMP,111) 'ZZ_',iou,(ZZ(iou,jou),jou=1,NT)
c c           enddo
c           ENDIF
        ENDIF
     
     
*============================= Iterations ==============================      
        DO its=1,ITERMAX 
        
        
*    ----- DIFFICULTE A CONVERGER : ON RELAXE (test non concluant) ----
c            IF (its .GT. 10) THEN
c              RELAX=0.222d0             
c            ENDIF

*    ----- CALCUL DE LA JACOBIENNE : dR/dX = Z(OMEGA) - dFNLdX ----
           DO J=1,NT
           DO I=1,NT
                 RX(I,J) = ZZ(I,J)-JAC(I,J)
           ENDDO 
           ENDDO
c            IF (IIMPI.GE.333)  THEN 
c              DO iou=1,NT
c                WRITE(IOIMP,111) 'RX_',iou,(RX(iou,jou),jou=1,NT)
c              ENDDO
c            ENDIF
           
*    ----- CAS 1: INITIALISATION (systeme force) ------------------
           IF (TYPC.EQ.'IF') THEN
*           Calcul de la correction dX, telle que: Rx*dX = R
*           Appel a "DGESV" (LAPACK)
            CALL DGESV(NT,1,RX,NT,IPIV,fvec,NT,INFO)
            DO M = 1,NT
               Q1(M) = Q1(M)-fvec(M)
            ENDDO
c             IF (IIMPI.GE.333)
c      &      WRITE(IOIMP,111) 'dQ^',its,(fvec(iou),iou=1,NT)
c           si on souhaite verifier la convergence en correction dX
c           res=dnrm2(NT,fvec,1)/dnrm2(NT,Q1,1)               
           ENDIF    
           
*    ----- CAS 2: CONTINUATION (systeme force) --------------------
           IF (TYPC.EQ.'CF') THEN    
*           Calcul de la correction dY, telle que: Ja*dY = {R,0}
*           avec Ja la Jacobienne augmentee: Ja = {RX,Rw;dX,dw}
            DO JJ=1,NT
            DO II=1,NT
                Ja(II,JJ) = RX(II,JJ)
            ENDDO
            ENDDO
*           Calcul de la derivee: R,w = dR/dw 
            CALL HBMRW(NT,NDDL,1,Q1,OMEG,XM,XASM,XK,Rw,.true.)
*           cas Granger-Paidoussis : R,w = R,w - dFf/dw 
            DO J = 1,IPALA(/1)
              IF (IPALA(J,1).EQ.5 .AND. IPALA(J,3).EQ.101) THEN
                VCTCS(4) = VV
                CALL HBMRWF(NT,NDDL,OMEG,Q1,AiDi,Di,LAMBD,VCTCS,Rw)     
              ENDIF
            ENDDO
c           cas d'un balourd : force en OMEG**2 a deriver aussi
            IF (BAL.EQ.1) THEN
              DO I=1,NT
                Rw(I) = Rw(I) - TWO*OMEG*FEXA(I)
              ENDDO
            ENDIF
            DO KK = 1,NT
                Ja(KK,NT+1) = Rw(KK)
                Ja(NT+1,KK) = dX(KK)
ctest -> nechange rien :  Ja(NT+1,KK) = DS*dX(KK)
ctest                Ja(NT+1,KK) = (Q1(KK)-QOLD(KK))
                RHS(KK) = fvec(KK)
cdebug
c             if(OMEG.gt.0.153.and.OMEG.lt.0.170) 
c      &      
c               write(*,123) KK,(Ja(KK,iou),iou=1,6),RHS(KK)
            ENDDO
            Ja(NT+1,NT+1) = dw
ctest -> nechange rien :      Ja(NT+1,NT+1) = DS*dw
ctest            Ja(NT+1,NT+1) = OMEG-OMEGOLD
            RHS(NT+1) = ZERO
c             if(OMEG.gt.0.153.and.OMEG.lt.0.170) 
c      &      
c             write(*,123) NT+1,(Ja(NT+1,iou),iou=1,6),RHS(NT+1)
*           Appel a "DGESV" (LAPACK)
            CALL DGESV(NT+1,1,Ja,NT+1,IPIV2,RHS,NT+1,INFO)
            DO MM = 1,NT
c                Q1(MM) = Q1(MM) - RELAX*RHS(MM)
               Q1(MM) = Q1(MM) - RHS(MM)
            ENDDO
c             OMEG = OMEG - RELAX*RHS(NT+1)
            OMEG = OMEG - RHS(NT+1)
            CALL HBMZ(NT,NHBM,NDDL,MTQ,MTKAM,.true.)  
c           si on souhaite verifier la convergence en correction dX
c             res=dnrm2(NT,RHS,1)/dnrm2(NT,Q1,1) 
c             write(*,*) 'W,Q1=',OMEG,(Q1(iou),iou=1,NT)
           ENDIF
           
*    ----- CAS 3: INITIALISATION (systeme autonome) --------------
           IF (TYPC.EQ.'IA') THEN
*          Calcul de la correction dY, telle que: Ja*dY = -[R;g]
*          avec: Ja = [Rx Rw; gx 0]  
            DO II=1,NT
              DO JJ = 1,NT
                Ja(II,JJ) = RX(II,JJ)
              ENDDO
            ENDDO
            VV = VCTCS(4)
*           Calcul de la derivee: Rw = dR/dw 
            CALL HBMRW(NT,NDDL,1,Q1,OMEG,XM,XASM,XK,Rw,.true.)         
*           cas Granger-Paidoussis : R,w = R,w - dFf/dw 
            DO J = 1,IPALA(/1)
              IF (IPALA(J,1).EQ.5 .AND. IPALA(J,3).EQ.101) THEN
               CALL HBMRWF(NT,NDDL,OMEG,Q1,AiDi,Di,LAMBD,VCTCS,Rw)     
              ENDIF
            ENDDO
            DO KK = 1,NT
              Ja(KK,NT+1) = Rw(KK)
              RHS(KK) = fvec(KK)
            ENDDO
*           Condition de phase 
*           On impose une vitesse nulle au 1er DDL en t = 0:
*           dx1(0) = 0 ==> sum_i{i*Q1_si} = 0
            RHS(NT+1) = ZERO 
            DO I = 1,NT+1
              Ja(NT+1,I) = ZERO
            ENDDO
            DO JJ = 2,2*NHBM,2
              Ja(NT+1,JJ*NDDL+1) = JJ/TWO
*              RHS(NT+1)  = RHS(NT+1) + (JJ/TWO)*Q1(JJ*NDDL+1)
            ENDDO
c           si on souhaite verifier la convergence en correction dX
c             res=dnrm2(NT,RHS,1)              
            Ja(NT+1,NT+1) = ZERO        
            CALL COPYMAT(NT+1,Ja,J2) 
*           Appel a "DGESV" (LAPACK)
            CALL DGESV(NT+1,1,J2,NT+1,IPIV2,RHS,NT+1,INFO)
            DO M = 1,NT
               Q1(M) = Q1(M)-RHS(M)
            ENDDO
            OMEG = OMEG-RHS(NT+1)
            CALL HBMZ(NT,NHBM,NDDL,MTQ,MTKAM,.true.) 
*           cas Granger-Paidoussis : rajouter raideur de couplage
            DO J = 1,IPALA(/1)
              IF (IPALA(J,1).EQ.5 .AND. IPALA(J,3).EQ.101) THEN
               CALL HBMZZF(NT,NDDL,OMEG,AiDi,Di,LAMBD,VCTCS,ZZ)    
              ENDIF
            ENDDO
           ENDIF
           
*    ----- CAS 4: CONTINUATION (systeme autonome) -----------------
           IF (TYPC.EQ.'CA') THEN  
*    Calcul de la correction dY, telle que: Jaa*dY = -[R;g;0]
*    avec Jaa la Jacobienne augmentee: Jaa ={RX,Rw,Ra;gx,0,0;dX,dw,da}
            DO II=1,NT
              DO JJ = 1,NT
                Jaa(II,JJ) = RX(II,JJ)
              ENDDO
            ENDDO
*           Calcul de la derivee: Rw = dR/dw 
            CALL HBMRW(NT,NDDL,1,Q1,OMEG,XM,XASM,XK,Rw,.true.) 
*           cas Granger-Paidoussis : R,w = R,w - dFf/dw 
            DO J = 1,IPALA(/1)
              IF (IPALA(J,1).EQ.5 .AND. IPALA(J,3).EQ.101) THEN
                VCTCS(4) = VV
                CALL HBMRWF(NT,NDDL,OMEG,Q1,AiDi,Di,LAMBD,VCTCS,Rw)     
              ENDIF
            ENDDO 
            DO I = 1,NT+2
              Jaa(NT+2,I) = ZERO
            ENDDO
*           Calcul de la derivee : R,Vmoy = dR/dVmoy
            CALL HBMRV(NT,NDDL,OMEG,Q1,AiDi,Di,LAMBD,VCTCS,Ra)         
            DO KK = 1,NT
                Jaa(KK,NT+1) = Rw(KK)
                Jaa(KK,NT+2) = Ra(KK)
                Jaa(NT+2,KK) = dX(KK)
                Jaa(NT+1,KK) = ZERO
                RHS2(KK) = fvec(KK)    
            ENDDO
            Jaa(NT+2,NT+1) = dw
            Jaa(NT+2,NT+2) = dv
*           Condition de phase 
*           On impose une vitesse nulle au 1er DDL en t = 0:
*           dx1(0) = 0 ==> g(Q) = sum_i{i*Q1_si} = 0
*           dg/dw
            Jaa(NT+1,NT+1) = ZERO
*           dg/dv
            Jaa(NT+1,NT+2) = ZERO
            RHS2(NT+1) = ZERO 
            DO JJ = 2,2*NHBM,2
              Jaa(NT+1,JJ*NDDL+1) = JJ/2
              RHS2(NT+1)  = RHS2(NT+1) + (JJ/2)*Q1(JJ*NDDL+1)
            ENDDO
            RHS2(NT+2) = ZERO
*            RHS2(NT+2) = ZERO
*            WRITE(*,*) 'RHS2=',(RHS2(IOU),IOU=1,NT+2)
*            STOP
            CALL COPYMAT(NT+2,Jaa,Ja2) 
*           Appel a "DGESV" (LAPACK)
            CALL DGESV(NT+2,1,Ja2,NT+2,IPIV3,RHS2,NT+2,INFO)
c           si on souhaite verifier la convergence en correction dX
c             res=dnrm2(NT+1,RHS2,1) 
c             WRITE(*,*) 'res=',res
*            WRITE(*,*) 'RHS2=',(RHS2(IOU),IOU=1,NT+2)        
            DO M = 1,NT
               Q1(M) = Q1(M)-RHS2(M)
            ENDDO
            OMEG = OMEG-RHS2(NT+1)
            VV   = VV  -RHS2(NT+2)
            CALL HBMZ(NT,NHBM,NDDL,MTQ,MTKAM,.true.)  
            DO J = 1,IPALA(/1)
              IF (IPALA(J,3).EQ.101) THEN
               VCTCS(4) = VV
               XPALA(J,4) = VV
               CALL HBMZZF(NT,NDDL,OMEG,AiDi,Di,LAMBD,VCTCS,ZZ)    
               ENDIF
            ENDDO      
           ENDIF
           
*    ----- CAS 5: INITIALISATION (systeme Hamiltonien) --------------
           IF (TYPC.EQ.'IN') THEN
*          Calcul de la correction dY, telle que: Ja*dY = -[R;g]
*          avec: Ja = [Rx Rw; gx 0]  
            DO II=1,NT
              DO JJ = 1,NT
                Ja(II,JJ) = RX(II,JJ)
              ENDDO
            ENDDO
*           Calcul de la derivee: Rw = dR/dw 
            CALL HBMRW(NT,NDDL,1,Q1,OMEG,XM,XASM,XK,Rw,.false.)
            DO KK = 1,NT
              Ja(KK,NT+1) = Rw(KK)
              RHS(KK) = fvec(KK)
            ENDDO
*           Condition d'energie
*           On initialise en imposant un certain niveau d'energie,
*           i.e. on fixe la norme de Q1
            RHS(NT+1) = 0.5*(DDOT(NT,Q1,1,Q1,1))-XPARA
cbp    <=>  RHS(NT+1) = -0.5*(DDOT(NT,Q1,1,Q1,1)) 
c           car XPARA=DDOT(Q1)=sqrt(Energie_initiale) dans hbmalo
cbp : incoherence avec calcul energie realise dans hbmco3
c             RHS(NT+1) = DDOT(NT,Q1,1,Q1,1)-XPARA**2
            DO I = 1,NT
              Ja(NT+1,I) = Q1(I)
            ENDDO
c           si on souhaite verifier la convergence en correction dX
            res=dnrm2(NT+1,RHS,1)              
            Ja(NT+1,NT+1) = ZERO        
*            CALL COPYMAT(NT+1,Ja,J2) 
*           Appel a "DGESV" (LAPACK)
            CALL DGESV(NT+1,1,Ja,NT+1,IPIV2,RHS,NT+1,INFO)
            DO M = 1,NT
               Q1(M) = Q1(M)-RHS(M)
            ENDDO
            OMEG = OMEG-RHS(NT+1)
            CALL HBMZ(NT,NHBM,NDDL,MTQ,MTKAM,.false.) 
           ENDIF
           
*    ----- CAS 6: CONTINUATION (systeme Hamiltonien) -----------------
           IF (TYPC.EQ.'CN') THEN  
*          Calcul de la correction dY, telle que: Jaa*dY = -[R;g;0]
*          avec Jaa la Jacobienne augmentee: 
*                       Jaa ={RX,Rw,Ra;gx,0,0;dX,dw,0}
*          Ici, 'a' est un parametre artificiel qui ferme le probleme
*          initialement sous-contraint.
            DO II=1,NT
              DO JJ = 1,NT
                Jaa(II,JJ) = RX(II,JJ)
              ENDDO
            ENDDO
*           Calcul de la derivee: Rw = dR/dw 
            CALL HBMRW(NT,NDDL,1,Q1,OMEG,XM,XASM,XK,Rw,.false.)
*           Calcul de la derivee : Ra= (LoI)*X
            CALL HBMDVEC(NT,NHBM,NDDL,Q1,1.D0,Ra)  
            DO KK = 1,NT
                Jaa(KK,NT+1) = Rw(KK)
                Jaa(KK,NT+2) = Ra(KK)
                Jaa(NT+2,KK) = dX(KK)
                RHS2(KK) = fvec(KK)    
            ENDDO
            Jaa(NT+2,NT+1) = dw
            Jaa(NT+2,NT+2) = ZERO
*           Condition de phase 
*           On minimise la variation de phase entre deux pas succesifs
*           (condition integrale)
*           dg/dw
            Jaa(NT+1,NT+1) = ZERO
*           dg/da
            Jaa(NT+1,NT+2) = ZERO
            CALL HBMDVEC(NT,NHBM,NDDL,QOLD,-1.D0,gx)  
            DO JJ = 1,NT
              Jaa(NT+1,JJ) = gx(JJ)
            ENDDO
            RHS2(NT+1)  = DDOT(NT,gx,1,Q1,1)
            RHS2(NT+2)  = ZERO
*            RHS2(NT+1) = ZERO
*            RHS2(NT+2) = ZERO
*            WRITE(*,*) 'RHS2=',(RHS2(IOU),IOU=1,NT+2)
*            STOP
            CALL COPYMAT(NT+2,Jaa,Ja2) 
            res=dnrm2(NT+2,RHS2,1) 
*           Appel a "DGESV" (LAPACK)
            CALL DGESV(NT+2,1,Ja2,NT+2,IPIV3,RHS2,NT+2,INFO)
c           si on souhaite verifier la convergence en correction dX
*            res=dnrm2(NT+2,RHS2,1) 
c             WRITE(*,*) 'res=',res
*            WRITE(*,*) 'RHS2=',(RHS2(IOU),IOU=1,NT+2)        
            DO M = 1,NT
               Q1(M) = Q1(M)-RHS2(M)
            ENDDO
            OMEG = OMEG-RHS2(NT+1)
            CALL HBMZ(NT,NHBM,NDDL,MTQ,MTKAM,.false.)    
           ENDIF
           
*    ----- EVALUATION DU RESIDU -----------------------------------
           CALL funcv(NT,NHBM,NDDL,NFFT,MTQ,MTKAM,MTPHI,MTLIAA,
     &           MTLIAB,MTPAS,MTFEX,LOCLFA,LOCLB1,JANAL2,fvec,fref,NNM) 
     
*          residu relatif (calcule autrement dans le cas NNM)
           IF (TYPC(2:2).NE.'N') THEN
             res=dnrm2(NT,fvec,1)/fref0
           ENDIF
           
           IF (IIMPI.GE.2) THEN
             Q1NRM2=dnrm2(NT,Q1,1)
c              IF (IIMPI.GE.333) THEN 
c              WRITE(IOIMP,111) 'Q^',its,(Q1(iou),iou=1,NT)
c              WRITE(IOIMP,111) 'R^',its,(fvec(iou),iou=1,NT)
c              ENDIF
             WRITE(IOIMP,999) its,OMEG,Q1NRM2,res
           ENDIF
     
           
*    ----- TEST DE CONVERGENCE ------------------------------------
           ITER = its
           IF (res.LE.TOLMIN) THEN             
             check=.false.
c            Calcul de la Jacobienne pour la solution convergee
             CALL HBMZ(NT,NHBM,NDDL,MTQ,MTKAM,.not.NNM)
             DO J = 1,IPALA(/1)
               IF (IPALA(J,1).EQ.5 .AND. IPALA(J,3).EQ.101) THEN
                 VCTCS(4) = VV
                 XPALA(J,4) = VV
                 CALL HBMZZF(NT,NDDL,OMEG,AiDi,Di,LAMBD,VCTCS,ZZ)
               ENDIF
             ENDDO             
             DO J=1,NT
             DO I=1,NT
                RX(I,J) = ZZ(I,J) - JAC(I,J)
             ENDDO         
             ENDDO                    
             KTQ = MTQ
             KTEMP=MTEMP
             RETURN
           ELSE
            check = .true.
           ENDIF
           
        ENDDO 
*====== FIN DES ITERATIONS =============================================


*=======================================================================
*       Mise en forme des messages
*=======================================================================  
 990    FORMAT(' + newt : ',I3,'  w=',F9.5,' |Q|=',F9.5,' |R|=',E10.3,
     &         ' |ref|=',E10.3,' ds=',F9.5)
 999    FORMAT(' + newt : ',I3,'  w=',F9.5,' |Q|=',F9.5,' |R|=',E10.3)
cdebug
c  123    FORMAT('Ja(',I2,',1:8)=',6(E10.3E1,1X),'... F=',E9.3E1)
 123    FORMAT('Ja(',I2,',1:6)=',6(E10.3,1X),'... F=',E10.3)
c  111    FORMAT(A,I2,'=',11(1X,F10.6))

       END               
 
 
 
 
