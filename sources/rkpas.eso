C D2VPAS    SOURCE    BP208322  20/09/18    21:15:19     10718          
c
      SUBROUTINE RKPAS(Q1,Q2,Q3,NA1,NPC1,XK,XASM,XM,PDT,T,NPAS,
     &   FTOTA,FEXA,NPFEXA,NLIAA,NLSA,IPALA,IPLIA,XPALA,XVALA,
     &   NLIAB,NLSB,NPLB,IDIMB,IPALB,IPLIB,JPLIB,XPALB,XVALB,FTOTB,
     &   FTOTBA,XPTB,FEXPSM,
     &   FINERT,IERRD,FTEST,FTEST2,WEXT,WINT,
     &   XABSCI,XORDON,NIP,FTEXB,FEXB,KTROT,KTPHI,XCHPFB,
     &   XOPM1,NB1,NB1K,NB1C,NB1M,nn2,nnsb,nndef) 
     
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*                                                                    *
*     Op�rateur DYNE : algorithme des DIFFERENCES CENTREES           *
*     ________________________________________________               *
*                                                                    *
*     Calcul d'un pas de temps, appel aux s-p sp�cifiques.           *
*                                                                    *
*     Param�tres:                                                    *
*                                                                    *
* es  Q1(,)   Vecteur des d�placements g�n�ralis�s                   *
* es  Q2(,)   Vecteur des vitesses g�n�ralis�es                      *
* es  Q3(,)   Vecteur des acc�l�rations g�n�ralis�es                 *
* es  NA1     Nombre total d'inconnues en base A                     *
* es  NPC1    Nombre de pas de calcul - 1                            *
* es  XK      Vecteur des raideurs g�n�ralis�es                      *
* es  XASM    Vecteur des amortissements g�n�ralis�s                 *
* es  XM      Vecteur des masses g�n�ralis�es                        *
* e   PDT     pas de temps courant                                   *
* e   T       temps courant                                          *
* e   NPAS    Num�ro du pas de temps                                 *
* es  FTOTA   Forces ext�rieures totalis�es, sur la base A           *
* es  FEXA    Evolution des forces ext�rieures en base A             *
* e   FTEXB   Evolution des forces ext�rieures en base B             *
* e   FEXB    Forces ext�rieures sur la base B, servant au calcul    *
*             des moments pour les corps rigides.                    *
* e   RIGIDE  Vrai si corps rigide, faux sinon                       *
* es  IFEXA   Num�ro du mode correspondant au point de chargement    *
*             (supprime le 2018-12-14 par bp)                        *
* es  NPFEXA  Nombre de points de chargement                         *
* e   NLIAA   Nombre de liaisons sur la base A                       *
* e   NLSA    Nombre de liaisons A en sortie                         *
* e   IPALA   Tableau renseignant sur le type de liaison (base A)    *
* e   IPLIA   Tableau contenant les num�ros "DYNE" des points        *
* e   XPALA   Tableau contenant les param�tres des liaisons          *
* es  XVALA   Tableau contenant les variables internes de liaison A  *
*     XPHILB  Vecteur des deformees modales                          *
* e   NLIAB   Nombre de liaisons sur la base B                       *
* e   NLSB    Nombre de liaisons base B en sortie                    *
* e   NPLB    Nombre total de points de liaisons (base B)            *
* e   IDIMB   Nombre de directions                                   *
* e   IPALB   Tableau renseignant sur le type de liaison             *
* e   IPLIB   Tableau contenant les numeros "DYNE" des points        *
* e   JPLIB   Tableau contenant les numeros "GIBI" des points        *
* e   XPALB   Tableau contenant les parametres des liaisons (base B) *
* es  XVALB   Tableau contenant les variables internes de liaison B  *
*     FTOTB   Forces exterieures totalisees sur la base B            *
* e   XABSCI  Tableau contenant les abscisses de la loi plastique    *
* e   XORDON  Tableau contenant les ordonnees de la loi plastique    *
* e   NIP     Nbr de points dans l'evolution de la loi plastique     *
*     FTOTBA  Forces totales base B projetees base A                 *
*     XPTB    Deplacements des points de liaison                     *
*     IBASB   Appartenance des points de liaison a une sous-base     *
*     IPLSB   Position du point de liaison dans la sous-base         *
*     INMSB   Nombre de modes dans la sous-base                      *
*     IORSB   Position du 1er mode de la sous-base dans ens. modes   *
*     IAROTA  Indique la position des modes de rotation              *
*     NSB     Nombre de sous-bases                                   *
*     NPLSB   Nombre de points de liaison par sous-base              *
*     NA2     Nombre d'inconnues dans la sous-base                   *
*     FEXPSM  Pseudo-Modes base B                                    *
*     FINERT  Forces d'inertie base B                                *
*     IERRD   Indicateur d'erreur                                    *
* -   FTEST   Tableau local FTEST de la subroutine D2VLFA            *
* -   FTEST2  Tableau local FTEST de la subroutine DEVLB1            *
* e,s WEXT   travail des forces exterieures                          *
* e,s WINT   travail des forces interieures (rigidite et             *
*            amortissement et forces de liaison )                    *
*                                                                    *
*     fmomtot : couple exterieur dans le body frame pour la phase rk4!!
*--------------------------------------------------------------------*
*
-INC CCREEL
*
      SEGMENT,MTPHI
         INTEGER IBASB(NPLB),IPLSB(NPLB),INMSB(NSB),IORSB(NSB)
         INTEGER IAROTA(NSB)
         REAL*8 XPHILB(NSB,NPLSB,NA2,IDIMB)
      ENDSEGMENT
      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EPOT(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XTPHIN(3,NPDEF,NA2,NSB),XMNO(NA2,NSB)
         REAL*8 XMPOI(NPDEF,NA2,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT
      
*
*      INTEGER IFEXA(*),IPALA(NLIAA,*),IPLIA(NLIAA,*)
      INTEGER IPALA(NLIAA,*),IPLIA(NLIAA,*)
      INTEGER IPALB(NLIAB,*),IPLIB(NLIAA,*),JPLIB(*)
      REAL*8 Q1(NA1,*),Q2(NA1,*),Q3(NA1,*)
* Matt: ligne parmetres corps rigide:
      REAL*8 DYN2(3),DQUAT(4)
*
      REAL*8 XVALA(NLIAA,4,*),XPALA(NLIAA,*),XM(NA1,*),XK(NA1,*)
      REAL*8 XPALB(NLIAB,*),XVALB(NLIAB,4,*),FEXPSM(NPLB,NPC1,2,*)
      REAL*8 XASM(NA1,*),FTOTA(NA1,*),FEXA(NPFEXA,NPC1,*)
      REAL*8 FTOTB(NPLB,*),FTOTBA(*),XPTB(NPLB,2,*),FINERT(NA1,*)
      REAL*8 WEXT(NA1,2),WINT(NA1,2)
      REAL*8 XABSCI(NLIAB,*),XORDON(NLIAB,*),FEXB(NPLB,3,*)
      REAL*8 FTEST(NA1,4), FTEST2(NPLB,6)
      REAL*8 FTEXB(NPLB,NPC1,2,*),XCHPFB(2,NLIAB,4,NPLB)
cbp,2020-09      REAL*8 XOPM1(NB1,NB1,*),Q2DEMI(NA1),FAMOR(NA1)
      REAL*8 XOPM1(NB1,NB1,*),FAMOR(NA1)
      
*     TODO : KTOTXA et KTOTVA a allouer dans le segment LOCLFA ?
      REAL*8 KTOTXA(NA1,NA1), KTOTVA(NA1,NA1) 
*     TODO : KTOTXB et KTOTVB a allouer dans le segment LOCLFB ?
      REAL*8 KTOTXB(NPLB,IDIMB,IDIMB),KTOTVB(NPLB,IDIMB,IDIMB) 
*
c     LOGICAL LWRITE
      LOGICAL RIGIDE,lxpinv,linert,methJ1,methJ2
* CMS : 
      REAL*8 FAMO1(NA1),FAMO2(NA1)
cms : pour le couple resistant "hard code" : 
      real*8 tspin(3)
*     pour le calcul des forces d'inerties :
      real*8 chxcg(3,3),chmst(3,3)
      logical lrspin
*     vecteurs de rotations incrementaux :
      real*8 th1(3), th2(3), th3(3), th4(3), jw2(3), t2(3)
      real*8 dexpinv(3,3)
*     matrices pour la matrice de masse si couplage inertiel :
      real*8 Xt(3),Xtcha(3,3),B(nn2,nndef,3,3),ntat(nn2,nndef,3)
      real*8 mrth(3,3),mthr(3,3),mfr(nn2,3),mrf(3,nn2)
      real*8 mfth(nn2,3),mthf(3,nn2)
      real*8 mthth(3,3,nnsb),xnorm(nn2)
      real*8 Xt2(3),Xt2cha(3,3)
      real*8 fer(3,4,nnsb),feth(3,4,nnsb),fef(nn2,4,nnsb)
      real*8 fr(3,nnsb),fth(3,nnsb),ff(nn2,nnsb)
      real*8 jw(3),rtgex(3),qf(nn2,nnsb),qr(3,nnsb),qth(3,nnsb)
      real*8 qr2(3,nnsb),qth2(3,3,nnsb)
      real*8 wchap(3,3),wchap2(3,3),ine(3,3),invine(3,3)

*     resistance au spin ?
      lrspin = .false.
*     correction dexpinv ?
      lxpinv = .false.
*     couplage inertiel ?
      linert = .true.
*     method de calcul de la MAJ du tenseur d'inertie J ?
      methJ1 = .false.
      methJ2 = .true.
*     le cas echeant, base modale de l'adaptateur : 
      ibad = 1

      RIGIDE = (KTROT.NE.0)
      IF (RIGIDE) THEN
        MTROT = KTROT
        npdef = xtphi(/2)
      ENDIF
      MTPHI  = KTPHI
      NSB = XPHILB(/1)
      NPLSB = XPHILB(/2)
      NA2 =  XPHILB(/3)
*      IF (IIMPI.EQ.555) THEN 
cmsw        WRITE(*,*)'D2VPAS: KTROT = ',KTROT
cmsw        WRITE(*,*)'        RIGIDE = ',RIGIDE
cmsw        WRITE(*,*)'        NSB =',NSB
cmsw        WRITE(*,*)'        IDIMB = ',IDIMB
cmsw        WRITE(*,*)'        NLIAA = ',NLIAA
cmsw        WRITE(*,*)'        NLIAB = ',NLIAB
*      ENDIF
* Calcul de IDIM pour le calcul de l energie cinetique :
      IF (IDIMB.EQ.6) THEN
        IDIM=3
      ELSEIF (IDIMB.EQ.3) THEN
        IDIM=2
      ENDIF
C     Parametres d'affichage (pour debuggage) 
c     LWRITE=.false.
c     LWRITE=(NPAS.LE.20).OR.(MOD(NPAS,1000).EQ.0)
c     if(LWRITE) write(*,*) '-------- NPAS =',NPAS

************************************************************************
*     Parametres temporels locaux
************************************************************************
      tdeb = T
      tfin = T + PDT
      dt = PDT
      dt2 = dt/2.D0
      dt22 = dt*dt2

*     write(*,*)'rkpas : indice 5 :'
*     write(*,*)'        mat. inertie :'
*     do id=1,3
*        write(*,'(3(1X,F8.5))') , (inertie(id,j,1),j=1,3)
*     enddo
*     write(*,*)'         omeg2 :'
*     WRITE(*,'(3(1X,F8.5))')((omeg2(id,5,1),id=1,3),isb=1,nsb)
*     write(*,*)'         omeg3 :'
*     WRITE(*,'(3(1X,F8.5))')((omeg3(id,5,1),id=1,3),isb=1,nsb)
************************************************************************
*     remplissage de fexb(ip,1,id) et ftota(i,1) : "les deux extremites du pas de temps"
************************************************************************
*     pas de conditoin sur l'appel a d2vfxa.
      CALL RKFXA(FEXA,FTOTA,NPFEXA,NA1,NPC1,NPAS,FTEXB,FEXB,
     &              NPLB,IDIMB,RIGIDE)
*      write(*,*)'rkpas : fexb :'
*      write(*,'(3(1X,F8.5))') , ((fexb(ip,3,j),j=1,3),ip=1,nplb)
*      write(*,*)'rkpas : ftota :'
*      do i=1,na1
*      write(*,'(3(1X,F8.5))') , (ftota(i,ind1),ind1=1,3)
*      enddo
*      write(*,*)'rkpas : finert :'
*      do i=1,na1
*      write(*,'(1X,F8.5)') , finert(i,1)
*      enddo
* ddls elastiques :  
*      do in=1,npfexa 
**        fel(in,3) = ftota(in,2)
**       force au demi-pas de temps :
*        fel(in,2) = fota(in,2) + ((ftota(in,1) - ftota(in,2))/2.d0)
*        fel(in,2) = 
*      enddo
      
************************************************************************
*     todo : ici : l'interpolation des forces exterieures
************************************************************************

************************************************************************
*     Corps rigides: prediction, MAJ matrice de rotation
************************************************************************
* TODO dans D2VINI / DYNE18: initialisation de toutes les ss bases
* pour l'instant, seulement 1 seule ss base inititalisee
     
*      
      IF (RIGIDE) THEN
        NSB = ROT(/4)
        DO 7 IIB=1,NSB
CMS :     Rotas rigides ssi il y a une grande rota ds la ss base en question !!
cmsw          WRITE(*,*)'D2VPAS : IAROTA(',IIB,') = ',IAROTA(IIB)
          IF (IAROTA(IIB).EQ.0) GOTO 7
*         mise a 0 des couples ext. :
          do id=1,3
            fmomtot(id,1,iib) = 0.d0
            fmomtot(id,2,iib) = 0.d0
            fmomtot(id,3,iib) = 0.d0
            fmomtot(id,4,iib) = 0.d0
            fmomtot(id,5,iib) = 0.d0
          enddo
*         th1 correspond au plan tangent en t_n --> on y est deja!
          do id=1,3
            th1(id) = 0.d0
          enddo
************************************************************************
*         k1 = (w1,a1)^T avec :
*           - w1 = omeg2(id,5,iib)
*           - a1 = omeg3(id,5,iib)
************************************************************************
*          u2 = (th2,w2) = y + dt2*k1 : 
************************************************************************
          do id=1,3
            th2(id) = omeg2(id,5,iib) * dt2
            omeg2(id,4,iib)  = omeg2(id,5,iib) + omeg3(id,5,iib) * dt2
          enddo

************************************************************************
*          calcul de EXPTH pour eq. dynamique:
          CALL VECT2QUAT(TH2(1),DQUAT)
*          MAJ quaternion OMEG1:
          CALL PQUAT(OMEG1(1,5,IIB),DQUAT,OMEG1(1,4,IIB))
*          quaternion a l'instant tn+1:
          CALL QUAT2MAT(OMEG1(1,4,IIB),ROT(1,1,4,IIB)) 

*          write(*,*)'rkpas : rot 1st pred : indice 4'
*          do id=1,3
*              write(*,'(3(1X,F8.5))') , (rot(id,j,4,iib),j=1,3)
*          enddo

*          equilibre dynamique : 1/2 pdt --> ifex = 3
          call rkpasrig(omeg1,omeg2,omeg3,rot,inertie,invinert,nsb,iib,
     &                  th2,fmomtot,xcoolb,fexb,nplb,4,3,lxpinv,.true.)

************************************************************************
*         "rappatriement" sur le plan tangent en t_n de :
*           - du vecteur de rotation thi, i = 1,
*           - du vecteur de rotation
************************************************************************
*         k2 = (w2,a2)^T avec :
*           - w2 = omeg2(id,4,iib)
*           - a2 = omeg3(id,4,iib)
************************************************************************
*          u3 = (th3,w3) = y + dt2*k2 : 
************************************************************************
          do id=1,3
            th3(id) = omeg2(id,4,iib) * dt2
            omeg2(id,3,iib)  = omeg2(id,5,iib) + omeg3(id,4,iib) * dt2
          enddo
************************************************************************
*          calcul de EXPTH pour eq. dynamique:
          CALL VECT2QUAT(TH3(1),DQUAT)
*          MAJ quaternion OMEG1:
          CALL PQUAT(OMEG1(1,5,IIB),DQUAT,OMEG1(1,3,IIB))
*          quaternion a l'instant tn+1:
          CALL QUAT2MAT(OMEG1(1,3,IIB),ROT(1,1,3,IIB)) 
*          equilibre dynamique : 1/2 pdt --> ifex = 3
          call rkpasrig(omeg1,omeg2,omeg3,rot,inertie,invinert,nsb,iib,
     &                  th3,fmomtot,xcoolb,fexb,nplb,3,3,lxpinv,.true.)
************************************************************************
*         k3 = (w3,a3)^T avec :
*           - w3 = omeg2(id,3,iib)
*           - a3 = omeg3(id,3,iib)
************************************************************************
*          u4 = (th4,w4) = y + dt*k2 : 
************************************************************************
          do id=1,3
            th4(id) = omeg2(id,3,iib) * dt
            omeg2(id,2,iib)  = omeg2(id,5,iib) + omeg3(id,3,iib) * dt
          enddo
************************************************************************
*          calcul de EXPTH pour eq. dynamique:
          CALL VECT2QUAT(TH4(1),DQUAT)
*          MAJ quaternion OMEG1:
          CALL PQUAT(OMEG1(1,5,IIB),DQUAT,OMEG1(1,2,IIB))
*          quaternion a l'instant tn+1:
          CALL QUAT2MAT(OMEG1(1,2,IIB),ROT(1,1,2,IIB)) 
*          equilibre dynamique : t_n+1 --> ifex = 1
          call rkpasrig(omeg1,omeg2,omeg3,rot,inertie,invinert,nsb,iib,
     &                  th4,fmomtot,xcoolb,fexb,nplb,2,1,lxpinv,.true.)
************************************************************************
*         k4 = (w4,a4)^T avec :
*           - w4 = omeg2(id,2,iib)
*           - a4 = omeg3(id,2,iib)
************************************************************************
          do id=1,3
            dtheta(id,iib) = (dt/6.d0)*( omeg2(id,5,iib)
     &                                 + 2.d0*omeg2(id,4,iib)
     &                                 + 2.d0*omeg2(id,3,iib)
     &                                 + omeg2(id,2,iib) )
          enddo
*
          CALL VECT2QUAT(DTHETA(1,IIB),DQUAT)
*          MAJ quaternion OMEG1:
          CALL PQUAT(OMEG1(1,5,IIB),DQUAT,OMEG1(1,1,IIB))
*          quaternion a l'instant tn+1:
          CALL QUAT2MAT(OMEG1(1,1,IIB),ROT(1,1,1,IIB)) 
*         maj des vitesses angulaires :
          do id=1,3
            omeg2(id,1,iib) = omeg2(id,5,iib) +
     &                   (dt/6.d0)*( omeg3(id,5,iib) 
     &                             + 2.d0*omeg3(id,4) 
     &                             + 2.d0*omeg3(id,3) 
     &                             + omeg3(id,2)) 
          enddo
******** fin boucle sur les ss bases
 7      continue
      ENDIF
*     fin condition RIGIDE

************************************************************************
*     RK4 : deplacements elastiques 
************************************************************************
*     k1 = (q2(i,5), q3(i,5))^T
*     u2 = y + k1*dt2
************************************************************************
*      write(*,*)'rkpas : indice 5'
*      do i = 1,na1
*      write(*,*)'q1 :',q1(i,5)
*      write(*,*)'q2 :',q2(i,5)
*      enddo

*     write(*,*)'rkpas 1st pred :'
      do i = 1,na1
        q1(i,4) = q1(i,5) + q2(i,5) * dt2
        q2(i,4) = q2(i,5) + q3(i,5) * dt2
*       write(*,*)'q1 :',q1(i,4)
*       write(*,*)'q2 :',q2(i,4)
      enddo
*     1/2 pdt --> ifex = 3
      call rkpasel(q1,q2,q3,xk,xm,ftota,na1,nb1k,nb1c,nb1,famor,
     &             xasm,xopm1,finert,4,3,pdt)
*      write(*,*)'rkpas 1st rkpasel :'
*      do i = 1,na1
*      write(*,*)'q2 :',q2(i,4)
*      write(*,*)'q3 :',q3(i,4)
*      enddo
************************************************************************
*     k2 = (q2(i,4), q3(i,4))^T
*     u3 = y + k2*dt2
************************************************************************
*     write(*,*)'rkpas 2nd pred :'
      do i = 1,na1
        q1(i,3) = q1(i,5) + q2(i,4) * dt2
        q2(i,3) = q2(i,5) + q3(i,4) * dt2
*        write(*,*)'q1 :',q1(i,3)
*        write(*,*)'q2 :',q2(i,3)
      enddo
*     1/2 pdt --> ifex = 3
      call rkpasel(q1,q2,q3,xk,xm,ftota,na1,nb1k,nb1c,nb1,famor,
     &             xasm,xopm1,finert,3,3,pdt)

************************************************************************
*     k3 = (q2(i,3), q3(i,3))^T
*     u4 = y + k3*dt
************************************************************************
*     write(*,*)'rkpas 3rd pred :'
      do i = 1,na1
        q1(i,2) = q1(i,5) + q2(i,3) * dt
        q2(i,2) = q2(i,5) + q3(i,3) * dt
*        write(*,*)'q1 :',q1(i,2)
*        write(*,*)'q2 :',q2(i,2)
      enddo
*     t_n+1 --> ifex = 1
      call rkpasel(q1,q2,q3,xk,xm,ftota,na1,nb1k,nb1c,nb1,famor,
     &             xasm,xopm1,finert,2,1,pdt)
************************************************************************
*     k4 = (q2(i,2), q3(i,2))^T
************************************************************************
      do i=1,na1
*       position :
      q1(i,1)=q1(i,5)+(dt/6.d0)*(q2(i,5) + 2.d0*q2(i,4) + 2.d0*q2(i,3) +
     &                       q2(i,2))
*       vitesse :
      q2(i,1)=q2(i,5)+(dt/6.d0)*(q3(i,5) + 2.d0*q3(i,4) + 2.d0*q3(i,3) +
     &                       q3(i,2))

*      write(*,*)'rkpas avant liaison :'
*      write(*,*)'q1 :',q1(i,1)
*      write(*,*)'q1 :',q1(i,1)
*      write(*,*)'q2 :',q2(i,1)
*      write(*,*)'q2 :',q2(i,1)
      enddo

************************************************************************
*     Calcul des forces de liaisons
************************************************************************
*     Totalisation des forces ext�rieures pour la base A a la fin du pas
        CALL D2VFXA(FEXA,FTOTA,NPFEXA,NA1,NPC1,NPAS,FTEXB,FEXB,
     &              NPLB,IDIMB,RIGIDE)
*     Ajout des forces de liaison
      IF (NLIAA.NE.0) THEN
         CALL D2VLFA(Q1,Q2,FTOTA,NA1,IPALA,IPLIA,XPALA,XVALA,
     &               NLIAA,dt,tfin,NPAS,1,FINERT,0,FTEST,
     &               KTOTXA,KTOTVA,.FALSE.)
      ENDIF
      IF (IIMPI.EQ.333) WRITE(IOIMP,*)'D2VPAS: NLIAB = ',NLIAB
      IF (NLIAB.NE.0) THEN
         IF (IIMPI.EQ.333) THEN
cmsw           WRITE(IOIMP,*)'D2VPAS : appel au sous-programme D2VLFB'
         ENDIF      
*        WRITE(*,*)'rkpas : appel au sous-programme D2VLFB'
*        dernier arg = .false. --> calcul du moment au pas t_n+1 via rkmom
         CALL D2VLFB(Q1,Q2,FTOTA,NA1,IPALB,IPLIB,XPALB,XVALB,NLIAB,
     &               XPHILB,JPLIB,NPLB,IDIMB,FTOTB,FTOTBA,XPTB,dt,tfin,
     &               NPAS,IBASB,IPLSB,INMSB,IORSB,NSB,NPLSB,NA2,1,
     &               FEXPSM,NPC1,IERRD,FTEST2,XABSCI,XORDON,NIP,
     &               FEXB,KTROT,IAROTA,XCHPFB,
     &               KTOTXA,KTOTVA,KTOTXB,KTOTVB,.FALSE.,.false.)
*
         IF (IERRD.NE.0) RETURN
      ENDIF
************************************************************************
*     EquilibreS DynamiqueS (separes)
************************************************************************
* elastique :
************************************************************************
      if (.not.linert) then
        call rkpasel(q1,q2,q3,xk,xm,ftota,na1,nb1k,nb1c,nb1,famor,
     &               xasm,xopm1,finert,1,1,pdt)

*       MAJ vitesse generalisee :
        do in=1,na1
          q2(in,1) = q2(in,5) + (dt/2.d0)*(q3(in,1)+q3(in,5))
        enddo
************************************************************************
* rotas rigides :
************************************************************************
        do 22 iib=1,nsb
        if (iarota(iib).eq.0) goto 22
        call rkpasrig(omeg1,omeg2,omeg3,rot,inertie,invinert,nsb,iib,
     &    dtheta(1,iib),fmomtot,xcoolb,fexb,nplb,1,1,.false.,.false.)
*         MAJ vitesse angulaire :
        do id = 1,3
          omeg2(id,1,iib) = omeg2(id,5,iib) + 
     &                    (dt/2.d0)*(omeg3(id,1,iib)+omeg3(id,5,iib))
        enddo
 22     continue
      endif

************************************************************************
* ROTATIONS RIGIDES: calcul des matrices necessaires au calcul des forces d'inertie 
*     dans le repere spatial --> on prend le quaternion omeg1 (orientation dans le repere spatial).
******************************************************************
      if (linert) then
      if (rigide) then
*       initialisation des forces d'entrainements :
        do iib=1,nsb
            do indi=1,4
              do id=1,3
                fer(id,indi,iib) = 0.d0
                feth(id,indi,iib) = 0.d0
              enddo
              do in=1,na2
                fef(in,indi,iib) = 0.d0
              enddo
            enddo
        enddo

******************************************************************
        do 1 iib=1,nsb
**        na3 : nombre de modes elastiques + translations rig
**              dans la ss base iib.
        na3 = inmsb(iib)
*        premier mode elast ou transl rigi de la sous base iib ds l'ensemble des modes elast + trans rigis
        ina1 = iorsb(iib) - 1
*        initialisation des forces d'inertie, pour ttes les ss bases!
*         --> apparaissent apres dans l'equilibre dynamique
        do id=1,3
          fr(id,iib) = 0.d0
          fth(id,iib) = 0.d0
          qr(id,iib) = 0.d0
          qth(id,iib) = 0.d0
          qr2(id,iib) = 0.d0
          do j=1,3
            qth2(id,j,iib) = 0.d0
          enddo
        enddo
        do in=1,na3
          ff(in,iib) = 0.d0
          qf(in,iib) = 0.d0
        enddo
*       maintenant on peut sauter les ss bases ss rotas rigides :
        if (iarota(iib).eq.0) goto 1
*       do ind1=2,5
        ind1=1
*         calcul des normes des modes au carre :
          xnortot = 0.d0
          do 33 in=1,na3
*           write(*,*)'rkpas : xm(ina1+1,1) = ',xm(ina1+in,iib)
*           test on norme le mode :
            xnorm(in) = 0.d0
            do ip=1,npdef
              do id=1,3
                xnorm(in) = xnorm(in) +
     &          xtphi(id,ip,in,iib)*xtphi(id,ip,in,iib)
              enddo
            enddo
            xnorm(in) = dsqrt(xnorm(in))
            if (xnorm(in).le.xzprec) goto 33
            xnortot = xnortot + (xm(ina1+in,iib)/xnorm(in))
*           write(*,*)'(norme du mode)^2 = ',xnorm(in)
*           write(*,*)'XM / (norme du mode)^2 = ',
*     &                 xm(ina1+in,iib)/xnorm(in)
*           write(*,*)'%age de la masse associee : ',
*     &                100.*(xm(ina1+in,iib)/xnorm(in))/mtsb(iib)
 33       continue
*         write(*,*)'%age de ts les modes : ',100.*(xnortot)/mtsb(iib)
******************************************************************
*         calcul de la matrice B(na2,npdef,3,3) = - rot chap(Xt)
******************************************************************
          do ip=1,npdef
            do in = 1,na3
              i2 = in + ina1
              do id=1,3
                Xt(id) = xcoophi(id,ip,iib) - xcent(id,iib) + 
     &                (xtphi(id,ip,in,iib) * q1(i2,ind1))
              enddo
              call chap(Xt(1),Xtcha(1,1))
              do id=1,3
                do j=1,3
                  B(in,ip,id,j) = 0.d0
                  do k=1,3 
                   B(in,ip,id,j) = B(in,ip,id,j) - 
     &                     rot(id,k,ind1,iib) * Xtcha(k,j)
                  enddo
                enddo
              enddo
            enddo
          enddo
******************************************************************
*     M_{Rth} : couplage rotas-trnaslas shabana p 320
*           B^j = -rot * sum_nodes chap(X_i + u_f_i) ( * A plus tard)
*             - X : coordonnes undeformed state dans le body frame --> XCOOPHI
*             - u_f = q_i phi_i : depl. elastiques body frame, phi_i --> XTPHI
*             - A : acceleration angulaire body frame
*           M_{thR} = sum_modes mu_j * B_j^T
*           M_{Rth} = sum_modes mu_j * B_j
* Rq 1. : la somme des profuits vect sum_i (v_i x A) = (sum_i v_i) x A
*         --> on somme les positions dans le body frame.
* Rq 2. : la fonction chapeau est lineairesa.
******************************************************************
          do id=1,3
            do j=1,3
              mrth(id,j) = 0.d0
              do 10 in=1,na3
                if (xnorm(in).le.xzprec) goto 10
                i2 = ina1 + in
                do ip=1,npdef
                  mrth(id,j) = mrth(id,j) + 
     &            ((xm(i2,1)/xnorm(in)) * B(in,ip,id,j))
                enddo
 10           continue
            enddo
          enddo

*        write(*,*)'MRTH :'
*        do id=1,3
*           write(*,'(3(1X,F8.5))') , (mrth(id,j),j=1,3)
*        enddo
******************************************************************
*     M_{fR} (dim : nmodes x 3) : couplage elas-translas shabana p 320
*          M_{fR} = sum_modes mu_i * Phi^T * rot^T
*          mfr(in,id) = sum_nodes sum_modes (ph_i(node_i)^T) * rot^T
*          considering Phi^T for one node :
*           in is the line, id is the column
          do 11 in=1,na3
*           on saute les translations rigides :
            mfr(in,1) = 0.d0
            mfr(in,2) = 0.d0
            mfr(in,3) = 0.d0
            if (itrig(iib,in)) goto 11
*           pas besoin car xtphi est nul si in correspond a une translation rigide 
*             - d2vini --> xcoophi = 0 partout
*             - filldef --> xcoophi rempli que sur les deformees elastiques.
            i2 = ina1 + in
*           write(*,*)'ntat pour in = ',in
            do j=1,3
              mfr(in,j) = 0.d0
              do ip=1,npdef
                ntat(in,ip,j) = 0.d0 
                if (xnorm(in).le.xzprec) goto 11
                do k=i,3
                 ntat(in,ip,j) = ntat(in,ip,j) + 
     &                           xtphi(k,ip,in,iib)*rot(j,k,ind1,iib) 
                enddo
                mfr(in,j) = mfr(in,j) + ntat(in,ip,j)
              enddo
              mfr(in,j) = (xm(i2,1)/xnorm(in)) * mfr(in,j) 
            enddo
 11       continue

*          write(*,*)'MFR :'
*          do in=1,na3
*             write(*,'(3(1X,F8.5))') , (mfr(in,id),id=1,3)
*          enddo

******************************************************************
*    M_{fth} (dim : nmodes x 3) : couplage elas-rotas shabana p 320
*         M_{fth} = sum_modes mu_i * N^T * rot^T * B^T
*         ntat = N^T * A^T
******************************************************************
          do 12 in=1,na3
            i2 = ina1 + in
            do j=1,3
              mfth(in,j) = 0.d0
              if (xnorm(in).le.xzprec) goto 12
              do ip=1,npdef
                do k=1,3
                  mfth(in,j) = mfth(in,j) + 
     &                                  (ntat(in,ip,k)*B(in,ip,k,j)) 
                enddo
              enddo
              mfth(in,j) = (xm(i2,1)/xnorm(in))*mfth(in,j)
            enddo
 12       continue

*        write(*,*)'MFTH :'
*        do in=1,na3
*           write(*,'(3(1X,F8.5))') , (mfth(in,id),id=1,3)
*        enddo
* pour etre sur : mthf :
          do 24 in = 1,na3
            i2 = in + ina1
            mthf(1,in) = 0.d0
            mthf(2,in) = 0.d0
            mthf(3,in) = 0.d0
            if (xnorm(in).le.xzprec) goto 24
*           pour 1 point :
            do ip=1,npdef
*             on prend ses coord en base A :
              do id=1,3
                mthf(id,in) = 0.d0
                Xt(id) = xcoophi(id,ip,iib) - xcent(id,iib) + 
     &                (xtphi(id,ip,in,iib) * q1(i2,ind1))
              enddo
*             on applique la fonction chapeau :
              call chap(Xt(1),Xtcha(1,1))
*             on multiplie par le mode in en ponderant :
              do id=1,3
                do k=1,3 
                    mthf(id,in) = mthf(id,in) +
     &      ((xtcha(id,k)*xtphi(k,ip,in,iib))*(xm(i2,1)/xnorm(in)))
                enddo
              enddo
            enddo
 24       continue

*       write(*,*)'MTHF :'
*       do in=1,na3
*          write(*,'(3(1X,F8.5))') , (mfth(id,in),id=1,3)
*       enddo
           
******************************************************************
*    M_{thth} (dim : 3 x 3) : modif tenseur d'inertie du aux defo elastiques.
*                          (shabana p 320)
*         on utilise la methode 2 :
*         - comme on ne considere pas forcement bcp de modes, reconstruire un tenseur d'inertie seulement avec la matrice B parait illusoire (perte d'infos).
*         ==> on garde mthth = perturbation due aux modes. en developpant J = chap(X+u)^T * chap(X+u) :
*         perturbation = chap(u_f)^T * (chap(X) + chap(u_f))
******************************************************************
          if (methJ2) then
*         methode 2 : on calcul seulement la perturbation = 
*         chap(u_f)^T * chap(u_f) dont la participation pour chaque mode est pondere par le norme du mode
          do id=1,3
            do j=1,3
              mthth(id,j,iib) = 0.d0
            enddo
          enddo
*
          do ip=1,npdef
            do 14 in = 1,na3
              if (xnorm(in).le.xzprec) goto 14
              i2 = in + ina1
*             write(*,*)'i2 = ',i2
*             write(*,*)'q1(i2,ind1) = ',q1(i2,ind1)
              do id=1,3
                Xt(id) = (xtphi(id,ip,in,iib) * q1(i2,ind1))
              enddo
              
              call chap(Xt(1),Xtcha(1,1))
              do id=1,3
                do j=1,3
                  do k=1,3
                    mthth(id,j,iib) = mthth(id,j,iib) +
     &              (Xtcha(k,id)*Xtcha(k,j))*(xm(i2,1)/xnorm(in)) 
                  enddo
                enddo
              enddo

*            write(*,*)'Xt(id) = '
*            write(*,'(3(1X,F12.9))') , (Xt(id),id=1,3)
*             if (mthth(1,1,iib).ge.10) then
*               write(*,*)'mthth too big!'
*               call exit(1)
*             endif

 14         continue
        enddo
*         fin method 2
          endif
*
*        write(*,*)'inertia tensor : ind',ind1
*        write(*,*)'inertia tensor : undeformed state'
*        do id=1,3
*           write(*,'(3(1X,F8.5))') , (inertie(id,j,iib),j=1,3)
*        enddo
*        write(*,*)'inertia tensor : perturbation :'
*        do id=1,3
*           write(*,'(3(1X,F12.9))') , (mthth(id,j,iib),j=1,3)
*        enddo
*
*      on implemente les forces d'inertie d'entrainement
*      dues aux blocs non diagonnaux de la matrice de masse :
* contribution modes elastiques a l'acceleration en translation :
*       indice :
*        ind2 = ind1-1
*        write(*,*)'calcul fer :'
        ind2 = ind1
        do id=1,3
        do 15 in=1,na3
          if (itrig(iib,in)) goto 15
          i2 = ina1 + in
          fer(id,ind2,iib) = fer(id,ind2,iib) + mfr(in,id)*q3(i2,ind1) 
 15     continue
        enddo
* contribution accel angulaire de rotation a l'acceleration en translation
        do id=1,3
          do j=1,3
          fer(id,ind2,iib) = fer(id,ind2,iib) +
     &           (mrth(id,j)*omeg3(j,ind1,iib))
          enddo
        enddo

*   FETH : attention ! il faut que les modes de translas soient dans l'ordre 
*       X,Y,Z dans la base modale !
* contribution accel translation a l'accel angulaire de rotation
*        write(*,*)'calcul feth :'
        do id = 1,3
        j = 0
        do in=1,na3
          i2 = ina1 + in
          if (itrig(iib,in)) then
            j = j + 1
            feth(id,ind2,iib) = feth(id,ind2,iib) +
     &           (mrth(j,id)*q3(i2,ind1))
          endif
        enddo
        enddo
*       write(*,*)'feth via mrth :'
*       write(*,'(3(1X,F8.5))') , (feth(id,ind2,iib),id=1,3)
* contribution accel elastique sur l'accel angulaire de rotation
*       do id=1,3
*       do 16 in=1,na3
*         if (itrig(iib,in)) goto 16
*         i2 = ina1 + in
*         feth(id,ind2,iib) = feth(id,ind2,iib) +
*    &            mfth(in,id)*q3(i2,ind1) 
*16     continue
*       enddo

        do id=1,3
        do 16 in=1,na3
          if (itrig(iib,in)) goto 16
          i2 = ina1 + in
          feth(id,ind2,iib) = feth(id,ind2,iib) +
     &            mthf(id,in)*q3(i2,ind1) 
 16     continue
        enddo
*       write(*,*)'feth + mfth :'
*       write(*,'(3(1X,F8.5))') , (feth(id,ind2,iib),id=1,3)

* contribution accel translation sur l'accel elastique 
*        write(*,*)'calcul fef :'
        do in=1,na3
          j = 0
          do in1=1,na3
            i2 = ina1 + in1
            if (itrig(iib,in1)) then
              j = j + 1
              fef(in,ind2,iib) = fef(in,ind2,iib) +
     &               (mfr(in1,j)*q3(i2,ind1))
            endif
          enddo
        enddo
*       write(*,*)'fef via mfr :'
*       do in = 1,na3
*       write(*,'(3(1X,F8.5))') , (fef(in,ind2,iib))
*       enddo
* contribution accel angulaire sur l'accel elastique :
        do 23 in=1,na3
          if (itrig(iib,in)) goto 23
          do j=1,3
          fef(in,ind2,iib) = fef(in,ind2,iib) +
     &              (mfth(in,j)*omeg3(j,ind1,iib))
          enddo
 23     continue

*       write(*,*)'fef + mfth :'
*       do in = 1,na3
*       write(*,'(3(1X,F8.5))') , (fef(in,ind2,iib))
*       enddo
***** quadratic velocity vector : incluant l'effet de coriolis et les forces centrifuges
*       Qr : -rot * (chap(omeg1)^2 * sum_i m_i (X + u_f) + 2 chap(omeg1) * sum_i m_i q2(i)
*       write(*,*)'calcul qr :'
*       write(*,*)'calcul wchap2 :'
        call chap(omeg2(1,ind1,iib),wchap(1,1))
        do id=1,3
          do j=1,3
            wchap2(id,j) = 0.d0
            do k=1,3
              wchap2(id,j) = wchap2(id,j) + wchap(id,k) * wchap(k,j)
            enddo
          enddo
        enddo
*
        do ip=1,npdef
          do 18 in = 1,na3
            if (xnorm(in).le.xzprec) goto 18
            if (itrig(iib,in)) goto 18
            i2 = in + ina1
            do id=1,3
              Xt(id) = (xcoophi(id,ip,iib) - xcent(id,iib) + 
     &                  (xtphi(id,ip,in,iib) * q1(i2,ind1))) *
     &                  (xm(i2,1)/xnorm(in)) 
            enddo

*       write(*,*)'calcul qr2 :'
            do id=1,3
              do j=1,3
                qr2(id,iib) = qr2(id,iib) + wchap2(id,j) * Xt(j)
              enddo
            enddo
            do id=1,3
              do j=1,3
                qr2(id,iib) = qr(id,iib) + (2.d0*wchap(id,j)*
     &                      xtphi(j,ip,in,iib)*q2(i2,1)*
     &                      (xm(i2,1)/xnorm(in)))
              enddo
            enddo
 18       continue
        enddo
*       qr1 = -rot * qr2
*       write(*,*)'calcul qr :'
        do id=1,3
          qr(id,iib) = 0.d0
          do j=1,3
            qr(id,iib) = qr(id,iib) - rot(id,j,ind1,iib) * qr2(j,iib)
          enddo
        enddo
* Qth : shabana p 321
*     - la 1ere partie de Qth est calculee au moment de l'eq dyn.
*     - 2eme partie : dot(Ithth) = chap(dot(u_f))^T * chap(u_f) +
*                                  chap(u_f)^T * chap(dot(u_f)) 
        do ip=1,npdef
          do 19 in = 1,na3
            if (xnorm(in).le.xzprec) goto 19
            i2 = in + ina1
            do id=1,3
              Xt(id) = (xtphi(id,ip,in,iib) * q1(i2,ind1))
              Xt2(id) = (xtphi(id,ip,in,iib) * q2(i2,ind1))
            enddo
            call chap(Xt(1),Xtcha(1,1))
            call chap(Xt2(1),Xt2cha(1,1))
            do id=1,3
              do j=1,3
                do k=1,3
                   qth2(id,j,iib) =  qth2(id,j,iib) +
     &             (Xt2cha(k,id)*Xtcha(k,j))*(xm(i2,1)/xnorm(in)) +
     &             (Xtcha(k,id))*Xt2cha(k,j)*(xm(i2,1)/xnorm(in))
                enddo
              enddo
            enddo
            do id = 1,3
              do j = 1,3
                qth(id,iib) = qth(id,iib) -
     &                       (qth2(id,j,iib) * omeg2(j,ind1,iib)) 
              enddo
            enddo
 19       continue
        enddo
*       write(*,*)'QTH : 2eme partie : '
*       write(*,'(3(1X,F8.5))') , (qth(id,iib),id=1,3)
*       QTH 3eme partie : -W vect (Ithf q2)
        do ip=1,npdef
          do 20 in = 1,na3
            if (xnorm(in).le.xzprec) goto 20
            i2 = in + ina1
            do id=1,3
              Xt(id) = (xcoophi(id,ip,iib) - xcent(id,iib)) + 
     &                  xtphi(id,ip,in,iib) * q1(i2,ind1)
            enddo
            call chap(Xt(1),Xtcha(1,1))
            do id=1,3
              Xt(id) = 0.d0
              do j=1,3
                Xt(id) = Xt(id) + 
     &          (Xtcha(id,j)*xtphi(j,ip,in,iib)*q2(i2,ind1)*
     &          (xm(i2,1)/xnorm(in)))
              enddo
            enddo
            qth(1,iib) = qth(1,iib) -
     &      (omeg2(2,ind1,iib)*Xt(3) - omeg2(3,ind1,iib)*Xt(2))
            qth(2,iib) = qth(2,iib) -
     &      (omeg2(3,ind1,iib)*Xt(1) - omeg2(1,ind1,iib)*Xt(3))
            qth(3,iib) = qth(3,iib) -
     &      (omeg2(1,ind1,iib)*Xt(2) - omeg2(2,ind1,iib)*Xt(1))
 20       continue
        enddo
* Qf :  
        do 21 in = 1,na3
          qf(in,iib) = 0.d0
          if (xnorm(in).le.xzprec) goto 21
          i2 = in + ina1
        do ip=1,npdef
        do id=1,3
          Xt(id) = 0.d0
          do j=1,3
            Xt(id) = Xt(id) + 
     &              ((wchap2(id,j) *
     &(xcoophi(j,ip,iib)-xcent(j,iib)+xtphi(j,ip,in,iib)*q1(i2,ind1)))
     &  + ( 2.d0*wchap(id,j)*(xtphi(j,ip,in,iib)*q2(i2,ind1)) ))
          enddo
          qf(in,iib) = qf(in,iib) -
     &    ((xtphi(id,ip,in,iib) * Xt(id)) * (xm(i2,1)/xnorm(in)))
        enddo
        enddo
 21     continue
        
***********************************************************************
*               fin boucle sur les indices 1,4
***********************************************************************
*       enddo
***********************************************************************
*       si on a fait les forces d'inertie sur les 4 indices :
*        do id=1,3
**
*        fr(id,iib) = (fer(id,4,iib) + (5.d-1*fer(id,3,iib)) + 
*     &                (5.d-1*fer(id,2,iib)) + fer(id,1,iib))/6.d0
*        fth(id,iib) = (feth(id,4,iib) + (5.d-1*feth(id,3,iib)) + 
*     &                (5.d-1*feth(id,2,iib)) + feth(id,1,iib))/6.d0
*        enddo
*       forces d'inertie sur les ddls elastiques :
*        do in=1,na3
*        ff(in,iib) = (fef(in,4,iib) + (5.d-1*fef(in,3,iib)) + 
*     &                (5.d-1*fef(in,2,iib)) + fef(in,1,iib))/6.d0
**        write(*,'(1X,F8.5)') , ff(in,iib)
**
*        enddo
*       si on a fait les forces d'inertie que sur l'indice 1 :
*       write(*,*)'calcul fr, fth, ff :'
        do id=1,3
          fr(id,iib) = fer(id,1,iib) 
          fth(id,iib) = feth(id,1,iib) 
          if ((fr(id,iib).ne.fr(id,iib)).or.
     &      (fth(id,iib).ne.fth(id,iib))) then
            write(*,*)'Nan dans les FTH'
            call exit(1)
          endif
        enddo
*        write(*,*)'rkpas : FR'
*        write(*,'(3(1X,F8.5))') , (fr(id,iib),id=1,3)
*        write(*,*)'rkpas : FTH'
*        write(*,'(3(1X,F8.5))') , (fth(id,iib),id=1,3)
        do in=1,na3
          ff(in,iib) = fef(in,1,iib) 
          if (ff(in,iib).ne.ff(in,iib)) then
            write(*,*)'Nan dans FF'
            call exit(1)
          endif
*        write(*,'(1X,F8.5)') , ff(in,iib)
        enddo

***********************************************************************
*      on totalise sur ftota et fmomtot :
***********************************************************************
        do in=1,na3
          i2 = ina1 + in
          j=0
          if (itrig(iib,in)) then
            j = j + 1
            ftota(i2,1) = ftota(i2,1) - fr(j,iib) + qr(j,iib) 
*            ftota(i2,1) = ftota(i2,1)  
          endif
          if (.not.itrig(iib,in)) then
            ftota(i2,1) = ftota(i2,1) - ff(in,iib) + qf(in,iib) 
*           ftota(i2,1) = ftota(i2,1)  
          endif
        enddo
* Pour les rotas rigides fmomtot est calcule en base B alors que fth et qth
* sont calcules en base A. on les integre dans l'eq dynamique direct.
***********************************************************************
**     fin boucle sur les ss bases
 1      continue
**     fin if rigide
      endif
************************************************************************
*     equilibre dynamique a t_n+1
************************************************************************
*     coordonnees modales : modes elastiques + translations rigides 
************************************************************************
*      write(*,*)'   eq. dyn :'
*     ajout des forces de raideurs :
      CALL RKLK0(Q1,XK,FTOTA,NA1,NB1K,1,1)
*     ajout des forces d'amortissement :
      IF (NB1C.GT.1) THEN
        DO I=1,NA1
           FAMOR(I) = 0.D0
          DO J=1,NB1
            FAMOR(I) = FAMOR(I) + XASM(I,J) * Q2(J,1)
          enddo
        enddo
      ELSE
        DO I=1,NA1
           FAMOR(I) = XASM(I,1) * Q2(I,1)
        enddo
      ENDIF
c    -Cas C ou M pleine : pas de prise en compte des forces d'inertie
      IF (NB1.NE.1) THEN
        DO I=1,NA1
          Q3(I,1) = 0.D0
          DO J=1,NB1
          Q3(I,1) = Q3(I,1) + XOPM1(I,J,1)*(FTOTA(J,1)-FAMOR(J))
          enddo
        enddo
c    -Cas C et M diagonales : on prend en compte les forces d'inertie
      else
        DO I=1,NA1
          UNSM = 1.D0 / ( XM(I,1) + dt2*XASM(I,1) - FINERT(I,1) )
          Q3(I,1) = (FTOTA(I,1)-FAMOR(I)) * UNSM
        enddo
      endif

*     MAJ des vitesses :
      do in=1,na1
        q2(in,1) = q2(in,5) + (dt/2.d0)*(q3(in,5)+q3(in,1))
      enddo

************************************************************************
*     rotations rigides :  
************************************************************************
      if (rigide) then
       if (lrspin) then 
         fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + tspin(1)
         fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + tspin(2)
         fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + tspin(3)
       endif
       do 17 iib=1,nsb
          if (iarota(iib).eq.0) goto 17
*         inversion de la matrice d'inertie :

          do id=1,3
            jw(id) = 0.d0
            rtgex(id) = 0.d0
            do j=1,3
          rtgex(id) = rtgex(id) + rot(j,id,1,iib)*fmomtot(j,1,iib)
*         jw(id) = jw(id) + (inertie(id,j,iib))*
          jw(id) = jw(id) + (mthth(id,j,iib) + inertie(id,j,iib))*
     &                      omeg2(j,1,iib)
              ine(id,j) = (mthth(id,j,iib) + inertie(id,j,iib))
            enddo
*           on rajoute les forces d'inertie a rtgex :
            rtgex(id) = rtgex(id) + qth(id,iib) - fth(id,iib)
          enddo
          t2(1) = omeg2(2,1,iib)*jw(3) - omeg2(3,1,iib)*jw(2) 
          t2(2) = omeg2(3,1,iib)*jw(1) - omeg2(1,1,iib)*jw(3) 
          t2(3) = omeg2(1,1,iib)*jw(2) - omeg2(2,1,iib)*jw(1) 
*         On calcul l'inverse de la matrice d'inertie :
          call hinv33(ine(1,1),invine(1,1))
          do id = 1,3
            omeg3(id,1,iib) = 0.d0
            do j = 1,3
              omeg3(id,1,iib) = omeg3(id,1,iib) + 
     &         invine(id,j) * (-t2(j) + rtgex(j))
*     &        (-t2(j) + rtgex(id) - fth(id,iib))
            enddo
          enddo
*          MAJ vitesse angulaire :
          do id = 1,3
            omeg2(id,1,iib) = omeg2(id,5,iib) + 
     &                 (dt/2.d0)*(omeg3(id,1,iib)+omeg3(id,5,iib))
          enddo
 17    continue
      endif

************************************************************************
*     fin if linert
************************************************************************
      endif
************************************************************************
*     Energies
************************************************************************
      IF (RIGIDE) THEN
       DO 8 IIB=1,NSB
CMS :     Rotas rigides ssi il y a une grande rota ds la ss base en question !!
          IF (IAROTA(IIB).EQ.0) GOTO 8
***       Calcul du moment cinetique : 
          DO I=1,3
            PICIN(IIB,I) = 0.D0
            DO J=1,3
              DYN2(J) = 0.D0
              DO K=1,3
                DYN2(J) = DYN2(J) +
     &                    ROT(I,K,1,IIB)*INERTIE(K,J,IIB)
              ENDDO
              PICIN(NSB,I) = PICIN(IIB,I)+DYN2(J)*OMEG2(J,1,IIB)
            ENDDO
          ENDDO
***       Calcul de l energie cinetique en rotation : 
          TCIN(IIB) = 0.D0
          DO I=1,3
            DYN2(I) = 0.D0
            DO J=1,3
              DYN2(I) = DYN2(I) + INERTIE(I,J,IIB)*OMEG2(J,1,IIB)
            ENDDO
            TCIN(IIB) = TCIN(IIB) + (OMEG2(I,1,IIB)*DYN2(I)/2.d0) 
          ENDDO
          NA3  = INMSB(IIB)
*              = nbr de modes elasiques ds la ss base (incluant les transl. rigides)
          INA2 = IORSB(IIB) - 1
          XTC = 0.D0
          DO IN = 1,NA3
            IN2 = INA2 + IN
            IF ((ITRIG(IIB,IN))) THEN
*             Energie cinetique translation : 
              DO ID=1,IDIM
                XTC = XTC + 
     &            0.5*MTSB(IIB)*((XPHILB(IIB,1,IN,ID)*Q2(IN2,1))**2.d0) 
              ENDDO
            ELSE
*             Energie cinetique modes flexibles : 
              XTC = XTC + (0.5 * (Q2(IN2,2)**2) * XM(IN,1))
            ENDIF 
          ENDDO
          TCIN(IIB) = TCIN(IIB) + XTC
*         Energie potentielle de pesanteur : 
*           - la gravite est en -ez
*           - le cdm du solide est le point de liaison numero 1 
          if (nliab.ne.0) then
            epot(iib) = xptb(1,1,3)*mtsb(iib)*9.81 
          endif
 8     CONTINUE
* fin boucle ss bases
      ENDIF
*
      END

 
 
 
 
