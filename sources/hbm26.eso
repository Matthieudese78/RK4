C HBM26     SOURCE    BP208322  20/09/18    21:16:31     10718          
*
C DYNE26    SOURCE    BP208322  19/04/03    21:15:10     10174          
      SUBROUTINE HBM26(IBAS,KTKAM,KTLIAB,KTPHI,IA1,IB,ICOMP,RIGIDE,ITKM)
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*                                                                    *
*     Operateur DYNE : algorithme de Fu - de Vogelaere               *
*     ________________________________________________               *
*                                                                    *
*     Transpose l'information des objets de Castem2000 dans des      *
*     tableaux de travail.                                           *
*                                                                    *
*     Parametres:                                                    *
*                                                                    *
* e   IBAS    Table representant une base modale                     *
* es  KTKAM   Segment contenant les matrices XK, XASM et XM          *
* es  KTPHI   Segment des deformees modales                          *
* e   KTLIAB  Segment des liaisons sur base B                        *
* es  IA1     Compteur                                               *
* e   IB      Compteur de la sous base                               *
* es  RIGIDE  Vrai si l'on a un corps rigide, faux sinon             *
* e   ITKM    >0 si table RAIDEUR_ET_MASSE fournie                   *
*                                                                    *
*     Auteur, date de creation:                                      *
*                                                                    *
*     Lionel VIVAN, le 24 octobre 1989.                              *
*                                                                    *
*--------------------------------------------------------------------*
-INC PPARAM
-INC CCOPTIO
-INC CCREEL
-INC SMCHAML
-INC SMELEME
-INC SMMODEL
*
*-INC TMDYNC.INC
************************** debut TMDYNC.INC ****************************

*    TMDYNC : FUTUR INCLUDE POUR LES SEGMENTS DE L'OPERATEUR DYNC
*    TODO   : a extraire dans un include des que stabilise
*
*     Segment des variables generalisees:
*     -----------------------------------
      SEGMENT MTQ
         REAL*8 Q1(NT1)
         REAL*8 OMEG,XPARA
         REAL*8 JAC(NT1,NT1),ZZ(NT1,NT1),RX(NT1,NT1)
         REAL*8 dX(NT1), dw, dv
      ENDSEGMENT
*     Q1   : vecteur des inconnues frequentielles de dimension (2h+1)*n
*            Q1 = {q_0 q_c1 q_s1 ... q_sh}
*            avec q_i vecteur de dimension n ou n=nombre de modes
*     OMEG : frequence fondamentale de l'approximation
*     XPARA: parametre de continuation (par defaut la frequence) 
*            \in [PARINI,PARFIN]
*     RX   : matrice jacobienne = ZZ + dFnl/dX
*     JAC  : jacobienne des efforts non-lineaires  = dFnl/dX
*     ZZ   : matrice dynamique associee aux matrices modales K, M et C 
*            lineaires et constantes
*     {dX,dw,(dv)} : vecteur tangent utilise pour la prediction
*
*
*     Segment contenant les matrices XK, XASM et XM:
*     ---------------------------------------------
      SEGMENT MTKAM
         REAL*8 XK(NA1,NB1K),XASM(NA1,NB1C),XM(NA1,NB1M)
         REAL*8 GAM(NPC1,nl1),IGAM(nl1,NPC1),DL(nl1)
*         REAL*8 GAMFIN(NPC2,nl1)
      ENDSEGMENT
*     XK,XASM et XM : matrices de raideur, amortissement et masse
*     GAM et IGAM : matrices pour la FFT et son inverse
*     GAMFIN      : 
*
*     Segment des deformees modales:
*     ------------------------------
*     (idem DYNE)
      SEGMENT MTPHI
         INTEGER IBASB(NPLB),IPLSB(NPLB),INMSB(NSB),IORSB(NSB)
         INTEGER IAROTA(NSB)
         REAL*8  XPHILB(NSB,NPLSB,NA2,IDIMB)
      ENDSEGMENT
*
*     Segment descriptif des liaisons en base A:
*     ------------------------------------------
*     (idem DYNE)
      SEGMENT MTLIAA
         INTEGER IPALA(NLIAA,NIPALA),IPLIA(NLIAA,NPLAA),JPLIA(NPLA)
         REAL*8  XPALA(NLIAA,NXPALA)
      ENDSEGMENT
*
*     Segment descriptif des liaisons en base B:
*     ------------------------------------------
*     (idem DYNE)
      SEGMENT MTLIAB
         INTEGER IPALB(NLIAB,NIPALB),IPLIB(NLIAB,NPLBB),JPLIB(NPLB)
         REAL*8  XPALB(NLIAB,NXPALB)
         REAL*8  XABSCI(NLIAB,NIP),XORDON(NLIAB,NIP)
      ENDSEGMENT
*
*     Segment representant les chargements exterieurs:
*     -----------------------------------------------
      SEGMENT MTFEX
         REAL*8  FEXA(NT1)
         REAL*8  FEXPSM(NPLB,NPC1,2,IDIMB)
         INTEGER BAL
      ENDSEGMENT
*     FEXA : Vecteur des efforts ext. sous la forme de coefficients de
*            Fourier et exprimes en base A
*     FEXPSM: chargement/deplacement statique lie aux modes negliges
*             (neglige aussi les Fnl). Dans DYNC toujours =0, cree pour
*             compatibilite avec calcul des Fnl.
*     BAL  : indique s'il s'agit d'un chargement de type balourd
*            (cad proportionnel a OMEG**2)
*
*     Segment "local" pour DEVLFA:
*     ----------------------------
      SEGMENT LOCLFA
         REAL*8 FTEST(NA1,4)
      ENDSEGMENT
*      
*     Segment "local" pour DEVLB1:
*     ----------------------------
      SEGMENT LOCLB1
         REAL*8 FTEST2(NPLB,6)
      ENDSEGMENT
*      
*     Segment contenant les variables au cours d un pas de temps:
*     ----------------------------------------------------------
      SEGMENT MTPAS
         REAL*8 FTOTA(NA1,4),FTOTB(NPLB,IDIMB),FTOTBA(NA1)
         REAL*8 XPTB(NPLB,2,IDIMB),FINERT(NA1,4)
         REAL*8 XVALA(NLIAA,4,NTVAR),XVALB(NLIAB,4,NTVAR)
         REAL*8 FEXB(NPLB,3,IDIM),XCHPFB(2,NLIAB,4,NPLB)
         REAL*8 KTOTXA(NA1,NA1),KTOTVA(NA1,NA1)
         REAL*8 KTOTXB(NPLB,IDIMB,IDIMB), KTOTVB(NPLB,IDIMB,IDIMB) 
      ENDSEGMENT
*     FTOTA/B/BA : forces sur base A, B et B projetees sur A
*     XPTB       : deplacement du point d'une liaison en base B
*     XVALA/B    : grandeurs de la liaison en base A/B a stocker
*     FEXB       : forces exterieures en base B (a priori uniquement 
*                  pour les moments appliques aux rotations rigides ?)
*     XCHPFB     : forces de contact en base B (lorsqu'on  considere un
*                  maillage de contact dans certaines liaisons)
*     KTOTXA/XB/VA/VB : Jacobienne par rapport au deplacement/vitesse en
*                       base A/B (= contributions a dFnl/dX)
*
*
*     Segment des points de reference des modes (base A):
*     --------------------------------------------------
      SEGMENT MPREF
         INTEGER IPOREF(NPREF),IPORIG(NPRIG)
      ENDSEGMENT
*
*     Segment des points en base B:
*     -----------------------------
      SEGMENT NCPR(XCOOR(/1)/(IDIM+1))
*     NCRP(#global) = #local dans XPTB (1er indice)      
*
*     Segment des parametres numeriques pour la continuation: 
*     ------------------------------------------------------
      SEGMENT PARNUM
         CHARACTER*4 TYPS
         REAL*8   DS,DSMAX,DSMIN,ANGMIN,ANGMAX,ITERMOY,ISENS,TOLMIN
         REAL*8   PARINI,PARFIN
         INTEGER  ITERMAX,NBPAS
         LOGICAL  JANAL
      ENDSEGMENT
*
*     Segment des resultats:
*     ---------------------
      SEGMENT  PSORT
        REAL*8 QSAVE(NT1,NPAS),WSAVE(NPAS),LSAVE(2,2*NA1,NPAS)
        REAL*8 VSAVE(NPAS)
        LOGICAL ZSAVE(NPAS)
        CHARACTER*2 TYPBIF(NBIFU)
        REAL*8 QBIFU(NT1,NBIFU),WBIFU(NBIFU),WBIF2(NBIFU)
        REAL*8 QPSIR(NT1,NBIFU),QPSII(NT1,NBIFU)
        INTEGER CBIF
      ENDSEGMENT
*     QSAVE(i,j) = Q harmonique i au pas j
*     VSAVE(j)   = parametre de continuation (si non w) au j-eme pas
*     ZSAVE(j)   = stabilite au j-eme pas
*     LSAVE(1,j) : partie reelle de l'exposant de Floquet
*     LSAVE(2,j) : partie imaginaire de l'exposant de Floquet
*     TYPBIF = {LimitPoint, BranchPoint, NeimarkSacker, PeriodDoubling}
*     QBIFU,WBIFU : vecteur Q et w au point de bifurcation
*           WBIF2 : partie imaginaire de l'exposant de Floquet
*     QPSIR,QPSII : vecteur propre au point de bifurcation
      
*     Segment des tableaux de travail:
*     -------------------------------
      SEGMENT  MTEMP
         REAL*8 RW(NT1),A,T0(NT1+1),TP(NT1+1),AMPX,AUX
         REAL*8 T02(NT1+2), TP2(NT1+2)
         INTEGER IPIV(NT1),IPIV2(NT1+1),IPIV3(NT1+2)
         REAL*8 res
         REAL*8 RHS(NT1+1),Ja(NT1+1,NT1+1)
         REAL*8 QOLD(NT1),OMEGOLD
         REAL*8 MATJA(NT1+1,NT1+1),Rw2(NT1)
         REAL*8 Jaa(NT1+2,NT1+2),RHS2(NT1+2),Ra(NT1),VV,VVOLD
      ENDSEGMENT
*     Jacobiennes augmentees 
*     Ja : [ RX  Rw ; dX dw]
*     Jaa: [ RX  Rw Ra; gx 0 0; dX dw da]

*      SEGMENT  NNNN
*         REAL*8 IGAM2(nl1,NPC2),DL2(nl1)
*      ENDSEGMENT

*************************** fin TMDYNC.INC *****************************

*
      LOGICAL L0,L1,RIGIDE
      CHARACTER*4 NOMTRI(6),NOMAXI(6),NOMPLA(3)
      CHARACTER*8 CMOT,TYPRET,MORIGI,CHARRE
      REAL*8      XAXROT(3),XROTA(2,3)
*
*     si IFOMOD = -1  :  modele PLAN
*     si IFOMOD =  0  :  modele AXIS
*     si IFOMOD =  1  :  modele FOUR
*     si IFOMOD =  2  :  modele TRID
*
*     Les noms de composante sont
*       - en modele PLAN   :  UX, UY, RT
*       - en modele AXIS   :  UX, UY, RZ
*       - en modele FOUR 1 :  UR, UZ, UT, RT
*       - en modele TRID   :  UX, UY, UZ, RX, RY, RZ
*
      DATA NOMTRI/'UX  ','UY  ','UZ  ','RX  ','RY  ','RZ  '/
      DATA NOMAXI/'UR  ','UT  ','UZ  ','RR  ','RT  ','RZ  '/
      DATA NOMPLA/'UX  ','UY  ','RZ  '/
*
      MTKAM  = KTKAM
      MTPHI  = KTPHI
      MTLIAB = KTLIAB
*
      NLIAB  = IPALB(/1)
      NPLB   = JPLIB(/1)
      NSB    = XPHILB(/1)
      NPLSB  = XPHILB(/2)
      NA2    = XPHILB(/3)
      IDIMB  = XPHILB(/4)
      DEUXPI = 2.D0 * XPI
*
      IORSB(IB) = IA1 + 1
      IAROTA(IB) = 0
      IROT = 0
      IN = 0

************************************************************************
*     table BASE_MODALE
************************************************************************

 10   CONTINUE
      IN = IN + 1
      TYPRET = ' '
      CALL ACCTAB(IBAS,'ENTIER',IN,X0,' ',L0,IP0,
     &                   TYPRET,I1,X1,CHARRE,L1,IBAMOD)
      IF (IERR.NE.0) RETURN
*    -on a bien un objet de type table
      IF (IBAMOD.NE.0) THEN
       IF (TYPRET.EQ.'TABLE   ') THEN

         IA1 = IA1 + 1

*        remplissage de XM et XK diagonale depuis la table BASE_MODALE
*        sauf si deja fait car on a une table RAIDEUR_ET_MASSE !
         IF (ITKM.LE.0) THEN
           CALL ACCTAB(IBAMOD,'MOT',I0,X0,'MASSE_GENERALISEE',L0,IP0,
     &                        'FLOTTANT',I1,XMASSE,' ',L1,IP1)
           IF (IERR.NE.0) RETURN
           XM(IA1,1) = XMASSE
           CALL ACCTAB(IBAMOD,'MOT',I0,X0,'FREQUENCE',L0,IP0,
     &                        'FLOTTANT',I1,XFREQ,' ',L1,IP1)
           IF (IERR.NE.0) RETURN
           OMEGA = XFREQ * DEUXPI
           XK(IA1,1) = XMASSE * OMEGA * OMEGA
           IF (IIMPI.EQ.333) THEN
              WRITE(IOIMP,*)'HBM26 :   XM(',IA1,') =',XMASSE
              WRITE(IOIMP,*)'HBM26 :   XK(',IA1,') =',XK(IA1,1)
           ENDIF
         ENDIF

*    si liaison_B existe, remplissage de IPLSB, XPHILB, IAROTA, INMSB...
         IF (NLIAB.NE.0) THEN
            CALL ACCTAB(IBAMOD,'MOT',I0,X0,'DEFORMEE_MODALE',L0,IP0,
     &                         'CHPOINT',I1,X1,' ',L1,ICDM)
            IF (IERR.NE.0) RETURN
            DO 12 ID = 1,IDIMB
               IF (IFOUR.EQ.0 .OR. IFOUR.EQ.1) THEN
                  CMOT = NOMAXI(ID)
               ELSE
                  IF (IFOMOD.EQ.-1) THEN
                      CMOT = NOMPLA(ID)
                  ELSE
                      CMOT = NOMTRI(ID)
                  ENDIF
               ENDIF
               IF (IIMPI.EQ.333)
     &         WRITE(IOIMP,*)'HBM26 :  composante a extraire :',CMOT
               ICOMP  = 0
               DO 14 IP = 1,NPLB
                  IPOINT = JPLIB(IP)
*      On extrait du chpoint ICDM au point IPOINT de composante CMOT
                  CALL EXTRA9(ICDM,IPOINT,CMOT,0,.FALSE.,XVAL,IRET)
                  ICOMP = ICOMP + 1
*          on ajuste la taille si necessaire
                  IF(ICOMP.GT.NPLSB) THEN
                      NPLSB=ICOMP
                      SEGADJ MTPHI
                  ENDIF
                  IPLSB(IP) = ICOMP
* suite a la modif dans extra9, car on attribue une valeur meme
* si le point n'existe pas dans le chpoint
                  IF (XVAL.NE.0.) THEN
                    IF ((IBASB(IP).NE.0).AND.(IBASB(IP).NE.IB)) THEN
                      call erreur (783)
                      RETURN
                    ENDIF
                    IBASB(IP) = IB
                  ELSEIF ((IB.EQ.NSB).AND.(IBASB(IP).EQ.0)) THEN
                    IBASB(IP) = IB
                  ENDIF
                  XPHILB(IB,ICOMP,IN,ID) = XVAL
      IF (IIMPI.EQ.333) THEN
        WRITE(IOIMP,*)'HBM26 :   IPLSB(',IP,') =',IPLSB(IP)
        WRITE(IOIMP,*)'HBM26 :   IBASB(',IP,') =',IBASB(IP)
        XVA2 = XPHILB(IB,ICOMP,IN,ID)
        WRITE(IOIMP,*)'HBM26 :   XPHILB(',IB,ICOMP,IN,ID,') =',XVA2
      ENDIF
 14            CONTINUE
 12         CONTINUE
         ENDIF

c *        Prise en compte d'un mode de rotation de corps rigide
          MORIGI = ' '
          CALL ACCTAB(IBAMOD,'MOT',I0,X0,'ROTATION_RIGIDE',L0,IP0,
     &                      MORIGI,I1,X1,CMOT,L1,IP1)
          IF (IERR.NE.0) RETURN
          IF (MORIGI.EQ.'MOT') THEN
             WRITE(*,*)'Pas de rotations rigides avec HBM'
             CALL ERREUR(272)
             RETURN
             IF (CMOT(1:4).EQ.'VRAI') THEN
                 CALL ACCTAB(IBAMOD,'MOT',I0,X0,'CENTRE_DE_GRAVITE',
     &          L0,IP0,'POINT',I1,X1,'  ',L1,ICDG)
                 IF (IERR.NE.0) RETURN
* non, pas de rotas rigides avec HBM: IAROTA(IB)=IA1
                 IROT = IN
             ENDIF
          ENDIF
         GOTO 10
       ELSE
         CALL ERREUR(491)
         RETURN
       ENDIF
      ENDIF
*    -fin du cas ou on a bien un objet de type table
      INMSB(IB) = IN - 1
*       
************************************************************************
*     Remplissage des fausses deformees modales de rotations
************************************************************************
*
*50   continue
      IF (IAROTA(IB).NE.0) THEN
         RIGIDE = .TRUE.
         MERR = 0
         NPLUS = IN + 1
         IF (NPLUS.GT.NA2) THEN
* On reajuste le dimension NA2 de XPHILB
                 NA2 = NPLUS
                 SEGADJ MTPHI
         ENDIF
         DO 18 IP=1,NPLB
             IPOINT=JPLIB(IP)
             IPOS=IPLSB(IP)
             IBBAS= IBASB(IP)
             IF (IBBAS.EQ.IB) THEN
                DO 20 ID=(IDIM+1),IDIMB
                  XAXROT(ID-IDIM) = XPHILB(IB,IPOS,IROT,ID)
 20             CONTINUE
* En tridimensionnel l'axe de rotation est le vecteur propre de rotation
* On norme l axe du plan de rotation
                CALL DYNE41(XAXROT,MERR,IDIM)
* En bidimensionnel l'axe de rotation est fixe
* Calcul des fausses deformees modales de rotation
                CALL DYNE42(XROTA,XAXROT,IPOINT,ICDG,IDIMB,MERR)
             DO 22 ID =1,IDIMB
                 XPHILB(IB,IPOS,IN,ID)  = XROTA(1,ID)
                 XPHILB(IB,IPOS,IN+1,ID)= XROTA(2,ID)
 22          CONTINUE
             ENDIF
 18       CONTINUE
      ENDIF
 
      IF (IIMPI.EQ.333) THEN
        WRITE(IOIMP,*)'HBM26 :   INMSB(',IB,') =',INMSB(IB)
        WRITE(IOIMP,*)'HBM26 :   IORSB(',IB,') =',IORSB(IB)
        WRITE(IOIMP,*)'HBM26 :   IAROTA(',IB,') =',IAROTA(IB)
      ENDIF      
      END



 
 
