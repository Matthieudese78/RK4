C RCDEP2    SOURCE    CB215821  20/11/25    13:38:34     10792          
      SUBROUTINE RCDEP2(IBAS,KTRAV,KCPR,KCHAR,XTEMP,ICHDE,ITRES,IPOS,
     &                  ITLIA,ITYP,ICHPT)
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*                                                                    *
*     Recombine le chpoint ICHPT en d�placement ou en r�action.      *
*                                                                    *
*     Param�tres:                                                    *
*                                                                    *
* e   IBAS    table repr�sentant une base modale                     *
* e   KCHAR   chargement de la structure                             *
* e   XTEMP   temps de recombinaison                                 *
* e   ITRES   table r�sultat issue de l'op�rateur DYNE               *
* e   IPOS    position de XTEMP dans le listreel des temps           *
* e   ITLIA   table des liaisons                                     *
* e   ITYP    = 0 , on recombine les d�placements nature diffuse     *              
*             = 1 , on recombine les vitesses                        *
*             =-1 , on recombine les acc�l�rations                   *
*             = 2 , on recombine les r�actions.   nature discrete    *               
* -   RIGIDE  Vrai si l'on a un corps rigide,faux sinon              *
*                                                                    *
*     Auteur, date de cr�ation:                                      *
*                                                                    *
*     Lionel VIVAN, le 26 avril 1990.                                *
*                                                                    *
* Rq Matthieu: jusqu a maintenant, on recombinais les mult. de       *
*              Lagrange comme les modes. Cela n a pas de sens si les *
*              reactions ne concernent pas les m�mes points ou pas   *
*              les m�mes composantes. Desormais, on saute donc       *
*              le SOUPO des mult. de Lagrange dans la recombinaison. *
*--------------------------------------------------------------------*

-INC PPARAM
-INC CCOPTIO
-INC SMCOORD
-INC SMCHPOI
-INC SMELEME
      SEGMENT ICPR(nbpts)
      SEGMENT TRAV(NPOIN)*D
      LOGICAL L0,L1,RIGIDE,LTRIG,LJOK
      CHARACTER*8 TYPRET,MORIGI,CMOT,CHARRE,MOTLAG,CMOT1
*     MOTLAG = pour identifier les mult. de Lagrange et les sauter
      DATA MOTLAG/'LX'/
      REAL*8 XAXROT(3),XROTA(2,6),XXGP(3)
* Ajoutes par matthieu:
*      - QUAT: quaternion --> matrice de rotation
*      - WANG: vecteur vitesse angulaire
*      - AANG: vecteur acceleration angulaire
      REAL*8 WANG(3),AANG(3),QUAT(4),ROT(3,3)
      REAL*8 VLOCAL(3),ALOCAL(3),WVLOCAL(3)
*

      TRAV = KTRAV
*     pour les modes elastiques:
*     TRAV(point IK1 du chpoin)
*      = valeur au point IK1 du chpoin au temps d'indice IPOS
      ICPR = KCPR
      RIGIDE =.FALSE.
*
*      WRITE(*,*)'RCDEP2: MOTLAG = ',MOTLAG
      CALL ACCTAB(IBAS,'MOT',I0,X0,'MODES',L0,IP0,
     &               'TABLE',I1,X1,' ',L1,IBBB)
*****************************************************************
*     initialisation du CHPOINT de sortie (base sur def modale)
*****************************************************************
      N1 = 1
      CALL ACCTAB(IBBB,'ENTIER',N1,X0,' ',L0,IP0,
     &                  'TABLE',I1,X1,' ',L1,ITBMOD)
      TYPRET = ' '
      IF (ITYP.EQ.0.OR.ITYP.EQ.1.OR.ITYP.EQ.-1) THEN
*         WRITE(*,*)'rcdep2 : base modale IBBB = ',IBBB
         CALL ACCTAB(ITBMOD,'MOT',I0,X0,'DEFORMEE_MODALE',L0,IP0,
     &                     TYPRET,I1,X1,CHARRE,L1,ICHD1)
*         WRITE(*,*)'rcdep2 : def mod. modele : ICHD1 = ',ICHD1
      ELSE IF (ITYP.EQ.2) THEN
         CALL ACCTAB(ITBMOD,'MOT',I0,X0,'REACTION_MODALE',L0,IP0,
     &                     TYPRET,I1,X1,CHARRE,L1,ICHD1)
      ENDIF
      IF (ICHD1.EQ.0 .OR. TYPRET.NE.'CHPOINT ') THEN
         MOTERR(1:8) = 'RCDEP2  '
         INTERR(1) = N1
         CALL ERREUR(169)
         RETURN
      ENDIF
      MCHPO1 = ICHD1
      SEGACT MCHPO1
      NSOUPO = MCHPO1.IPCHP(/1)
      NAT=MAX(MCHPO1.JATTRI(/1),1)
      SEGINI MCHPOI
      ICHDE = MCHPOI
      IFOPOI = MCHPO1.IFOPOI
      MTYPOI = MCHPO1.MTYPOI
      MOCHDE = '                      CHPOINT CREE PAR RCDEP2  '
      IF ( ITYP .EQ. 0 .OR.ITYP.EQ.1.OR.ITYP.EQ.-1) THEN
        JATTRI(1) = 1
      ELSE IF ( ITYP .EQ. 2 ) THEN
        JATTRI(1) = 2
      ENDIF
      DO 10 ISOU = 1,NSOUPO
         MSOUP1 = MCHPO1.IPCHP(ISOU)
         SEGACT MSOUP1
         NC = MSOUP1.NOCOMP(/2)
*         WRITE(*,*)'RCDEP2: NC = ',NC
         SEGINI MSOUPO
         IPCHP(ISOU) = MSOUPO
         DO 12 IC = 1,NC
            NOCOMP(IC) = MSOUP1.NOCOMP(IC)
            NOHARM(IC) = MSOUP1.NOHARM(IC)
 12      CONTINUE
         IGEOC = MSOUP1.IGEOC
         MELEME = IGEOC
         SEGACT MELEME
         N = NUM(/2)
         SEGDES MELEME,MSOUP1
         SEGINI MPOVAL
         IPOVAL = MPOVAL
         SEGDES MPOVAL
         SEGDES MSOUPO
 10   CONTINUE
      SEGDES MCHPO1
*      WRITE(*,*)'RCDEP2 : fin initialisation du SOUPO de sortie'
*****************************************************************
* fin initialisation du chpoint de sortie
*****************************************************************

*****************************************************************
*      RECO ELASTIQUE
*****************************************************************
*     boucle sur le nombre de modes (on saute les rotas rigides)

       IM = 0
       IRIG = 0
       rigide = .false.
       LTRIG = .FALSE.
 20    CONTINUE
       IM = IM + 1
*       WRITE(*,*)'RCDEP2: boucle mode IM = ',IM
       TYPRET = ' '
       CALL ACCTAB(IBBB,'ENTIER',IM,X0,' ',L0,IP0,
     &                   TYPRET,I1,X1,CHARRE,L1,ITBMOD)
       IF (ITBMOD.NE.0 .AND. TYPRET.EQ.'TABLE   ') THEN
         CALL ACCTAB(ITBMOD,'MOT',I0,X0,'POINT_REPERE',L0,IP0,
     &                    'POINT',I1,X1,' ',L1,IPTR)
         IF (ITYP.EQ.0.OR.ITYP.EQ.1.OR.ITYP.EQ.-1) THEN
            CALL ACCTAB(ITBMOD,'MOT',I0,X0,'DEFORMEE_MODALE',L0,IP0,
     &                     'CHPOINT',I1,X1,' ',L1,ICHDI)
            MORIGI = ' '
            CALL ACCTAB(ITBMOD,'MOT',I0,X0,'ROTATION_RIGIDE',L0,IP0,
     &                      MORIGI,I1,X1,CMOT,L1,IP1)
            IF (IERR.NE.0) RETURN
            IF (MORIGI.EQ.'MOT') THEN
                IF (CMOT(1:4).EQ.'VRAI') THEN
*                    write(*,*)'rcdep2 : rigide = ',rigide
                    RIGIDE = .true.
                    IRIG = 1
                ENDIF
            ENDIF
* Si rota rigide: Detection eventuelle d une ou plusieurs translations rigides dans la ss base
            TYPRET = ' '
            CALL ACCTAB(ITBMOD,'MOT',I0,X0,'TRANSLATION_RIGIDE',
     &                           L0,IP0,TYPRET,I1,X1,CMOT1,L1,IP1)
            IF (IERR.NE.0) RETURN
            IF (TYPRET.EQ.'MOT') THEN
              IF (CMOT1(1:4).EQ.'VRAI') THEN
                LTRIG = .TRUE.
*                WRITE(*,*)'rcdep2: translation rigide = ',LTRIG
* On ne prend pas la translation rigide dans la reco des modes elastiques:
                GOTO 20
              ENDIF
            ENDIF
*
          ELSE IF (ITYP.EQ.2) THEN
            CALL ACCTAB(ITBMOD,'MOT',I0,X0,'REACTION_MODALE',L0,IP0,
     &                     'CHPOINT',I1,X1,' ',L1,ICHDI)
         ENDIF
         IMODE = ICPR(IPTR)
* Si mode = rota rigide, on saute ce mode:
         IF (IRIG.NE.0) THEN
           IRIG = 0
           GOTO 20
         ELSEIF (IMODE.EQ.0) THEN
*
*           on ne trouve pas la d�form�e modale
*
            MOTERR(1:8) = 'RCDEP2'
            INTERR(1) = IM
            CALL ERREUR(169)
            RETURN
         ENDIF
*
* Reco modes elastiques:
         XVAL = TRAV(IMODE)
*         WRITE(*,*)'RCDEP2: XVAL = ',XVAL
         MCHPO1 = ICHDI
*         WRITE(*,*)'RCDEP2: RECO elastique du CHPO',MCHPO1
         SEGACT MCHPO1
         NSOUP1 = MCHPO1.IPCHP(/1)
*         WRITE(*,*)'NSOUPO = ',NSOUPO
*         WRITE(*,*)'NSOUP1 = ',NSOUP1
*        logique de saut des mult. de Lag. si NSOUPO diff NSOUP1
         LJOK=.FALSE.
         DO 22 ISOU = 1,NSOUPO
*            WRITE(*,*)'ISOU = ',ISOU
            MSOUP1 = MCHPO1.IPCHP(ISOU)
*            WRITE(*,*)'MSOUP1 = ',MSOUP1
            MSOUPO = IPCHP(ISOU)
*            WRITE(*,*)'MSOUPO = ',MSOUPO
            SEGACT MSOUP1,MSOUPO
            MPOVA1 = MSOUP1.IPOVAL
            MPOVAL = IPOVAL
*            WRITE(*,*)'MPOVA1 = ',MPOVA1
*            WRITE(*,*)'MPOVAL = ',MPOVAL
            SEGACT MPOVA1,MPOVAL*MOD
            N  = MPOVA1.VPOCHA(/1)
*            WRITE(*,*)'RCDEP2: N = ',N
            NC = MPOVA1.VPOCHA(/2)
*            WRITE(*,*)'RCDEP2: NC = ',NC
*****            si NSOUPO < NSOUP1 
*              & si NSOUPO < ISOU+1
*              & si MSOUP1.NOCOMP(IC)=MOTLAG
*              on ne peut pas impl�menter ISOU pour les deux,
*              il faut incr�menter MSOUP1 sans incr�menter MSOUPO
            IF (NSOUPO.LT.NSOUP1) THEN
              IF (NSOUPO.LT.(ISOU+1)) THEN
*                WRITE(*,*)'RCDEP2 : on ne peut pas sauter'
                DO IC=1,NC
                  IF ((MSOUP1.NOCOMP(IC)).EQ.MOTLAG) THEN
*                    WRITE(*,*)'RCDEP2 : soupo des mult. de Lag.'
*                    SEGDES MSOUP1,MPOVA1
                    MSOUP1=MCHPO1.IPCHP(ISOU+1)
*                    WRITE(*,*)'RCDEP2 : nouveau MSOUP1 = ',MSOUP1
                    SEGACT MSOUP1
                    MPOVA1 = MSOUP1.IPOVAL
                    SEGACT MPOVA1
                    N  = MPOVA1.VPOCHA(/1)
                    NC = MPOVA1.VPOCHA(/2)
                    LJOK=.TRUE.
*                    WRITE(*,*)'RCDEP2 : on reprend'
                    GOTO 30
                  ENDIF
                ENDDO
              ENDIF
            ELSEIF (NSOUPO.GT.NSOUP1) THEN
              WRITE(*,*)'Cas NSOUPO > NSOUP1'
              IF (NSOUP1.LT.(ISOU+1)) THEN
*                WRITE(*,*)'Initialement : '
*                WRITE(*,*)'RCDEP2: N = ',VPOCHA(/1)
*                WRITE(*,*)'RCDEP2: NC = ',VPOCHA(/2)
                NC1 = NOCOMP(/2)
                DO IC1=1,NC1
                  IF ((NOCOMP(IC1)).EQ.MOTLAG) THEN
*                    WRITE(*,*)'RCDEP2 : soupo des mult. de Lag.'
*                    SEGDES MSOUPO,MPOVAL
                    MSOUPO = IPCHP(ISOU+1)
*                    WRITE(*,*)'MSOUPO = ',MSOUPO
                    SEGACT MSOUPO
                    MPOVAL = IPOVAL
*                    WRITE(*,*)'MPOVAL = ',MPOVAL
                    SEGACT MPOVAL*MOD
                    N  = VPOCHA(/1)
                    NC = VPOCHA(/2)
                    LJOK=.TRUE.
*                    WRITE(*,*)'RCDEP2: N = ',N
*                    WRITE(*,*)'RCDEP2: NC = ',NC
*                    WRITE(*,*)'RCDEP2 : on reprend'
                    GOTO 30                    
                  ENDIF
                ENDDO
              ENDIF
            ENDIF
 30         CONTINUE
*            WRITE(*,*)'Sortie boucle 30'
*****
            DO 24 IC = 1,NC
*               WRITE(*,*)'RCDEP2: boucle 24 IC = ',IC
*              On saute les mult. de Lag. :
               IF ((MSOUP1.NOCOMP(IC)).EQ.MOTLAG) THEN
*                WRITE(*,*)'saut du MSOUP1 mult. Lag.'
                 GOTO 22
               ENDIF
               DO 26 IN = 1,N
*                 WRITE(*,*)'RCDEP2: boucle 26 IN = ',IN
* OLD: FAUX, maintenant, on saute les mult de Lagrange
* MATT: On a calque le CHPOINT de SORTIE sur la premiere def modale. 
* Or parfois, le SOUPO des mult de Lagrange des moes suivants 
* a un VPOCHA(/1) superieur a celui qui a dimensionne le CHPOINT de sortie
* N = (nbr de points concern�s par les CL * nbr de composantes concernees)
* Il est donc necessaire de redimensionner MPOVAL de sortie.
* Ex .dgibi: FSB en chute libre
*                  IF (IN.GT.VPOCHA(/1)) THEN
*                    N = N + 1
*                    SEGADJ, MPOVAL
*                  ENDIF
*                  WRITE(*,*)'RCDEP2: XVAL = ',XVAL
*                  WRITE(*,*)'RCDEP2: MPOVA1.VPOCHA(IN,IC) = ',
*     &                               MPOVA1.VPOCHA(IN,IC)
*                  WRITE(*,*)'RCDEP2: VPOCHA(',IN,IC,') = ',VPOCHA(IN,IC)
      VPOCHA(IN,IC)=VPOCHA(IN,IC)+ ( XVAL*MPOVA1.VPOCHA(IN,IC) )
 26            CONTINUE
*               WRITE(*,*)' Contrib. modale . suivante'
 24         CONTINUE
*            WRITE(*,*)'MPOVA1 = ',MPOVA1
*            WRITE(*,*)'MPOVAL = ',MPOVAL
*            SEGDES MPOVA1,MPOVAL
*            SEGDES MSOUP1,MSOUPO
*            WRITE(*,*)'FIN ISOU  = ',ISOU
            IF (LJOK) THEN 
              SEGDES MCHPO1
              GOTO 20
            ENDIF
 22      CONTINUE
         SEGDES MCHPO1
        GOTO 20
       ENDIF
* fin if itbmod tabl et nn nul
      SEGDES MCHPOI
*** fin RECO modes elastiques
      
*
*****************************************************************
*     Prise en compte de la rotation des corps rigide
*****************************************************************
      IF ((ITYP.EQ.0.OR.ITYP.EQ.1.OR.ITYP.EQ.-1).AND.(RIGIDE)) THEN
* On rajoute les eventuelles composantes (=0) manquantes parmis:
*   UX, UY, ou UZ via adcomp.eso:
         CALL ADCOMP(ICHDE)
         CALL ADCOMP(ICHD1)
* Remarque: ICHD1 est utilise comme modele pour la reco elastique
*           dans RECORIG. Par consequent, les chpoint qui en 
*           decoulent comporte les comp. UX,UY et UZ.
* 
*         WRITE(*,*)'RCDEP2 : appel RECORIG'
         CALL RECORIG(IBAS,ITRES,IPOS,ITYP,ICHD1,ICHDE,
     &                KTRAV,KCPR,KCHAR,XTEMP,ITLIA,LTRIG)
* Rq: KTRAV,KCPR,KCHAR,XTEMP,ITLI: uniquement pour l'appel 
*                 a rcdepel.
      ENDIF
****************************************************************
*     Prise en compte des pseudo-modes
*
      IF (KCHAR.NE.0 .OR. ITLIA.NE.0) THEN
        TYPRET = ' '
        CALL ACCTAB(IBAS,'MOT',I0,X0,'PSEUDO_MODES',L0,IP0,
     &                  TYPRET,I1,X1,CHARRE,L1,ITPS)
       IF (ITPS.NE.0 .AND. TYPRET.EQ.'TABLE   ') THEN
          IF (ITYP.EQ.0.OR.ITYP.EQ.1.OR.ITYP.EQ.-1) THEN
       CALL PSRCD2('DEPL',ITPS,IBBB,ICHDE,KCHAR,XTEMP,ITRES,IPOS,ITLIA)
          ELSE IF (ITYP.EQ.2) THEN
       CALL PSRCD2('REAC',ITPS,IBBB,ICHDE,KCHAR,XTEMP,ITRES,IPOS,ITLIA)
*--------------------------------------------------------------------*
          ENDIF
       ELSE
          CALL ERREUR(429)
       ENDIF
      ENDIF
* fin if pseudo modes
*
      END

*--------------------------------------------------------------------*


 
 
