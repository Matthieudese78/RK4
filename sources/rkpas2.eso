      SUBROUTINE RKPAS2(Q1,Q2,Q3,NA1,NPC1,XK,XASM,XM,PDT,T,NPAS,
     &   FTOTA,FEXA,NPFEXA,NLIAA,NLSA,IPALA,IPLIA,XPALA,XVALA,
     &   NLIAB,NLSB,NPLB,IDIMB,IPALB,IPLIB,JPLIB,XPALB,XVALB,FTOTB,
     &   FTOTBA,XPTB,FEXPSM,
     &   FINERT,IERRD,FTEST,FTEST2,WEXT,WINT,
     &   XABSCI,XORDON,NIP,FTEXB,FEXB,KTROT,KTPHI,XCHPFB,
     &   XOPM1,NB1,NB1K,NB1C,NB1M,NSB,NTOT) 
     
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*                                                                    *
*     Op�rateur DYNE : algorithme des DIFFERENCES CENTREES           *
*     ________________________________________________               *
*                                                                    *
*     Calcul d'un pas de temps, appel aux s-p sp�cifiques.           *
*                                                                    *
*     Param�tres:                                                    *
*                                                                    *
* es  Q1(,)   Vecteur des d�placements g�n�ralis�s                   *
* es  Q2(,)   Vecteur des vitesses g�n�ralis�es                      *
* es  Q3(,)   Vecteur des acc�l�rations g�n�ralis�es                 *
* es  NA1     Nombre total d'inconnues en base A                     *
* es  NPC1    Nombre de pas de calcul - 1                            *
* es  XK      Vecteur des raideurs g�n�ralis�es                      *
* es  XASM    Vecteur des amortissements g�n�ralis�s                 *
* es  XM      Vecteur des masses g�n�ralis�es                        *
* e   PDT     pas de temps courant                                   *
* e   T       temps courant                                          *
* e   NPAS    Num�ro du pas de temps                                 *
* es  FTOTA   Forces ext�rieures totalis�es, sur la base A           *
* es  FEXA    Evolution des forces ext�rieures en base A             *
* e   FTEXB   Evolution des forces ext�rieures en base B             *
* e   FEXB    Forces ext�rieures sur la base B, servant au calcul    *
*             des moments pour les corps rigides.                    *
* e   RIGIDE  Vrai si corps rigide, faux sinon                       *
* es  IFEXA   Num�ro du mode correspondant au point de chargement    *
*             (supprime le 2018-12-14 par bp)                        *
* es  NPFEXA  Nombre de points de chargement                         *
* e   NLIAA   Nombre de liaisons sur la base A                       *
* e   NLSA    Nombre de liaisons A en sortie                         *
* e   IPALA   Tableau renseignant sur le type de liaison (base A)    *
* e   IPLIA   Tableau contenant les num�ros "DYNE" des points        *
* e   XPALA   Tableau contenant les param�tres des liaisons          *
* es  XVALA   Tableau contenant les variables internes de liaison A  *
*     XPHILB  Vecteur des deformees modales                          *
* e   NLIAB   Nombre de liaisons sur la base B                       *
* e   NLSB    Nombre de liaisons base B en sortie                    *
* e   NPLB    Nombre total de points de liaisons (base B)            *
* e   IDIMB   Nombre de directions                                   *
* e   IPALB   Tableau renseignant sur le type de liaison             *
* e   IPLIB   Tableau contenant les numeros "DYNE" des points        *
* e   JPLIB   Tableau contenant les numeros "GIBI" des points        *
* e   XPALB   Tableau contenant les parametres des liaisons (base B) *
* es  XVALB   Tableau contenant les variables internes de liaison B  *
*     FTOTB   Forces exterieures totalisees sur la base B            *
* e   XABSCI  Tableau contenant les abscisses de la loi plastique    *
* e   XORDON  Tableau contenant les ordonnees de la loi plastique    *
* e   NIP     Nbr de points dans l'evolution de la loi plastique     *
*     FTOTBA  Forces totales base B projetees base A                 *
*     XPTB    Deplacements des points de liaison                     *
*     IBASB   Appartenance des points de liaison a une sous-base     *
*     IPLSB   Position du point de liaison dans la sous-base         *
*     INMSB   Nombre de modes dans la sous-base                      *
*     IORSB   Position du 1er mode de la sous-base dans ens. modes   *
*     IAROTA  Indique la position des modes de rotation              *
*     NSB     Nombre de sous-bases                                   *
*     NPLSB   Nombre de points de liaison par sous base              *
*     IERRD   Indicateur d'erreur                                    *
* -   FTEST   Tableau local FTEST de la subroutine D2VLFA            *
* -   FTEST2  Tableau local FTEST de la subroutine DEVLB1            *
* e,s WEXT   travail des forces exterieures                          *
* e,s WINT   travail des forces interieures (rigidite et             *
*            amortissement et forces de liaison )                    *
*                                                                    *
*     fmomtot : couple exterieur dans le body frame pour la phase rk4!!
*--------------------------------------------------------------------*
*
-INC CCREEL
*
      SEGMENT,MTPHI
         INTEGER IBASB(NPLB),IPLSB(NPLB),INMSB(NSB),IORSB(NSB)
         INTEGER IAROTA(NSB)
         REAL*8 XPHILB(NSB,NPLSB,NA2,IDIMB)
      ENDSEGMENT
      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EDEF(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XMNO(NA2,NSB),QVTH(3,NSB),QVR(3,NSB),QVF(NA2,NSB)
         REAL*8 MRTH(3,3,NSB),MTHTH(3,3,NSB)
         REAL*8 MFTH(NA2,3,NSB),MFR(NA2,3,NSB),MTOT(NTOT,NTOT,NSB)
         REAL*8 SKL(3,3,NA2,NA2,NSB),IKL(3,3,NA2,NSB)
         REAL*8 XMPOI(NPDEF,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT
      
*
*      INTEGER IFEXA(*),IPALA(NLIAA,*),IPLIA(NLIAA,*)
      INTEGER IPALA(NLIAA,*),IPLIA(NLIAA,*)
      INTEGER IPALB(NLIAB,*),IPLIB(NLIAA,*),JPLIB(*)
      REAL*8 Q1(NA1,*),Q2(NA1,*),Q3(NA1,*)
* Matt: ligne parmetres corps rigide:
      REAL*8 DYN2(3),DQUAT(4)
*
      REAL*8 XVALA(NLIAA,4,*),XPALA(NLIAA,*),XM(NA1,*),XK(NA1,*)
      REAL*8 XPALB(NLIAB,*),XVALB(NLIAB,4,*),FEXPSM(NPLB,NPC1,2,*)
      REAL*8 XASM(NA1,*),FTOTA(NA1,*),FEXA(NPFEXA,NPC1,*)
      REAL*8 FTOTB(NPLB,*),FTOTBA(*),XPTB(NPLB,2,*),FINERT(NA1,*)
      REAL*8 WEXT(NA1,2),WINT(NA1,2)
      REAL*8 XABSCI(NLIAB,*),XORDON(NLIAB,*),FEXB(NPLB,3,*)
      REAL*8 FTEST(NA1,4), FTEST2(NPLB,6)
      REAL*8 FTEXB(NPLB,NPC1,2,*),XCHPFB(2,NLIAB,4,NPLB)
cbp,2020-09      REAL*8 XOPM1(NB1,NB1,*),Q2DEMI(NA1),FAMOR(NA1)
      REAL*8 XOPM1(NB1,NB1,*),FAMOR(NA1)
      
*     TODO : KTOTXA et KTOTVA a allouer dans le segment LOCLFA ?
      REAL*8 KTOTXA(NA1,NA1), KTOTVA(NA1,NA1) 
*     TODO : KTOTXB et KTOTVB a allouer dans le segment LOCLFB ?
      REAL*8 KTOTXB(NPLB,IDIMB,IDIMB),KTOTVB(NPLB,IDIMB,IDIMB) 
*
c     LOGICAL LWRITE
      LOGICAL RIGIDE,lxpinv,linert,methJ1,methJ2
* CMS : 
      REAL*8 FAMO1(NA1),FAMO2(NA1)
cms : pour le couple resistant "hard code" : 
      real*8 tspin(3)
*     pour le calcul des forces d'inerties :
      logical lrspin,lbt,lcb 
*     vecteurs de rotations incrementaux :
      real*8 th1(3), th2(3), th3(3), th4(3) 
*      real*8 mdexp(3,3)
*     accelerations translations rigides + couple inertiel base A (body frame): 
      real*8 atrans(3),ginea(3)
      real*8 ftrans(3)
      real*8 rtgex(3),jw(3),wjw(3)
*      real*8 ine(3,3),invine(3,3)

*     resistance au spin ?
      lrspin = .false.
*     correction dexpinv ?
      lxpinv = .false.
*     couplage inertiel ?
      linert = .true.
*     method de calcul de la MAJ du tenseur d'inertie J ?
      methJ1 = .false.
      methJ2 = .true.
*     book toss ?
      lbt = .false.
*     coulombic soft wall ?
      lcb = .false.

*     le cas echeant, base modale de l'adaptateur : 
      ibad = 1

      RIGIDE = (KTROT.NE.0)
      IF (RIGIDE) THEN
        MTROT = KTROT
        npdef = xtphi(/2)
      ENDIF
      MTPHI  = KTPHI
      NSB = XPHILB(/1)
      NPLSB = XPHILB(/2)
      NA2 =  XPHILB(/3)
*      IF (IIMPI.EQ.555) THEN 
cmsw        WRITE(*,*)'D2VPAS: KTROT = ',KTROT
cmsw        WRITE(*,*)'        RIGIDE = ',RIGIDE
cmsw        WRITE(*,*)'        NSB =',NSB
cmsw        WRITE(*,*)'        IDIMB = ',IDIMB
cmsw        WRITE(*,*)'        NLIAA = ',NLIAA
cmsw        WRITE(*,*)'        NLIAB = ',NLIAB
*      ENDIF
* Calcul de IDIM pour le calcul de l energie cinetique :
      IF (IDIMB.EQ.6) THEN
        IDIM=3
      ELSEIF (IDIMB.EQ.3) THEN
        IDIM=2
      ENDIF
C     Parametres d'affichage (pour debuggage) 
c     LWRITE=.false.
c     LWRITE=(NPAS.LE.20).OR.(MOD(NPAS,1000).EQ.0)
c     if(LWRITE) write(*,*) '-------- NPAS =',NPAS

************************************************************************
*     Parametres temporels locaux
************************************************************************
      tdeb = T
      tfin = T + PDT
      dt = PDT
      dt2 = dt/2.D0
      dt22 = dt*dt2

*     write(*,*)'rkpas : indice 5 :'
*     write(*,*)'        mat. inertie :'
*     do id=1,3
*        write(*,'(3(1X,F8.5))') , (inertie(id,j,1),j=1,3)
*     enddo
*     write(*,*)'         omeg2 :'
*     WRITE(*,'(3(1X,F8.5))')((omeg2(id,5,1),id=1,3),isb=1,nsb)
*     write(*,*)'         omeg3 :'
*     WRITE(*,'(3(1X,F8.5))')((omeg3(id,5,1),id=1,3),isb=1,nsb)
************************************************************************
*     remplissage de fexb(ip,1,id) et ftota(i,1) : "les deux extremites du pas de temps"
************************************************************************
*     pas de conditoin sur l'appel a d2vfxa.
      CALL RKFXA(FEXA,FTOTA,NPFEXA,NA1,NPC1,NPAS,FTEXB,FEXB,
     &              NPLB,IDIMB,RIGIDE)
*      write(*,*)'rkpas : fexb :'
*      write(*,'(3(1X,F8.5))') , ((fexb(ip,3,j),j=1,3),ip=1,nplb)
*      write(*,*)'rkpas : ftota :'
*      do i=1,na1
*      write(*,'(3(1X,F8.5))') , (ftota(i,ind1),ind1=1,3)
*      enddo
*      write(*,*)'rkpas : finert :'
*      do i=1,na1
*      write(*,'(1X,F8.5)') , finert(i,1)
*      enddo
* ddls elastiques :  
*      do in=1,npfexa 
**        fel(in,3) = ftota(in,2)
**       force au demi-pas de temps :
*        fel(in,2) = fota(in,2) + ((ftota(in,1) - ftota(in,2))/2.d0)
*        fel(in,2) = 
*      enddo
      
************************************************************************
*     todo : ici : l'interpolation des forces exterieures
************************************************************************

************************************************************************
*     Corps rigides: prediction, MAJ matrice de rotation
************************************************************************
* TODO dans D2VINI / DYNE18: initialisation de toutes les ss bases
* pour l'instant, seulement 1 seule ss base inititalisee
     
*      
      IF (RIGIDE) THEN
        NSB = ROT(/4)
        DO 7 IIB=1,NSB
CMS :     Rotas rigides ssi il y a une grande rota ds la ss base en question !!
cmsw          WRITE(*,*)'D2VPAS : IAROTA(',IIB,') = ',IAROTA(IIB)
          IF (IAROTA(IIB).EQ.0) GOTO 7
*          write(*,*)'rkpas : rot tt debut : indice 5'
*          do id=1,3
*              write(*,'(3(1X,F8.5))') , (rot(id,j,5,iib),j=1,3)
*          enddo

*         mise a 0 des couples ext. :
          do id=1,3
            fmomtot(id,1,iib) = 0.d0
            fmomtot(id,2,iib) = 0.d0
            fmomtot(id,3,iib) = 0.d0
            fmomtot(id,4,iib) = 0.d0
            fmomtot(id,5,iib) = 0.d0
          enddo
*         th1 correspond au plan tangent en t_n --> on y est deja!
          do id=1,3
            th1(id) = 0.d0
          enddo
************************************************************************
*         k1 = (w1,a1)^T avec :
*           - w1 = omeg2(id,5,iib)
*           - a1 = omeg3(id,5,iib)
************************************************************************
*          u2 = (th2,w2) = y + dt2*k1 : 
************************************************************************
          do id=1,3
            th2(id) = omeg2(id,5,iib) * dt2
            omeg2(id,4,iib)  = omeg2(id,5,iib) + omeg3(id,5,iib) * dt2
          enddo
************************************************************************
*          calcul de EXPTH pour eq. dynamique:
          CALL VECT2QUAT(TH2(1),DQUAT)
*          MAJ quaternion OMEG1:
          CALL PQUAT(OMEG1(1,5,IIB),DQUAT,OMEG1(1,4,IIB))
*          quaternion a l'instant tn+1:
          CALL QUAT2MAT(OMEG1(1,4,IIB),ROT(1,1,4,IIB)) 
*           write(*,*)'rkpas : rot 1st pred : indice 4'
*           write(*,*)'        omeg2 :'
*           write(*,'((1X,F8.5))') , (omeg2(id,5,iib),id=1,3)
*           write(*,*)'        omeg3 :'
*           write(*,'((1X,F8.5))') , (omeg3(id,5,iib),id=1,3)
*           write(*,*)'        th2 :'
*           write(*,'((1X,F8.5))') , (th2(id),id=1,3)
*           write(*,*)'        dquat :'
*           write(*,'((1X,F8.5))') , (dquat(id),id=1,4)
*           write(*,*)'        omeg1 :'
*           write(*,'((1X,F8.5))') , (omeg1(id,4,iib),id=1,4)
*           write(*,*)'        rot :'
*           do id=1,3
*               write(*,'(3(1X,F8.5))') , (rot(id,j,4,iib),j=1,3)
*           enddo

*          equilibre dynamique : 1/2 pdt --> ifex = 3
          call rkpasrig(omeg1,omeg2,omeg3,rot,mthth,invinert,nsb,iib,
     &                  th2,fmomtot,xcoolb,fexb,nplb,4,3,lxpinv,.true.,
     &                  lcb)

************************************************************************
*         "rappatriement" sur le plan tangent en t_n de :
*           - du vecteur de rotation thi, i = 1,
*           - du vecteur de rotation
************************************************************************
*         k2 = (w2,a2)^T avec :
*           - w2 = omeg2(id,4,iib)
*           - a2 = omeg3(id,4,iib)
************************************************************************
*          u3 = (th3,w3) = y + dt2*k2 : 
************************************************************************
          do id=1,3
            th3(id) = omeg2(id,4,iib) * dt2
            omeg2(id,3,iib)  = omeg2(id,5,iib) + omeg3(id,4,iib) * dt2
          enddo
************************************************************************
*          calcul de EXPTH pour eq. dynamique:
          CALL VECT2QUAT(TH3(1),DQUAT)
*          MAJ quaternion OMEG1:
          CALL PQUAT(OMEG1(1,5,IIB),DQUAT,OMEG1(1,3,IIB))
*          quaternion a l'instant tn+1:
          CALL QUAT2MAT(OMEG1(1,3,IIB),ROT(1,1,3,IIB)) 
*          equilibre dynamique : 1/2 pdt --> ifex = 3
          call rkpasrig(omeg1,omeg2,omeg3,rot,mthth,invinert,nsb,iib,
     &                  th3,fmomtot,xcoolb,fexb,nplb,3,3,lxpinv,.true.,
     &                  lcb)
************************************************************************
*         k3 = (w3,a3)^T avec :
*           - w3 = omeg2(id,3,iib)
*           - a3 = omeg3(id,3,iib)
************************************************************************
*          u4 = (th4,w4) = y + dt*k2 : 
************************************************************************
          do id=1,3
            th4(id) = omeg2(id,3,iib) * dt
            omeg2(id,2,iib)  = omeg2(id,5,iib) + omeg3(id,3,iib) * dt
          enddo
************************************************************************
*          calcul de EXPTH pour eq. dynamique:
          CALL VECT2QUAT(TH4(1),DQUAT)
*          MAJ quaternion OMEG1:
          CALL PQUAT(OMEG1(1,5,IIB),DQUAT,OMEG1(1,2,IIB))
*          quaternion a l'instant tn+1:
          CALL QUAT2MAT(OMEG1(1,2,IIB),ROT(1,1,2,IIB)) 
*          equilibre dynamique : t_n+1 --> ifex = 1
          call rkpasrig(omeg1,omeg2,omeg3,rot,mthth,invinert,nsb,iib,
     &                  th4,fmomtot,xcoolb,fexb,nplb,2,1,lxpinv,.true.,
     &                  lcb)
************************************************************************
*         k4 = (w4,a4)^T avec :
*           - w4 = omeg2(id,2,iib)
*           - a4 = omeg3(id,2,iib)
************************************************************************
          do id=1,3
            dtheta(id,iib) = (dt/6.d0)*( omeg2(id,5,iib)
     &                                 + 2.d0*omeg2(id,4,iib)
     &                                 + 2.d0*omeg2(id,3,iib)
     &                                 + omeg2(id,2,iib) )
          enddo
*
          CALL VECT2QUAT(DTHETA(1,IIB),DQUAT)
*          MAJ quaternion OMEG1:
          CALL PQUAT(OMEG1(1,5,IIB),DQUAT,OMEG1(1,1,IIB))
*          quaternion a l'instant tn+1:
          CALL QUAT2MAT(OMEG1(1,1,IIB),ROT(1,1,1,IIB)) 
*         maj des vitesses angulaires :
          do id=1,3
            omeg2(id,1,iib) = omeg2(id,5,iib) +
     &                   (dt/6.d0)*( omeg3(id,5,iib) 
     &                             + 2.d0*omeg3(id,4) 
     &                             + 2.d0*omeg3(id,3) 
     &                             + omeg3(id,2)) 
          enddo
*         si linert : il nous faut une estimation de l'acceleration :
          if (linert) then
            do id=1,3
             omeg3(id,1,iib) = omeg3(id,2,iib)
*              omeg3(id,1,iib) = (1.d0/6.d0)*( omeg3(id,5,iib) 
*     &                                      + 2.d0*omeg3(id,4) 
*     &                                      + 2.d0*omeg3(id,3) 
*     &                                      + omeg3(id,2)) 
            enddo
          endif
******** fin boucle sur les ss bases
 7      continue
      ENDIF
*     fin condition RIGIDE

************************************************************************
*     RK4 : deplacements elastiques 
************************************************************************
*     k1 = (q2(i,5), q3(i,5))^T
*     u2 = y + k1*dt2
************************************************************************
*      write(*,*)'rkpas : indice 5'
*      do i = 1,na1
*      write(*,*)'q1 :',q1(i,5)
*      write(*,*)'q2 :',q2(i,5)
*      enddo

*     write(*,*)'rkpas 1st pred :'
      do i = 1,na1
        q1(i,4) = q1(i,5) + q2(i,5) * dt2
        q2(i,4) = q2(i,5) + q3(i,5) * dt2
*       write(*,*)'q1 :',q1(i,4)
*       write(*,*)'q2 :',q2(i,4)
      enddo
*     1/2 pdt --> ifex = 3
      call rkpasel(q1,q2,q3,xk,xm,ftota,na1,nb1k,nb1c,nb1,famor,
     &             xasm,xopm1,finert,4,3,pdt)
*      write(*,*)'rkpas 1st rkpasel :'
*      do i = 1,na1
*      write(*,*)'q2 :',q2(i,4)
*      write(*,*)'q3 :',q3(i,4)
*      enddo
************************************************************************
*     k2 = (q2(i,4), q3(i,4))^T
*     u3 = y + k2*dt2
************************************************************************
*     write(*,*)'rkpas 2nd pred :'
      do i = 1,na1
        q1(i,3) = q1(i,5) + q2(i,4) * dt2
        q2(i,3) = q2(i,5) + q3(i,4) * dt2
*        write(*,*)'q1 :',q1(i,3)
*        write(*,*)'q2 :',q2(i,3)
      enddo
*     1/2 pdt --> ifex = 3
      call rkpasel(q1,q2,q3,xk,xm,ftota,na1,nb1k,nb1c,nb1,famor,
     &             xasm,xopm1,finert,3,3,pdt)

************************************************************************
*     k3 = (q2(i,3), q3(i,3))^T
*     u4 = y + k3*dt
************************************************************************
*     write(*,*)'rkpas 3rd pred :'
      do i = 1,na1
        q1(i,2) = q1(i,5) + q2(i,3) * dt
        q2(i,2) = q2(i,5) + q3(i,3) * dt
*        write(*,*)'q1 :',q1(i,2)
*        write(*,*)'q2 :',q2(i,2)
      enddo
*     t_n+1 --> ifex = 1
      call rkpasel(q1,q2,q3,xk,xm,ftota,na1,nb1k,nb1c,nb1,famor,
     &             xasm,xopm1,finert,2,1,pdt)
************************************************************************
*     k4 = (q2(i,2), q3(i,2))^T
************************************************************************
      do i=1,na1
*       position :
      q1(i,1)=q1(i,5)+(dt/6.d0)*(q2(i,5) + 2.d0*q2(i,4) + 2.d0*q2(i,3) +
     &                       q2(i,2))
*       vitesse :
      q2(i,1)=q2(i,5)+(dt/6.d0)*(q3(i,5) + 2.d0*q3(i,4) + 2.d0*q3(i,3) +
     &                       q3(i,2))
*       if linert, il nous faut une estimation de l'acceleration :
        if (linert) then
          q3(i,1) = q3(i,2)
*      q3(i,1)=(1.d0/6.d0)*(q3(i,5) + 2.d0*q3(i,4) + 2.d0*q3(i,3) +
*     &                       q3(i,2))
        endif
*      write(*,*)'rkpas avant liaison :'
*      write(*,*)'q1 :',q1(i,1)
*      write(*,*)'q1 :',q1(i,1)
*      write(*,*)'q2 :',q2(i,1)
*      write(*,*)'q2 :',q2(i,1)
      enddo

************************************************************************
*     Calcul des forces de liaisons
************************************************************************
*     Totalisation des forces ext�rieures pour la base A a la fin du pas
        CALL D2VFXA(FEXA,FTOTA,NPFEXA,NA1,NPC1,NPAS,FTEXB,FEXB,
     &              NPLB,IDIMB,RIGIDE)
*     Ajout des forces de liaison
      IF (NLIAA.NE.0) THEN
         CALL D2VLFA(Q1,Q2,FTOTA,NA1,IPALA,IPLIA,XPALA,XVALA,
     &               NLIAA,dt,tfin,NPAS,1,FINERT,0,FTEST,
     &               KTOTXA,KTOTVA,.FALSE.)
      ENDIF
      IF (IIMPI.EQ.333) WRITE(IOIMP,*)'D2VPAS: NLIAB = ',NLIAB
      IF (NLIAB.NE.0) THEN
         IF (IIMPI.EQ.333) THEN
cmsw           WRITE(IOIMP,*)'D2VPAS : appel au sous-programme D2VLFB'
         ENDIF      
*        WRITE(*,*)'rkpas : appel au sous-programme D2VLFB'
*        dernier arg = .false. --> calcul du moment au pas t_n+1 via rkmom
         CALL D2VLFB(Q1,Q2,FTOTA,NA1,IPALB,IPLIB,XPALB,XVALB,NLIAB,
     &               XPHILB,JPLIB,NPLB,IDIMB,FTOTB,FTOTBA,XPTB,dt,tfin,
     &               NPAS,IBASB,IPLSB,INMSB,IORSB,NSB,NPLSB,NA2,1,
     &               FEXPSM,NPC1,IERRD,FTEST2,XABSCI,XORDON,NIP,
     &               FEXB,KTROT,IAROTA,XCHPFB,
     &               KTOTXA,KTOTVA,KTOTXB,KTOTVB,.FALSE.,.false.)
*
         IF (IERRD.NE.0) RETURN
      ENDIF
      if (lrspin) then 
*       achtung!! hard code : pour l'adaptateur : 
*       on impose une raideur en rotation
        xkspin = 5538.73
        call spinextr(ibad,nsb,rot,omeg1,xkspin,tspin)
        fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + tspin(1)
        fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + tspin(2)
        fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + tspin(3)
      endif
*     hard coded external torques :
      if (lbt) then 
        nd = floor(2.d0/pdt)
        if (t.le.(2.-pdt)) then 
          fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 20.
          fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 0.
          fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
        endif
        if ((npas.eq.nd).or.(npas.eq.(nd+1))) then 
          fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 0.
          fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + (2.d-1/pdt)
          fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
        endif
        if (t.ge.(2.+pdt)) then 
          fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 0.
          fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 0.
          fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
        endif
      endif
      if (lcb) then 
        xcgex = ((1.d-2*((1.1+rot(3,3,1,ibad))**(-11.d0))) -
     &                    ((1.1+rot(3,3,1,ibad))**(-2.d0)))
        fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 
     &                       -xcgex*rot(2,3,1,ibad)
        fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 
     &                       xcgex*rot(1,3,1,ibad)
        fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 
     &                        0.
      endif
************************************************************************
*     EquilibreS DynamiqueS (separes)
************************************************************************
* elastique :
************************************************************************
      if (.not.linert) then
        call rkpasel(q1,q2,q3,xk,xm,ftota,na1,nb1k,nb1c,nb1,famor,
     &               xasm,xopm1,finert,1,1,pdt)
*       MAJ vitesse generalisee : pour newmark only
*       do in=1,na1
*         q2(in,1) = q2(in,5) + (dt/2.d0)*(q3(in,1)+q3(in,5))
*       enddo
************************************************************************
* rotas rigides :
************************************************************************
        do 22 iib=1,nsb
        if (iarota(iib).eq.0) goto 22
        call rkpasrig(omeg1,omeg2,omeg3,rot,mthth,invinert,nsb,iib,
     &    dtheta(1,iib),fmomtot,xcoolb,fexb,nplb,1,1,.false.,.false.,
     &    .false.)
*         MAJ vitesse angulaire : pour newmark only
*       do id = 1,3
*         omeg2(id,1,iib) = omeg2(id,5,iib) + 
*    &                    (dt/2.d0)*(omeg3(id,1,iib)+omeg3(id,5,iib))
*       enddo
 22     continue
        
      endif

************************************************************************
* ROTATIONS RIGIDES: calcul des matrices necessaires au calcul des forces d'inertie 
*     dans le repere spatial --> on prend le quaternion omeg1 (orientation dans le repere spatial).
******************************************************************
      if (linert) then
      if (rigide) then
******************************************************************
        do 1 iib=1,nsb
**        na3 : nombre de modes elastiques + translations rig
**              dans la ss base iib.
        na3 = inmsb(iib)
*        premier mode elast ou transl rigi de la sous base iib ds l'ensemble des modes elast + trans rigis
        ina1 = iorsb(iib) - 1
*        initialisation des forces d'inertie, pour ttes les ss bases!
*         --> apparaissent apres dans l'equilibre dynamique
        do id=1,3
          qvr(id,iib) = 0.d0
          qvth(id,iib) = 0.d0
          do j=1,3
            mrth(id,j,iib) = 0.d0
            mthth(id,j,iib) = 0.d0
          enddo
        enddo
        do in=1,na2
          qvf(in,iib) = 0.d0
          do id=1,3
            mfr(in,id,iib) = 0.d0
            mfth(in,id,iib) = 0.d0
          enddo
        enddo
*       maintenant on peut sauter les ss bases ss rotas rigides :
        if (iarota(iib).eq.0) goto 1
******************************************************************
*       indice auquel sont calculees les forces d'inertie :
******************************************************************
        ind1=1
******************************************************************
*     M_{Rth} : couplage rotas-trnaslas shabana p 320
******************************************************************
*        write(*,*)'rkpas call cmrth : rot :'
*        do id=1,3
*           write(*,'(3(1X,F8.5))') , (rot(id,j,ind1,iib),j=1,3)
*        enddo
        call cmrth(Q1,KTROT,NA1,NB1M,IIB,ind1,na3,ina1) 
******************************************************************
******************************************************************
*     M_{fR} (dim : nmodes x 3) : couplage elas-translas shabana p 320
******************************************************************
      call cmfr(Q1,KTROT,NA1,NB1M,IIB,ind1,na3,ina1) 
******************************************************************
******************************************************************
*     M_{fth} (dim : nmodes x 3) : couplage elas-rotas shabana p 320
******************************************************************
      call cmfth(Q1,KTROT,NA1,NB1M,IIB,ind1,na3,ina1) 
*******************************************************************
******************************************************************
*    M_{thth} (dim : 3 x 3) : modif tenseur d'inertie du aux defo elastiques.
*                          (shabana p 320)
******************************************************************
      call cmthth(Q1,KTROT,NA1,NB1M,IIB,ind1,na3,ina1) 
*******************************************************************
* remplissage mtot :  
*******************************************************************
*     objecif : dans la matrice mtot(ntot,ntot,nsb), squizzer en haut a 
*     gauche les parties pleines (necessaire pour inversion via invalm).
*     initialisation :
      do i1=1,ntot
        do i2=1,ntot
          mtot(i1,i2,iib) = 0.d0
        enddo
      enddo
*     on repere le nombre de translations rigides a retirer de la  
*     dimension pour inverser.
      ntrig = 0
      do in=1,na3
        if (itrig(iib,in)) then 
          ntrig = ntrig + 1
        endif
      enddo
****** blocs diagonaux :
*     lignes 1-3 : translations
*     bloc (1,1) : mRR a 
      do id=1,ntrig 
        mtot(id,id,iib) = mtsb(iib) 
      enddo
*     lignes ntrig+1 -> ntrig+3 : rotations
*     bloc (2,2) du milieu : cmthth
      do id=1,3  
        id2 = id + ntrig
        do j=1,3
          j2= j + ntrig
          mtot(id2,j2,iib) = inertie(id,j,iib) + mthth(id,j,iib)
        enddo
      enddo
*     lignes 7-na2 : flexible
*     bloc (3,3) : cmff cas diagonal 
      in1 = 3 + ntrig + 1
      do in=1,na3
        i2 = ina1 + in
        if (.not.itrig(iib,in)) then 
          mtot(in1,in1,iib) = xm(i2,1)  
          in1 = in1 + 1
        endif
      enddo
****** blocs non-diagonaux :
*     bloc (1,2) : mRth 
      do id=1,3
        do j=1,3
          j2 = j + ntrig
          mtot(id,j2,iib) = mrth(id,j,iib)
          mtot(j2,id,iib) = mrth(id,j,iib)
        enddo
      enddo
*     bloc (1,3) : mRf = mfR^T
      in1 = 3 + ntrig + 1
      do in=1,na3
        if (.not.itrig(iib,in)) then
          do id=1,3 
            mtot(in1,id,iib) = mfr(in,id,iib)
            mtot(id,in1,iib) = mfr(in,id,iib)
          enddo
          in1 = in1 + 1
        endif
      enddo
*     bloc (2,3) : cmthf = cmfth^T
      in1 = 3 + ntrig + 1
      do in=1,na3  
        if (.not.itrig(iib,in)) then
          do id=1,3
            id2 = id + ntrig
            mtot(in1,id2,iib) = mfth(in,id,iib)
            mtot(id2,in1,iib) = mfth(in,id,iib)
          enddo
          in1 = in1 + 1 
        endif
      enddo

*      write(*,*)'        matrice totale :'
*      do in=1,ntot
*         write(*,'((16X,F8.5))') , (mtot(in,in1,iib),in1=1,ntot)
*      enddo
*     inversion de mtot : on part du principe qu'il y a 3 rotas rigides 
*         (nbr de modes flexibles = in1 - 7)
      ninv = 3 + na3 
      write(*,*)'rkpas : ntrig = ',ntrig
      write(*,*)'        in1 = ',in1
      write(*,*)'        na2 = ',na2
      write(*,*)'   3 + ntrig    ntot = ',ntot
      write(*,*)'        ninv = ',ninv
      call invalm(mtot,ntot,ninv,kerre,1.d-10)
*      call invalm(mtot(1,1,iib),ntot,ninv,kerre,1.d-10)
      write(*,*)'        matrice inversee :'
*      do i1=1,ntot
*         do i2=1,ntot
*          write(*,*) , mtot(i1,i2,iib)
*         enddo
*      enddo

*******************************************************************
*       Quadratic velocity vector : coriolis, centrifuge ...
********************3 + ntrig*********************************************
*       translation : 
      call cqvr(Q1,q2,KTROT,NA1,IIB,ind1,na3,ina1) 
******************************************************************
*       rotation : 
      call cqvth(Q1,q2,KTROT,NA1,IIB,ind1,na3,ina1) 
******************************************************************
*       coordonnees modales : 
      call cqvf(Q1,q2,KTROT,NA1,IIB,ind1,na3,ina1) 
******************************************************************
******************************************************************
*      on implemente les forces d'inertie d'entrainement
*      dues aux blocs non diagonnaux de la matrice de masse ET
*      au "quadratic velocity vector" :
*      * mthr, mrth, mthf, mfth, mrf, mfr
*      * qvr, qvth, qvf
******************************************************************
      ftrans(1) = 0.d0
      ftrans(2) = 0.d0
      ftrans(3) = 0.d0
      id = 1
      do in=1,na3
        i2 = ina1 + in
*       QVF : 
        if (.not.itrig(iib,in)) then 
          ftota(i2,ind1) = ftota(i2,ind1) + qvf(in,iib)
        endif
*       QVR : 
        if (itrig(iib,in)) then
          ftota(i2,ind1) = ftota(i2,ind1) + qvr(in,iib)
          ftrans(id) = ftota(i2,ind1) 
          id = id + 1
        endif
      enddo
**       on recupere les comp de l'acceleration en translation :
**       Attention : ici il faut qu'il soit dans l'ordre x,y,z ds la base modale.
**
**       write(*,*)'        fmomtot : avant forces inert '
**       write(*,'((1X,F8.5))') , (fmomtot(id,1,iib),id=1,3)
**
**       accel en translation de la ss base iib :
*        atrans(1) = 0.d0
*        atrans(2) = 0.d0
*        atrans(3) = 0.d0
**       couple inertiel en base A (body frame) exerce sur la ss base iib :
*        ginea(1) = 0.d0
*        ginea(2) = 0.d0
*        ginea(3) = 0.d0
*        id=0
*        do in=1,na3
*          i2 = ina1 + in
*          if (itrig(iib,in)) then 
*            id = id+1
*            atrans(id) = q3(i2,ind1)
**           MRTH :
*            do j=1,3
*              ftota(i2,ind1) = ftota(i2,ind1) -
*     &                         mrth(id,j,iib)*omeg3(j,ind1,iib)
*            enddo
*          endif
*        enddo
**       write(*,*)'        atrans :  '
**       write(*,'(3(1X,F8.5))') , (atrans(id),id=1,3)
**
*        do in=1,na3
*          i2 = ina1 + in
*          if (.not.itrig(iib,in)) then 
**           QVF : 
*            ftota(i2,ind1) = ftota(i2,ind1) + qvf(in,iib)
*            do j=1,3
**             MFR :
*              ftota(i2,ind1) = ftota(i2,ind1)-(mfr(in,j,iib)*atrans(j))
**             MTHF :
*              ginea(j) = ginea(j) - (mfth(in,j,iib) * q3(i2,ind1))
**             MFTH :
*              ftota(i2,ind1) = ftota(i2,ind1) -
*     &                         (mfth(in,j,iib) * omeg3(j,ind1,iib))  
*            enddo
*          endif
*        enddo
**
**       MTHR :
*        do id=1,3
**         QVTH : 
*          ginea(id) = ginea(id) + qvth(id,iib)
*          do j=1,3
*            ginea(id) = ginea(id) - (mrth(j,id,iib) * atrans(j))
*          enddo
*        enddo
*
**       write(*,*)'        ginea : avant mrf '
**       write(*,'(3(1X,F8.5))') , (ginea(id),id=1,3)
**       MRF :
*        id = 0
*        do in=1,na3
*          i2=ina1+in
*          if (itrig(iib,in)) then
*            id = id + 1
**           QVR : 
*            ftota(i2,ind1) = ftota(i2,ind1) + qvr(id,iib)
*            do in2=1,na3
*              if (.not.itrig(iib,in2)) then
*                ftota(i2,ind1) = ftota(i2,ind1) -
*     &                           (mfr(in2,id,iib) * q3(in2,ind1))
*              endif
*            enddo
*          endif
*        enddo
*
*       write(*,*)' ginea : fin forces inert '
*       write(*,'(3(1X,F8.5))') , (ginea(id),id=1,3)
************************************************************************
*       NEW MTOT : equilibre dynamique a t_n+1
************************************************************************
*         translations :
*         M^{-1}(1,1) * F_R
          id = 1
          in1 = ntrig + 3 + 1
          do in=1,na3
            i2 = ina1 + in
            q3(i2,1) = 0.d0
            if (itrig(iib,in)) then
              do j=1,ntrig
                q3(i2,1) = q3(i2,1) + mtot(id,j,iib) * ftrans(j)
              enddo
*             M^{-1}(1,2) * F_th
              do j=1,3
                j2 = j + ntrig
                q3(i2,1) = q3(i2,1) +
     &          mtot(id,j2,iib)*(rtgex(j) + qvth(j,iib) - wjw(j))
              enddo
*             M^{-1}(1,3) * F_f
              do inf=1,na3
                i3 = ina1 + inf
                if (.not.itrig(iib,inf)) then
                  q3(i2,1) = q3(i2,1) +
     &            mtot(id,in1,iib)*(FTOTA(i3,1)-FAMOR(i3))
                  in1 = in1 + 1
                endif
              enddo
              id = id + 1
            endif
          enddo
*         rotations :
          do id=1,3 
            id2 = id + ntrig
            in1 = 3 + ntrig + 1
            omeg3(id,1,iib) = 0.d0
            do j=1,3
              j2 = j + ntrig
*             M^{-1}(2,1) * F_R
              omeg3(id,1,iib) = omeg3(id,1,iib) +
     &                          mtot(id2,j,iib) * ftrans(j)
*             M^{-1}(2,2) * F_th
              omeg3(id,1,iib) = omeg3(id,1,iib) +
     &        mtot(id2,j2,iib)*(rtgex(j) + qvth(j,iib) - wjw(j))
            enddo
*            M^{-1}(2,3) * F_f
            do in=1,na3
              i2 = ina1 + in
              if (.not.itrig(iib,in)) then
                omeg3(id,1,iib) = omeg3(id,1,iib) +
     &          mtot(id2,in1,iib)*(FTOTA(i2,1)-FAMOR(i2))  
                in1 = in1 + 1
              endif
            enddo
          enddo
*         flexible :
          in1 = 3 + ntrig + 1
          do in=1,na3
            i2 = ina1 + in
            if (.not.itrig(iib,in)) then
*             M^{-1}(3,1) * F_R
              do j=1,ntrig
                q3(i2,1) = q3(i2,1) + mtot(in1,j,iib) * ftrans(j)
              enddo
*             M^{-1}(3,2) * F_th
              do j=1,3
                j2 = j + ntrig
                q3(i2,1) = q3(i2,1) +
     &          mtot(in1,j2,iib) * (rtgex(j) + qvth(j,iib) - wjw(j))
              enddo
*             M^{-1}(3,3) * F_f
              in2 = 3 + ntrig + 1
              do inf=1,na3
                i3 = ina1 + inf
                if (.not.itrig(iib,inf)) then 
                  q3(i2,1) = q3(i2,1) +
     &                       mtot(in1,in2,iib)*(FTOTA(i3,1)-FAMOR(i3))
                  in2 = in2 + 1
                endif
              enddo
              in1 = in1 + 1
            endif
          enddo
***********************************************************************
*     FIN boucle sur les ss bases
***********************************************************************
 1      continue
***********************************************************************
*     FIN IF RIGIDE
***********************************************************************
      endif
************************************************************************
*     equilibre dynamique a t_n+1
************************************************************************
*     coordonnees modales : modes elastiques + translations rigides 
************************************************************************
*      write(*,*)'   eq. dyn :'
*     ajout des forces de raideurs :
      CALL RKLK0(Q1,XK,FTOTA,NA1,NB1K,1,1)
*     ajout des forces d'amortissement :
      IF (NB1C.GT.1) THEN
        DO I=1,NA1
           FAMOR(I) = 0.D0
          DO J=1,NB1
            FAMOR(I) = FAMOR(I) + XASM(I,J) * Q2(J,1)
          enddo
        enddo
      ELSE
        DO I=1,NA1
           FAMOR(I) = XASM(I,1) * Q2(I,1)
        enddo
      ENDIF

************************************************************************
c    -Cas C ou M pleine : pas de prise en compte des forces d'inertie
      IF (NB1.NE.1) THEN
        DO I=1,NA1
          Q3(I,1) = 0.D0
          DO J=1,NB1
          Q3(I,1) = Q3(I,1) + XOPM1(I,J,1)*(FTOTA(J,1)-FAMOR(J))
          enddo
        enddo
c    -Cas C et M diagonales : on prend en compte les forces d'inertie
      else
        DO I=1,NA1
          UNSM = 1.D0 / ( XM(I,1) + dt2*XASM(I,1) - FINERT(I,1) )
          Q3(I,1) = (FTOTA(I,1)-FAMOR(I)) * UNSM
        enddo
      endif

**     MAJ des vitesses :
*      do in=1,na1
**        q2(in,1) = q2(in,5) + (dt/2.d0)*(q3(in,5)+q3(in,1))
*        q2(in,1)=q2(in,5) + 
*     &  (dt/6.d0)*(q3(in,5) + 2.d0*q3(in,4) + 2.d0*q3(in,3) + q3(in,1))
*      enddo

************************************************************************
*     rotations rigides :  
************************************************************************
      if (rigide) then
       if (lrspin) then 
         fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + tspin(1)
         fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + tspin(2)
         fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + tspin(3)
       endif
       if (lbt) then 
         nd = floor(2.d0/pdt)
         if (t.le.(2.-pdt)) then 
         fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 20.
         fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 0.
         fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
         endif
*        if ((t.ge.(2.-(pdt/1.99))).and.(t.le.(2.+(pdt/1.99)))) then 
         if ((npas.eq.nd).or.(npas.eq.(nd+1))) then 
         fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 0.
         fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + (2.d-1/pdt)
         fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
         endif
         if (t.ge.(2.+pdt)) then 
         fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 0.
         fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 0.
         fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 0.
         endif
       endif
       if (lcb) then 
         xcgex = ((1.d-2*((1.1+rot(3,3,1,ibad))**(-11.d0))) -
     &                    ((1.1+rot(3,3,1,ibad))**(-2.d0)))
         fmomtot(1,1,ibad) = fmomtot(1,1,ibad) + 
     &                       -xcgex*rot(2,3,1,ibad)
         fmomtot(2,1,ibad) = fmomtot(2,1,ibad) + 
     &                       xcgex*rot(1,3,1,ibad)
         fmomtot(3,1,ibad) = fmomtot(3,1,ibad) + 
     &                       0.
       endif
       do 17 iib=1,nsb
          if (iarota(iib).eq.0) goto 17
*         inversion de la matrice d'inertie :
          do id=1,3
            rtgex(id) = 0.d0
            do j=1,3
              rtgex(id) = rtgex(id) + rot(j,id,1,iib)*fmomtot(j,1,iib)
              mthth(id,j,iib) = (mthth(id,j,iib) + inertie(id,j,iib))
*              ine(id,j) = (mthth(id,j,iib) + inertie(id,j,iib))
            enddo
          enddo
*         On calcul l'inverse de la matrice d'inertie : Ithth
          call hinv33(mthth(1,1,iib),invinert(1,1,iib))
*         call hinv33(inertie(1,1,iib),invine(1,1))
*         write(*,*)'rkpas invine : '
          do id=1,3
*             write(*,'(3(1X,F8.5))') , (invine(id,j),j=1,3)
             if (invinert(id,1,iib).ne.invinert(id,1,iib)) then 
              write(*,*)'invinert = NaN!!!'
              call exit(1)
             endif
          enddo
*         on recalcule le terme convectif wjw car j a change :
          do id=1,3
            jw(id) = 0.d0
            do j=1,3
              jw(id) = jw(id) + mthth(id,j,iib)*omeg2(j,1,iib)
            enddo
          enddo
          wjw(1) = omeg2(2,1,iib)*jw(3) - omeg2(3,1,iib)*jw(2) 
          wjw(2) = omeg2(3,1,iib)*jw(1) - omeg2(1,1,iib)*jw(3) 
          wjw(3) = omeg2(1,1,iib)*jw(2) - omeg2(2,1,iib)*jw(1) 
*
          do id = 1,3
            omeg3(id,1,iib) = 0.d0
            do j = 1,3
              omeg3(id,1,iib) = omeg3(id,1,iib) + 
     &        invinert(id,j,iib) * (rtgex(j) + qvth(j,iib) - wjw(j))
*     &        invinert(id,j,iib) * (rtgex(j) + ginea(j) - wjw(j))
            enddo
          enddo
**         MAJ vitesse angulaire :
*          do id = 1,3
**            omeg2(id,1,iib) = omeg2(id,5,iib) + 
**     &                 (dt/2.d0)*(omeg3(id,1,iib)+omeg3(id,5,iib))
*            omeg2(id,1,iib) = omeg2(id,5,iib) +
*     &                        (dt/6.d0)*( omeg3(id,5,iib) 
*     &                                  + 2.d0*omeg3(id,4) 
*     &                                  + 2.d0*omeg3(id,3) 
*     &                                  + omeg3(id,1)) 
*          enddo

*           write(*,*)'rkpas : fin du pas indice 1 : '
*           write(*,*)'        rtgex :'
*           write(*,'((1X,F8.5))') , (rtgex(id),id=1,3)
*           write(*,*)'        fmomtot :'
*           write(*,'((1X,F8.5))') , (fmomtot(id,1,iib),id=1,3)
*           write(*,*)'        omeg2 :'
*           write(*,'((1X,F8.5))') , (omeg2(id,1,iib),id=1,3)
*           write(*,*)'        omeg3 :'
*           write(*,'((1X,F8.5))') , (omeg3(id,1,iib),id=1,3)
 17    continue
      endif
*     new : on garde la config modifiee du tenseur d'inertie, 
*           elle sera implementee a chaque pdt : to try
************************************************************************
*     fin if linert
************************************************************************
      endif
************************************************************************
*     Energies
************************************************************************
      IF (RIGIDE) THEN
       DO 8 IIB=1,NSB
          na3  = inmsb(iib)
          ina2 = iorsb(iib) - 1
CMS :     pour l'energie de deformation et cinetique (xec), on a calule pour ttes les ss bases, rots rigides ou non : 
          xec = 0.d0
          edef(iib) = 0.d0
          do in=1,na3
            i2 = in + ina2
            wint(i2,1) = 0.d0
            wext(i2,1) = 0.d0
            if (.not.itrig(iib,in)) then
             wint(i2,1) = (xk(i2,1) * (q1(i2,1)**2)/2.d0)
             edef(iib) = edef(iib) + wint(i2,1)
*            energie cinetique associee au mode i2 :
             wext(i2,1) = (xm(i2,1) * (q2(i2,1)**2)/2.d0)
             xec = xec + wext(i2,1)
            endif
          enddo
*         les slots wext et wint sont libres car on appelle pas d2vene.
*         --> on les utilise pour edef et ecin qu'ons stock dans les premiers modes.
*          if (iarota(iib).eq.0) then
*            wint(1,1) = edef(iib)
**           old : energie cinetique :
*            xec = 0.d0
*            do in=1,na3
*              IF (.not. (ITRIG(IIB,IN))) THEN
*                i2 = in + ina2
*                xec = xec + (5.d-1 * xm(i2,1) * (q2(i2,1)**2))
*                xec = xec + wext(i2,1)
*              endif
*            enddo
*            wext(1,1) = xec
*          endif
*          if (lcb) then 
**           energie potentielle magnetique :
*            edef(iib) = edef(iib) - (- ((1.1+rot(3,3,1,ibad))**(-1.d0))
*     &               + (1.d-3*((1.1+rot(3,3,1,ibad))**(-10.d0))))
*          endif
*         write(*,*)'rkpas : edef = ',edef(iib)
CMS :     Rotas rigides ssi il y a une grande rota ds la ss base en question !!
          IF (IAROTA(IIB).EQ.0) GOTO 8
***       Calcul du moment cinetique : 
          DO I=1,3
            PICIN(IIB,I) = 0.D0
            DO J=1,3
              DYN2(J) = 0.D0
              DO K=1,3
                DYN2(J) = DYN2(J) +
     &                    ROT(I,K,1,IIB)*mthth(K,J,IIB)
              ENDDO
              PICIN(NSB,I) = PICIN(IIB,I)+DYN2(J)*OMEG2(J,1,IIB)
            ENDDO
          ENDDO
***       Calcul de l energie cinetique en rotation : 
*          TCIN(IIB) = 0.D0
*         on va rajouter a l'energie cinetique sous forme de vribrations elastiques :
*          TCIN(IIB) = xec
          TCIN(IIB) = 0.d0
*         write(*,*)'xec = ',xec
          DO I=1,3
            DYN2(I) = 0.D0
            DO J=1,3
              DYN2(I) = DYN2(I) + mthth(I,J,IIB)*OMEG2(J,1,IIB)
            ENDDO
            TCIN(IIB) = TCIN(IIB) + (OMEG2(I,1,IIB)*DYN2(I)/2.d0) 
          ENDDO
*          NA3  = INMSB(IIB)
*              = nbr de modes elasiques ds la ss base (incluant les transl. rigides)
*          INA2 = IORSB(IIB) - 1
          XTC = 0.D0
          DO IN = 1,NA3
            IN2 = INA2 + IN
            IF ((ITRIG(IIB,IN))) THEN
*             Energie cinetique translation : 
              DO ID=1,IDIM
                XTC = XTC + 
     &            0.5*MTSB(IIB)*((XPHILB(IIB,1,IN,ID)*Q2(IN2,1))**2.d0) 
              ENDDO
*            ELSE
**             Energie cinetique modes flexibles : 
*              XTC = XTC + (0.5 * (Q2(IN2,2)**2) * XM(IN,1))
            ENDIF 
          ENDDO
          TCIN(IIB) = TCIN(IIB) + XTC
*         Energie potentielle de pesanteur : 
*           - la gravite est en -ez
*           - le cdm du solide est le point de liaison numero 1 
*         if (nliab.ne.0) then
*           epot(iib) = xptb(1,1,3)*mtsb(iib)*9.81 
*         endif
*         write(*,*)'tcin = ',tcin(iib)
 8     CONTINUE
* fin boucle ss bases
      ENDIF
*
      END

 
 
 
 
