C DYNE26    SOURCE    CB215821  20/11/04    21:16:12     10766          
      SUBROUTINE DYNE26(IBAS,KTKAM,KTLIAB,KTPHI,IA1,IB,ICOMP,
     &                  KTROT,ITCARA,LMODYN,ITKM,KCPRIG)
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8(A-H,O-Z)
*--------------------------------------------------------------------*
*                                                                    *
*     Operateur DYNE : algorithme de Fu - de Vogelaere               *
*     ________________________________________________               *
*                                                                    *
*     Transpose l'information des objets de Castem2000 dans des      *
*     tableaux de travail.                                           *
*                                                                    *
*     Parametres:                                                    *
*                                                                    *
* e   IBAS    Table representant une base modale                     *
* es  KTKAM   Segment contenant les matrices XK, XASM et XM          *
* es  KTPHI   Segment des deformees modales                          *
* e   KTLIAB  Segment des liaisons sur base B                        *
* es  IA1     Compteur                                               *
* e   IB      Compteur de la sous base                               *
* es  RIGIDE  Vrai si l'on a un corps rigide, faux sinon             *
* e   LMODYN  Logique = vrai si table PASAPAS                        *
* e   ITKM    >0 si table RAIDEUR_ET_MASSE fournie                   *
*                                                                    *
*     Auteur, date de creation:                                      *
*                                                                    *
*     Lionel VIVAN, le 24 octobre 1989.                              *
*                                                                    *
*     MAJ par Matthieu Serre: 2020-2021                              *
*       prise en compte des rotations rigide en dime 3 & 2           *
*  - Les rotas rigide sont maintenant traitees vie la seg. MTROT     *
*  - Les tables IAROTA et INMSB et IBASB du segment MTPHI sont       *
*    toujours necessaires pour le traitement des rotas rigides       *     
*--------------------------------------------------------------------*

-INC PPARAM
-INC CCOPTIO
-INC CCREEL
-INC SMCHAML
-INC SMELEME
-INC SMMODEL
-INC SMCOORD
*
      SEGMENT,MTKAM
         REAL*8 XK(NA1,NB1K),XASM(NA1,NB1C),XM(NA1,NB1M)
         REAL*8 XOPER(NB1,NB1,NOPER)
      ENDSEGMENT
*
      SEGMENT,MTPHI
         INTEGER IBASB(NPLB),IPLSB(NPLB),INMSB(NSB),IORSB(NSB)
         INTEGER IAROTA(NSB)
         REAL*8 XPHILB(NSB,NPLSB,NA2,IDIMB)
      ENDSEGMENT
*
      SEGMENT,MTLIAB
         INTEGER IPALB(NLIAB,NIPALB),IPLIB(NLIAB,NPLBB),JPLIB(NPLB)
         REAL*8 XPALB(NLIAB,NXPALB)
         REAL*8 XABSCI(NLIAB,NIP),XORDON(NLIAB,NIP)
      ENDSEGMENT
*
      SEGMENT,MTROT
         REAL*8 OMEG1(4,5,NSB),OMEG2(3,5,NSB),OMEG3(3,5,NSB)
         REAL*8 ROT(3,3,5,NSB),EXPTH(3,3,2,NSB),INERTIE(3,3,NSB)
         REAL*8 XCENT(3,NSB),XCOOLB(3,NSB,NPLB),DTHETA(3,NSB)
         REAL*8 FMOMTOT(3,5,NSB),INVINERT(3,3,NSB),MTSB(NSB)
         REAL*8 UFLEX(NPLB,NSB,3,2),VFLEX(NPLB,NSB,3,2)
         REAL*8 PICIN(NSB,3),TCIN(NSB),EDEF(NSB),XCG(3,NSB)
         REAL*8 XTPHI(3,NPDEF,NA2,NSB),XCOOPHI(3,NPDEF,NSB) 
         REAL*8 XMNO(NA2,NSB),QVTH(3,NSB),QVR(3,NSB),QVF(NA2,NSB)
         REAL*8 MRTH(3,3,NSB),MTHTH(3,3,NSB)
         REAL*8 MFTH(NA2,3,NSB),MFR(NA2,3,NSB),MTOT(NTOT,NTOT,NSB)
         REAL*8 SKL(3,3,NA2,NA2,NSB),IKL(3,3,NA2,NSB)
         REAL*8 BL0(3,NSB),BLF(3,NA2,NSB)
         REAL*8 XMPOI(NPDEF,NSB)
         INTEGER IBASR(NSB2)
         CHARACTER*4 ITCOMP(NSB2)
         LOGICAL ITRIG(NSB,NA2)
      ENDSEGMENT
* Matt: ajout segments ICPRIG pour remplissage 
* IBASR(ICPRIG(KNOE)) = IB
* ICPRIG est rempli dans dyne25
*
      SEGMENT,ICPRIG(nbpts)
*
      segment mtbas
        integer itbmod,lsstru(np1),nsstru
      endsegment
*
      LOGICAL L0,L1,RIGIDE,LMODYN,lnor
      CHARACTER*4 NOMTRI(6),NOMAXI(6),NOMPLA(3),MOTCOMP
** Matthieu: ajout de MONMOT pour detection rota rigide
      CHARACTER*8 CMOT,TYPRET,MORIGI,CHARRE,MONMOT,CMOT1
      REAL*8      XAXROT(3),XROTA(2,3),XXGP(3),XGRAV(3)
      REAL*8      JINERT(3,3),INERT2(3,3)
      real*8      ikl0(3,3),jtest(3,3),mff(20,20)
*      real*8      lmode(na2)

*
*     si IFOMOD = -1  :  modele PLAN
*     si IFOMOD =  0  :  modele AXIS
*     si IFOMOD =  1  :  modele FOUR
*     si IFOMOD =  2  :  modele TRID
*
*     Les noms de composante sont
*       - en modele PLAN   :  UX, UY, RT
*       - en modele AXIS   :  UX, UY, RZ
*       - en modele FOUR 1 :  UR, UZ, UT, RT
*       - en modele TRID   :  UX, UY, UZ, RX, RY, RZ
*
      DATA NOMTRI/'UX  ','UY  ','UZ  ','RX  ','RY  ','RZ  '/
      DATA NOMAXI/'UR  ','UT  ','UZ  ','RR  ','RT  ','RZ  '/
      DATA NOMPLA/'UX  ','UY  ','RZ  '/
*
      MTKAM  = KTKAM
      MTPHI  = KTPHI
      MTLIAB = KTLIAB
      RIGIDE = (KTROT.NE.0)
      IF (RIGIDE) THEN
        MTROT = KTROT
        npdef = xtphi(/2)
*       Masse totale du solide
        XMTOT = 0.D0
*       ICPRIG: pour remplissage IBASR (utile dans dyne18)      
        ICPRIG = KCPRIG
        segact,icprig
*       Inititalisation moment d'inertie:
        NSB = OMEG1(/3)
        DO I=1,3
          DO J=1,3
           INERTIE(I,J,IB) = 0.D0
           INVINERT(I,J,IB) = 0.D0
          ENDDO
        ENDDO
        MTSB(IB)=0.D0
* OLD:       Une valeur d'inertie_i < 0 signifiera qu il ne faut pas 
*       prendre en compte l axe i dans le calcul dans D2VPAS.
*       Rappel:
*        - 3D: 3 composantes a fournir en gibiane
*        - 2D: 1 composantes a fournir en gibiane
      ENDIF
*
      NLIAB  = IPALB(/1)
      NPLB   = JPLIB(/1)
      NSB    = XPHILB(/1)
      NPLSB  = XPHILB(/2)
      NA2    = XPHILB(/3)
*     juste pour test
      na1 = xm(/1)
      nb1m = xm(/2)
*
      IDIMB  = XPHILB(/4)
      DEUXPI = 2.D0 * XPI
      lnor = .true.
*
      IORSB(IB) = IA1 + 1
      IAROTA(IB) = 0
* ainsi IAROTA ne retient que l'indice de la derniere rota rigide 
*      contenue dans une sous base.
      IROT = 0
      IN = 0
      INEL = 0

      WRITE(*,*)'DYNE26: IDIM = ',IDIM
      WRITE(*,*)'DYNE26: IB = ',IB
*
************************************************************************
*      Aiguillage pour le cas
************************************************************************

      if (lmodyn) goto 40


************************************************************************
*     table BASE_MODALE
************************************************************************
* On est dans une boucle sur les modes de la sous base IB.

 10   CONTINUE
      IN = IN + 1
      TYPRET = ' '
      CALL ACCTAB(IBAS,'ENTIER',IN,X0,' ',L0,IP0,
     &                  TYPRET,I1,X1,CHARRE,L1,IBAMOD)
      IF (IERR.NE.0) RETURN
      IF (IIMPI.EQ.333) WRITE(IOIMP,*)'mode',IN,'IBAMOD=',IBAMOD
*    -on a bien un objet de type table
      IF (IBAMOD.NE.0) THEN
       IF (TYPRET.EQ.'TABLE   ') THEN
         MORIGI = ' '
         CALL ACCTAB(IBAMOD,'MOT',I0,X0,'ROTATION_RIGIDE',L0,IP0,
     &                      MORIGI,I1,X1,CMOT,L1,IP1)
         IF (IERR.NE.0) RETURN 
    
******** Mode Rotation Rigide **********
*         WRITE(*,*)'DYNE26: avant traitement rotas rigide'
         IF (MORIGI.EQ.'MOT') THEN
            IF ((CMOT(1:4).EQ.'VRAI').AND.(RIGIDE))  THEN
*             WRITE(*,*)'DYNE26: debut traitement rotas rigides'
              IROT = IROT+1
*             WRITE(*,*)'DYNE26: IROT = ',IROT
* Remplissage IBASR:
              CALL ACCTAB(IBAMOD,'MOT',I0,X0,'POINT_REPERE',L0,IP0,
     &                    'POINT',I1,X1,' ',L1,KNOE)
              IF (IERR.NE.0) RETURN
              KNOE2 = ICPRIG(KNOE)
              IBASR(KNOE2) = IB
              WRITE(*,*)'     ptrep rota rigide = ',KNOE
* Si il n y a pas 3 rotations (par ex en 2D):
              CALL ACCTAB(IBAMOD,'MOT',I0,X0,'COMPOSANTE',L0,IP0,
     &                    'MOT',I1,X1,MOTCOMP,L1,IP1)
              IF (IERR.NE.0) RETURN
              ITCOMP(KNOE2) = MOTCOMP
              WRITE(*,*)'     composante = ',MOTCOMP
* On remplit quand meme IAROTA(IB) qui nous sert a la detection 
* d'une rota rigide dans les subroutines: DEVRCO et D2VRIG.
              IAROTA(IB)=IROT
*             WRITE(*,*)'DYNE26 : IAROTA(',IB,') = ',IROT
*
*       Acquisition des 3 moments d'inertie diagonaux:
                CALL ACCTAB(IBAMOD,'MOT',I0,X0,'MASSE_GENERALISEE',L0,
     &          IP0,'FLOTTANT',I1,XMASSE,' ',L1,IP1)
                IF (IERR.NE.0) RETURN
              WRITE(*,*)'     moment inertie = ',XMASSE
* Matt TODO: mettre une erreur:
                IF (XMASSE.LT.XZPREC) THEN
       WRITE(*,*)
     &     'DYNE26: ERREUR: le moment d inertie doit etre non nul!!'
                   RETURN
                ENDIF
                IF (MOTCOMP.EQ.'RX') THEN
                  INERTIE(1,1,IB) = XMASSE
                  INVINERT(1,1,IB) = 1.D0/XMASSE
*            WRITE(*,*)'DYNE26: J_X ss base (',IB,') given by user = ',
*     &                               INVINERT(1,1,IB)                  
                ELSEIF(MOTCOMP.EQ.'RY') THEN
                  INERTIE(2,2,IB) = XMASSE
                  INVINERT(2,2,IB) = 1.D0/XMASSE
*            WRITE(*,*)'DYNE26: J_Y ss base (',IB,') given by user = ',
*     &                               INVINERT(2,2,IB)                  
                ELSEIF(MOTCOMP.EQ.'RZ') THEN 
                  INERTIE(3,3,IB) = XMASSE
                  INVINERT(3,3,IB) = 1.D0/XMASSE
*            WRITE(*,*)'DYNE26: J_Z ss base (',IB,') given by user = ',
*     &                               INVINERT(3,3,IB)
             WRITE(*,*)'DYNE26 : tenseur J'
             write(*,'(20F15.5)')((INERTIE(k,j),j= 1,3),k= 1,3)
                ENDIF
*       Acquisition masse totale du solide:
*        (eventuellement necessaire si matrice inert. pleine)
                IF (XMTOT.EQ.0.D0) THEN
                  CALL ACCTAB(IBAMOD,'MOT',I0,X0,'MASSE',
     &                  L0,IP0,'FLOTTANT',I1,XMTOT,' ',L1,IP1)
                  MTSB(IB)=XMTOT
                  WRITE(*,*)'DYNE26 : masse totale = ',XMTOT
                ENDIF
*       Acquisition du pointeur du centre de rotation IPCENT:                 
                CALL ACCTAB(IBAMOD,'MOT',I0,X0,'CENTRE_DE_ROTATION',
     &          L0,IP0,'POINT',I1,X1,'  ',L1,ICDR)
                IF (IERR.NE.0) RETURN
*               Au cas ou on est en 2D:
                XCENT(3,IB)=0.D0
                DO ID=1,IDIM
                  XCENT(ID,IB)=XCOOR((ICDR-1)*(IDIM+1)+ID)
*                  WRITE(*,*)'DYNE26:  XCENT(',ID,IB,')=',XCENT(ID,IB)
                ENDDO
                CALL ACCTAB(IBAMOD,'MOT',I0,X0,'CENTRE_DE_GRAVITE',
     &          L0,IP0,'POINT',I1,X1,'  ',L1,ICDG)
* Points de liaison en base B
               IF (NLIAB.NE.0) THEN
                CALL ACCTAB(IBAMOD,'MOT',I0,X0,'DEFORMEE_MODALE',
     &                      L0,IP0,'CHPOINT',I1,X1,CHARRE,L1,ICHDEF)
*                WRITE(*,*)'       NPLB =  ',NPLB

                WRITE(*,*)'DYNE26: boucle sur les pts liai MODE RIGIDE'
                DO 14 IP = 1,NPLB
                  IPOINT = JPLIB(IP)
                  WRITE(*,*)'DYNE26: JPLIB(',IP,') = ',JPLIB(IP)
*                 remplissage IBASB aussi pour les rotas rigides:
*                  WRITE(*,*)'DYNE26: appel extra10'
*                  WRITE(*,*)'        ICHDEF = ',ICHDEF
*                  WRITE(*,*)'        IPOINT = ',IPOINT
                  CALL EXTRA10(ICHDEF,IPOINT,IRET)
                  WRITE(*,*)'DYNE26: sortie EXTRA10:'
                  WRITE(*,*)'        IP = ',IP                  
                  WRITE(*,*)'        IPOINT = ',IPOINT
                  WRITE(*,*)'        IRET = ',IRET
*                  CALL EXTRA9(ICHDEF,IPOINT,CMOT,0,.FALSE.,XVAL,IRET)
                  IF ((IBASB(IP).NE.0).AND.(IRET.NE.0)) THEN
                    IF (IBASB(IP).NE.IB) THEN
                      call erreur (783)
                      RETURN
                    ENDIF
                    IBASB(IP) = IB
                    WRITE(*,*)'        IBASB(',IP,') = ',IBASB(IP)
                  ELSEIF ((IBASB(IP).NE.0).AND.(IRET.EQ.0)) THEN
*                    WRITE(*,*)
*     &      'pt ',IP,' appartient a une autre ss base: ',IBASB(IP)
                    GOTO 14
                  ELSEIF ((IBASB(IP).EQ.0).AND.(IRET.EQ.1)) THEN
                      IBASB(IP) = IB
                      WRITE(*,*)'        IBASB(',IP,') = ',IBASB(IP)
                  ELSEIF ((IB.EQ.NSB).AND.(IBASB(IP).EQ.0)) THEN
                    IF (IRET.EQ.0) THEN
                     WRITE(*,*)
     &  'DYNE26: IP n appartient a aucune sous-base!'
*                    CALL EXIT(1)
                     IBASB(IP) = IB
                    ENDIF
                    IBASB(IP) = IB
                    WRITE(*,*)'        IBASB(',IP,') = ',IBASB(IP)
                  ENDIF
*                 SSI IBASB(IP) = IP : Remplissage XCOOLB :
                  IF (IBASB(IP).EQ.IB) THEN
        WRITE(*,*)'DYNE26 : remplissage XCOOLB pour IPOINT = ',IPOINT
        WRITE(*,*)'     pour la ss base = IB = ',IB 
                  XCOOLB(3,IB,IP)=0.D0
                    DO ID = 1,IDIM
                      XCOOLB(ID,IB,IP)=XCOOR((IPOINT-1)*(IDIM+1)+ID)
                      WRITE(*,*)'DYNE26: XCOOLB(',ID,IB,IP,') = ',
     &                                  XCOOLB(ID,IB,IP)
                    ENDDO
                  ENDIF
 14             CONTINUE
               ENDIF
              GOTO 10
*  fin MORIGI = VRAI et RIGIDE
            ELSEIF ((CMOT(1:4).EQ.'VRAI').AND.(KTROT.EQ.0)) THEN
              WRITE(*,*)'DYNE26: erreur rotas rigides, KTROT = 0'
              CALL ERREUR(272)
              RETURN
            ENDIF
*
* fin rigide = MOT
         ENDIF
* lecture des donnes lues (gibiane: opti impi 33;):
                 

******** Mode Elastique **********
         INEL = INEL +  1
         IA1 = IA1 + 1
* Si il y a des rotas rigide en general (ie. RIGIDE=.TRUE.), on fait un
* scann sur les translations rigides qui recevront un traitement spécial (devrco, devpro) :
* en gibiane: Tmode . modes . I . 'TRANSLATION_RIGIDE' = 'VRAI' ;
* ( inutile de le signaler en l'absence de rotations rigides )
         IF (RIGIDE) THEN
           ITRIG(IB,INEL) = .FALSE.
           TYPRET = ' '
           CALL ACCTAB(IBAMOD,'MOT',I0,X0,'TRANSLATION_RIGIDE',L0,IP0,
     &                    TYPRET,I1,X1,CMOT1,L1,IP1)
           IF (IERR.NE.0) RETURN
           IF (TYPRET.EQ.'MOT') THEN
            IF ((CMOT1(1:4).EQ.'VRAI').AND.(RIGIDE)) THEN
              ITRIG(IB,INEL) = .TRUE.
*              WRITE(*,*)'DYNE26: ITRIG(',IN,') = ',ITRIG(IN)
            ENDIF
           ENDIF
         ENDIF
*
*        remplissage de XM et XK diagonale depuis la table BASE_MODALE
*        sauf si deja fait car on a une table RAIDEUR_ET_MASSE !
         IF(ITKM.LE.0) THEN
           CALL ACCTAB(IBAMOD,'MOT',I0,X0,'MASSE_GENERALISEE',L0,IP0,
     &                  'FLOTTANT',I1,XMASSE,' ',L1,IP1)
           IF (IERR.NE.0) RETURN
           XM(IA1,1) = XMASSE
           write(*,*)'dyne26 : mode ia1 = ',ia1
*          write(*,*)'         xm * mtot = ',xmasse * xmtot
           CALL ACCTAB(IBAMOD,'MOT',I0,X0,'FREQUENCE',L0,IP0,
     &                  'FLOTTANT',I1,XFREQ,' ',L1,IP1)
           IF (IERR.NE.0) RETURN
           OMEGA = XFREQ * DEUXPI
           XK(IA1,1) = XMASSE * OMEGA * OMEGA
           WRITE(*,*)'DYNE26 :   XK(',IA1,') =',XK(IA1,1)
           IF (IIMPI.EQ.333) THEN
              WRITE(IOIMP,*)'DYNE26 :   XM(',IA1,') =',XMASSE
              WRITE(IOIMP,*)'DYNE26 :   XK(',IA1,') =',XK(IA1,1)
           ENDIF
         ENDIF

*        si liaison_B existe, remplissage de IPLSB, XPHILB, IAROTA, INMSB...
         IF (IIMPI.EQ.333) WRITE(IOIMP,*) 
     &     'DYNE26: presence de liasons en base B = ',(NLIAB.NE.0)
         IF (NLIAB.NE.0) THEN
            CALL ACCTAB(IBAMOD,'MOT',I0,X0,'DEFORMEE_MODALE',L0,IP0,
     &                         'CHPOINT',I1,X1,' ',L1,ICDM)
            IF (IERR.NE.0) RETURN
            CALL ACTOBJ('CHPOINT ',ICDM,1)
            DO 12 ID = 1,IDIMB
               IF (IFOUR.EQ.0 .OR. IFOUR.EQ.1) THEN
                  CMOT = NOMAXI(ID)
               ELSE
                  IF (IFOMOD.EQ.-1) THEN
                      CMOT = NOMPLA(ID)
                  ELSE
                      CMOT = NOMTRI(ID)
                  ENDIF
               ENDIF
               IF (IIMPI.EQ.333)
     &         WRITE(IOIMP,*)'DYNE26 :  composante a extraire :',CMOT

               WRITE(*,*)'DYNE26: boucle sur les pts liai MODE FLEXIBLE'
               ICOMP  = 0
               DO 140 IP = 1,NPLB
                  IPOINT = JPLIB(IP)
*                  WRITE(*,*)'DYNE26: JPLIB(',IP,') = ',JPLIB(IP)
*      On extrait du chpoint ICDM au point IPOINT de composante CMOT
                  CALL EXTRA9(ICDM,IPOINT,CMOT,0,.FALSE.,XVAL,IRET)
                  ICOMP = ICOMP + 1
*          on ajuste la taille si necessaire
                  IF(ICOMP.GT.NPLSB) THEN
                      NPLSB=ICOMP
                      SEGADJ MTPHI
                  ENDIF
                  IPLSB(IP) = ICOMP
*                  WRITE(*,*)'DYNE26: IPOINT = ',IPOINT
*                  WRITE(*,*)'        IP = ',IP
*                  WRITE(*,*)'        IPLSB(',IP,') = ',IPLSB(IP)
                  IF (IIMPI.EQ.333) THEN
                    WRITE(IOIMP,*)'DYNE26 :   IPLSB(',IP,') =',
     &                                        IPLSB(IP)
                  ENDIF
* suite a la modif dans extra9, car on attribue une valeur meme
* si le point n'existe pas dans le chpoint
* old:                  IF (.NOT.RIGIDE) THEN
*                   Si RIGIDE, IBASB a deja ete rempli.
*                    WRITE(*,*)' modes elas, remplissage IBASB'
                    IF (XVAL.NE.0.) THEN
                      IF ((IBASB(IP).NE.0).AND.(IBASB(IP).NE.IB)) THEN
                       call erreur(783)
                       RETURN
                      ENDIF
                      IBASB(IP) = IB
                      WRITE(*,*)'        IBASB(',IP,') = ',IBASB(IP)
                    ELSEIF ((IB.EQ.NSB).AND.(IBASB(IP).EQ.0)) THEN
                      IBASB(IP) = IB
cms :   TODO retirer (on ne veut pas alterer le fonctionnement des modes flexibles):  pour verif :
                      WRITE(*,*)'DYNE26 : le pt liai IP = ',IP
                      WRITE(*,*)'         de pointeur IPOINT =  ',IPOINT
            WRITE(*,*)'   n appartient possiblement a aucune ss base,'
                      WRITE(*,*)'   OU est un noeud de vibration '
                      WRITE(*,*)'   pour le mode INEL = ',INEL
*                     CALL EXIT(1)
                    ENDIF
*                    IF (IIMPI.EQ.333) THEN
*                     WRITE(*,*)'DYNE26 :   IBASB(',IP,') =',
*     &                                        IBASB(IP)
*                    ENDIF
* old:                  ENDIF
* MAtt :on remplace IN par INEL: XPHILB rempli que par les modes
*                       elastiques
                  XPHILB(IB,ICOMP,INEL,ID) = XVAL
*
*      IF (IIMPI.EQ.333) THEN
        XVA2 = XPHILB(IB,ICOMP,INEL,ID)
*        WRITE(*,*)'DYNE26 :   IPLSB(',IP,') = ',IPLSB(IP)
*        WRITE(*,*)'DYNE26 :   defo modale = ICDM = ',ICDM
*        WRITE(*,*)'DYNE26 :   XPHILB(',IB,ICOMP,INEL,ID,') =',XVA2
*      ENDIF
 140           CONTINUE
 12         CONTINUE
* fin condition IF NLIA.NE.0
         ENDIF
* on boucle sur les modes
         GOTO 10        
       ELSE
*      si l'objet retourné n'est pas une table: erreur
         CALL ERREUR(491)
         RETURN
       ENDIF
* fin if IBAMOD NE.0
      ENDIF
*    -fin du cas ou on a bien un objet de type table
* OLD: INMSB(IB) = IN - 1
*     INMSB = Nombre de modes elatiques dans la sous base IB.
      INMSB(IB) = INEL
*       WRITE(*,*)'        NA2 par devalo: ',NA2
*       WRITE(*,*)'        ss-base IB, NA3 = ',INMSB(IB)
*       WRITE(*,*)'        old NA3 = ',(IN-1)
****** Calcul de la matrice d inertie en presence de rotations rigides:
*
      IF (RIGIDE) THEN
* 1) On desactive ICPRIG:
        SEGDES,ICPRIG
* 2) On verifie que tous les moments d'inertie diagonaux sont renseignes
        TESTIN=MIN(INERTIE(1,1,IB),INERTIE(2,2,IB),INERTIE(3,3,IB))
        WRITE(*,*)'DYNE26 : moment inertie min = ',TESTIN
        IF (TESTIN.LT.XPETIT) THEN
          IF ((IDIM.EQ.3).AND.(IROT.NE.0)) THEN
*           TODO: ERREUR a faire
            WRITE(*,*)
     &      'DYNE26: Moment d inertie trop faible ou non renseigne!!!'
            RETURN
          ELSEIF ( (IDIM.EQ.2).AND.(TESTIN.EQ.INERTIE(3,3,IB)).AND.
     &             (IROT.NE.0) ) THEN
*           TODO: ERREUR a faire
            WRITE(*,*)
     &    'DYNE26: Moment d inertie en Z doit être non nul en dime 2!'
            RETURN
          ENDIF
        ENDIF
* 3) Si (ICDR.NE.ICDG) on MAJ la matrice d inertie:
        IF (ICDR.NE.ICDG) THEN
          XGRAV(1)=0.D0
          XGRAV(2)=0.D0
          XGRAV(3)=0.D0
          DO ID=1,IDIM
            XGRAV(ID)=XCOOR((ICDG-1)*(IDIM+1)+ID)
*            WRITE(*,*)'DYNE26:  XGRAV(',ID,')=',XGRAV(ID)
            XCG(ID,IB) = (XGRAV(ID) - XCENT(ID,IB))
          ENDDO
*         Calcul de la norme de Xcdr - Xcdg:
          XCG2 = SQRT(XCG(1,ib)**2 + XCG(2,ib)**2 + XCG(3,ib)**2)
          write(*,*)'dyne26 : xcg2 = ',xcg2
          IF (XCG2.GT.XPETIT) THEN
            IF (IERR.NE.0) RETURN
            WRITE(*,*)'Appel MAJINERT '
            CALL MAJINERT(XCG(1,IB),MTSB(ib),INERTIE(1,1,IB))
*           Inversion avec la methode des cofacteurs:
            IF (IDIM.EQ.3) THEN
              CALL HINV33(INERTIE(1,1,IB),INVINERT(1,1,NSB))
            ELSEIF (IDIM.EQ.2) THEN
              CALL HINV22(INERTIE(1,1,IB),INVINERT(1,1,NSB))
            ENDIF
            write(*,*)'post-majinert : inertie :'
            do id=1,3
               write(*,'(3(1X,F8.5))') , (inertie(id,j,ib),j=1,3)
            enddo
            write(*,*)'                invinert :'
            do id=1,3
               write(*,'(3(1X,F15.10))') , (invinert(id,j,ib),j=1,3)
            enddo
          ENDIF
*       Fin correction moment d'inertie.
        ENDIF
* 4)  Si rk4 : on initialise mthth = inertie 
        do id=1,3
          do j=1,3
            mthth(id,j,ib) = inertie(id,j,ib)
          enddo
        enddo
*     Fin 
      ENDIF

************************************************************************
*        rigide : on implente les matrices 
*                 utiles au calculs des forces d'inertie
************************************************************************
      write(*,*)'dyne26 : rigide',rigide
      write(*,*)'         iarota(ib)',iarota(ib)
      if ((rigide).and.(iarota(ib).ne.0)) then
      
*       rq : ibas est deja la base de modes
       write(*,*)'         npdef = ',npdef
       write(*,*)'         na2 = ',na2
       write(*,*)'         nsb = ',nsb
       write(*,*)'         na1 = ',na1
       write(*,*)'         nb1m = ',nb1m
*
        call filldef(ibas,ib,ktphi,ktrot,ktkam,npdef,lnor)
        xsum = 0.d0
        do ip=1,npdef
          xsum = xsum + xmpoi(ip,ib)
        enddo
        write(*,*)' dyne26 : somme xmpoi :',xsum
        write(*,*)'          mtsb :',mtsb(ib)
        write(*,*)'          pourcentage : ',(xsum*100./mtsb(ib))
*       on convertit tout ce qu'on peut avec le scaling factor des modes : 
*       ds filldef le scaling factor est alpha = (xmno/xm)^(1/2)
*       MAJ masse modale : le ratio mu_new/mu_old = alpha**2
*       MAJ raideur modale : le ratio gamma_new/gamma_old = alpha**2
*       MAJ xphilb : le ratio xphilb_new/xphilb_old = alpha
        na3 = inmsb(ib)
        ina1 = iorsb(ib) - 1
        write(*,*)'na3 = ',na3
        write(*,*)'ina1 = ',ina1
        if (lnor) then
        do in=1,na3
          i2 = ina1 + in
          if (.not.itrig(ib,in)) then
            xalpha = dsqrt(xmno(in,ib)/xm(i2,1))
            write(*,*)'xalpha**2 = ',xalpha**2
            xm(i2,1) = xmno(in,ib)
            write(*,*)'dyne26 : xk avant : ',xk(i2,1)
            xk(i2,1) = (xalpha**2)*xk(i2,1)
            write(*,*)'         xk apres : ',xk(i2,1)
            write(*,*)' omega = sqrt(xk/xm) = ',dsqrt(xk(i2,1)/xm(i2,1))
            do ip=1,nplsb
             do id=1,idimb
               xphilb(ib,ip,in,id) = xphilb(ib,ip,in,id)*xalpha
             enddo
            enddo
          endif
        enddo
        endif

******* Construction des time-invariant matrices :
*     SKL(3,3,na2,na2,nsb) : Phi_k^T * Phi_l , where Phi_k is the k^th row of the mode shape matrix
*     k,l=1,..,3 --> coordinates
*     i,j=1,..,na3 --> modes
*           --> matrix of size (na2 x na2) for each pair (k,l)
*     xmno : is the modal mass, since we normalized the modes to unity, 
*     xmno = Mtot / npdef 
*       i.e. the total mass of the solide divided by the number of nodes 
*       i.e. the mass contribution of a node 
      do k=1,3
        do l=1,3
          do i=1,na3
            do j=1,na3
              do ip=1,npdef
                skl(k,l,i,j,ib) = skl(k,l,i,j,ib) +
     &          (xmpoi(ip,ib) * (xtphi(k,ip,i,ib)*xtphi(l,ip,j,ib)))
              enddo
            enddo
          enddo
        enddo
      enddo
      write(*,*)'        skl : '
      do k=1,3
        write(*,*)'        K ',k
        do l=1,3
          write(*,*)'        L ',l
          do in=1,na3
             write(*,'(4(1X,F8.5))') , (skl(k,l,in,j,ib),j=1,na3)
          enddo
        enddo
      enddo
*     ikl(3,3,na2,nsb) : X0_k wedge Phi_l (l^th line of the modal shape matrix)
      do k=1,3
        do l=1,3
          do i=1,na3
            do ip=1,npdef
              ikl(k,l,i,ib) = ikl(k,l,i,ib) + 
     & (xmpoi(ip,ib)*(xcoophi(k,ip,ib)-xcent(k,ib))*(xtphi(l,ip,i,ib)))
            enddo
          enddo
        enddo
      enddo
      write(*,*)'        ikl : '
      do k=1,3
        write(*,*)'        K ',k
        do l=1,3
          write(*,*)'        L ',l
          do in=1,na3
             write(*,'(1X,F8.5)') , (ikl(k,l,in,ib))
          enddo
        enddo
      enddo
*     calcul du bras de levier :
*       statique :
      do ip=1,npdef
        bl0(1,ib) = bl0(1,ib) +
     &   xmpoi(ip,ib)*(xcoophi(1,ip,ib)-xcent(1,ib))
        bl0(2,ib) = bl0(2,ib) +
     &   xmpoi(ip,ib)*(xcoophi(2,ip,ib)-xcent(2,ib))
        bl0(3,ib) = bl0(3,ib) +
     &   xmpoi(ip,ib)*(xcoophi(3,ip,ib)-xcent(3,ib))
      enddo
      write(*,*)'        bl0 : '
      write(*,'(1X,F15.10)') , (bl0(id,ib),id=1,3)

*       dynamique :
      do in=1,na3
        do ip=1,npdef
          blf(1,in,ib)= blf(1,in,ib) + xmpoi(ip,ib)*(xtphi(1,ip,in,ib))
          blf(2,in,ib)= blf(2,in,ib) + xmpoi(ip,ib)*(xtphi(2,ip,in,ib))
          blf(3,in,ib)= blf(3,in,ib) + xmpoi(ip,ib)*(xtphi(3,ip,in,ib))
        enddo
      enddo
      write(*,*)'        blf : '
      do in=1,na3
        write(*,'(1X,F15.10)') , (blf(id,in,ib),id=1,3)
      enddo
*     TEST : ikl0 : X0_k wedge X0_l (l^th line of the modal shape matrix)
      do k=1,3
        do l=1,3
          ikl0(k,l) = 0.d0
          do ip=1,npdef
              ikl0(k,l) = ikl0(k,l) + xmpoi(ip,ib) *
     &  ((xcoophi(k,ip,ib)-xcent(k,ib))*(xcoophi(l,ip,ib)-xcent(l,ib)))
          enddo
        enddo
      enddo
*   jtest : termes diagonaux :
      jtest(1,1) = ikl0(2,2) + ikl0(3,3)
      jtest(2,2) = ikl0(1,1) + ikl0(3,3)
      jtest(3,3) = ikl0(1,1) + ikl0(2,2)
*   termes non diagonaux :
      do k=1,3
        do l=1,3
          if (k.ne.l) then
            jtest(k,l) = - ikl0(l,k)
          endif
        enddo
      enddo
*     on remplace inertie par jtest
*      do id=1,3
*        do j=1,3
*          if (jtest(id,j).gt.1.d-10) then
*            inertie(id,j,ib) = jtest(id,j)
*          endif
*        enddo
*      enddo
      write(*,*)'ikl0 :'
      do id=1,3
         write(*,'(3(1X,F15.10))') , (ikl0(id,j),j=1,3)
      enddo
      write(*,*)'jtest :'
      do id=1,3
         write(*,'(3(1X,F15.10))') , (jtest(id,j),j=1,3)
      enddo
      write(*,*)'inertie issu de majinert :'
      do id=1,3
         write(*,'(3(1X,F15.10))') , (inertie(id,j,ib),j=1,3)
      enddo
      write(*,*)'ecart jtest / inertie :'
      write(*,'(3(1X,F15.10))') ,
     &  (100.d0*(1.d0 - jtest(id,id)/inertie(id,id,ib)),id=1,3)
*     on remplace inertie par jtest
*      do id=1,3
*        if (jtest(id,id).gt.1.d-10) then
*          inertie(id,id,ib) = jtest(id,id)
*        endif
*      enddo
*
      write(*,*)'inertie definitive :'
      do id=1,3
      write(*,'(20F15.10)'),inertie(id,id,ib)
      enddo
*     mff 
*      do in1=1,na2
*        do in2=1,na2
*          mff(in1,in2) = 0.d0 
*        enddo
*      enddo
*      do in1=1,na3
*        if (.not.itrig(ib,in1)) then
*          do in2=1,na3
*            if (.not.itrig(ib,in2)) then
*              do id=1,3
*              do ip=1,npdef
*                mff(in1,in2) = mff(in1,in2) +
*     &          xmpoi(ip,ib)*xtphi(id,ip,in1,ib)*xtphi(id,ip,in2,ib)
*              enddo
*              enddo
*            endif
*          enddo
*        endif
*      enddo
*      WRITE(*,*)'masse modale : '
*      do in=1,na3
*      i2 = ina1 + in
*      if (.not.itrig(ib,in)) then
*        write(*,'(20F12.8)'),(xm(i2,1))
*      endif
*      enddo
*      WRITE(*,*)'mff : '
*      do in=1,na3
*        write(*,'(20F15.10)'),(mff(in,in2),in2= 1,na3)
*      enddo
*     on corrige les masses et raideurs generalisees pour que ca colle avec les valeurs integrees
*      do in=1,na3
*        i2 = ina1 + in
*        if (.not.itrig(ib,in)) then
*          xalpha = (mff(in,in)/xm(i2,1))
*          xm(i2,1) = xalpha*xm(i2,1)
*          xk(i2,1) = xalpha*xk(i2,1)
*        endif
*      enddo
*
*        write(*,*)'dyne26 : xcoophi'
*        do ip = 1,npdef
*         write(*,'(3(1X,F8.5))') , (xcoophi(id,ip,ib),id=1,3)
*        enddo
*        write(*,*)'dyne26 : xtphi'
*        do ip = 1,npdef
*         do in=1,na2
*         write(*,'(3(1X,F8.5))') , (xtphi(id,ip,in,ib),id=1,3)
*         enddo
*        enddo

*     fin if rigide and iarota(ib).ne.0 :
      endif
************************************************************************
************************************************************************
*     table PASAPAS
************************************************************************

 40   if (lmodyn) then
*
       mtbas = ibas
       mmodel = itbmod
       segact mmodel
       mchelm = itcara
       segact mchelm
       n1 = imache(/1)
       IN = 0

       do 41 ik =1,kmodel(/1)
        imodel = kmodel(ik)
        if (lsstru(ik).ne.ib) goto 41
         IN =  IN + 1
        segact imodel
        jdefo = 0
        jmass = 0
        jfreq = 0
        jgrav = 0
        do 46 inc = 1,n1
          meleme = imache(inc)
          if (meleme.ne.imamod) goto 46
          if (conche(inc).ne.conmod) goto 46
          segact meleme
          mchaml = ichaml(inc)
          segact mchaml
          n2 = ielval(/1)

          do io = 1,n2
            if (nomche(io)(1:4).eq.'DEFO') then
              jdefo = io
              melval = ielval(io)
              segact melval
            else if  (nomche(io)(1:4).eq.'MASS') then
              jmass =io
              melval = ielval(io)
              segact melval
            else if (nomche(io)(1:4).eq.'FREQ') then
              jfreq = io
              melval = ielval(io)
              segact melval
            else if (nomche(io)(1:4).eq.'CGRA') then
              jgrav = io
              melval = ielval(io)
              segact melval
            else
            endif
           if (jdefo.gt.0.and.jmass.gt.0.and.jfreq.gt.0.and.
     &jgrav.gt.0) goto 47
          enddo
           if (jdefo.gt.0.and.jmass.gt.0.and.jfreq.gt.0) goto 47
 46     continue
        if (jdefo.eq.0.and.jmass.eq.0.and.jfreq.eq.0) then
         write(6,*) 'pas de caracteristiques modele ',ik, conmod
         return
        endif
 47     continue
        do ip =1,num(/2)
         IA1 = IA1 + 1
           melval = ielval(jmass)
           xmasse = velche(1,ip)
         XM(IA1,1) = XMASSE

           melval = ielval(jfreq)
           xfreq = velche(1,ip)
         OMEGA = XFREQ * DEUXPI
         XK(IA1,1) = XMASSE * OMEGA * OMEGA

           melval = ielval(jdefo)
           icdm = ielche(1,ip)

**
*   Prise en compte d'un mode de rotation de corps rigide
           if (jgrav.gt.0) then

** Matthieu: pas de prise en compte de rotations rigides dans table PASAPAS:
              WRITE(*,*)'DYNE26: Rotation rigide incompatible avec
     &                       PAP. Utiliser differences_centrees.'
              CALL ERREUR(272)
              RETURN
*             melval = ielval(jgrav)
*             ICDG = ielche(1,ip)
*                IAROTA(IB)=IA1
*                IROT = IN
           endif
        enddo
*
*
         IF (IIMPI.EQ.333) THEN
            WRITE(IOIMP,*)'DYNE26 :   XM(',IA1,') =',XMASSE
            WRITE(IOIMP,*)'DYNE26 :   XK(',IA1,') =',XK(IA1,1)
         ENDIF
         IF (NLIAB.NE.0) THEN
         
            CALL ACTOBJ('CHPOINT ',ICDM,1)
         
            DO 42 ID = 1,IDIMB
               IF (IFOUR.EQ.0 .OR. IFOUR.EQ.1) THEN
                  CMOT = NOMAXI(ID)
               ELSE
                  IF (IFOMOD.EQ.-1) THEN
                      CMOT = NOMPLA(ID)
                  ELSE
                      CMOT = NOMTRI(ID)
                  ENDIF
               ENDIF
               IF (IIMPI.EQ.333) THEN
                  WRITE(IOIMP,*)'DYNE26 :  composante a extraire :',CMOT
               ENDIF
               ICOMP  = 0
               DO 44 IP = 1,NPLB
                  IPOINT = JPLIB(IP)
*
*     On extrait du chpoint ICDM au point IPOINT de composante CMOT
*
                  CALL EXTRA9(ICDM,IPOINT,CMOT,0,.FALSE.,XVAL,IRET)
                     ICOMP = ICOMP + 1
*
*          on ajuste la taille si necessaire
*                      MP
                         IF(ICOMP.GT.NPLSB) THEN
                             NPLSB=ICOMP
                             SEGADJ MTPHI
                         ENDIF
                     IPLSB(IP) = ICOMP
* suite e la modif dans extra9, car on attribue une valeur meme
* si le point n'existe pas dans le chpoint
*
*                  WRITE(*,*)' PAP, remplissage IBASB'
* OLD : on ne touche pas a PAP!   IF (.NOT.RIGIDE) THEN
*                   Si RIGIDE, IBASB a deja ete rempli.
                    IF (XVAL.NE.0.) THEN
                      IF ((IBASB(IP).NE.0).AND.(IBASB(IP).NE.IB)) THEN
                       call erreur(783)
                       RETURN
                      ENDIF
                      IBASB(IP) = IB
                    ELSEIF ((IB.EQ.NSB).AND.(IBASB(IP).EQ.0)) THEN
                      IBASB(IP) = IB
                    ENDIF
*                  ENDIF
*
                  XPHILB(IB,ICOMP,IN,ID) = XVAL
      IF (IIMPI.EQ.333) THEN
        WRITE(IOIMP,*)'DYNE26 :   IPLSB(',IP,') =',IPLSB(IP)
        WRITE(IOIMP,*)'DYNE26 :   IBASB(',IP,') =',IBASB(IP)
        XVA2 = XPHILB(IB,ICOMP,IN,ID)
        WRITE(IOIMP,*)'DYNE26 :   XPHILB(',IB,ICOMP,IN,ID,') =',XVA2
      ENDIF

 44               CONTINUE
 42            CONTINUE
          ENDIF
*

 41    continue
       INMSB(IB) = IN
       IN = IN + 1

       endif
****** fin du cas table PASAPAS ****************************************

      IF (RIGIDE) THEN
        IF (IIMPI.EQ.333) THEN
        WRITE(IOIMP,*)'DYNE26: '
        DO IIB=1,NSB
        DO I=1,3
          DO J=1,3
            WRITE(IOIMP,*)'  INERTIE(',I,J,IIB,') = ',INERTIE(I,J,IIB)
          ENDDO
        ENDDO
        DO I=1,3
          DO J=1,3
            WRITE(IOIMP,*)'  INVINERT(',I,J,IIB,') = ',INVINERT(I,J,IIB)
          ENDDO
        ENDDO  
        ENDDO
        ENDIF
      ENDIF
      IF (IIMPI.EQ.333) THEN
        WRITE(IOIMP,*)'DYNE26: FIN:'
        WRITE(IOIMP,*)'DYNE26: IDIMB = ',IDIMB
        WRITE(IOIMP,*)'   INMSB(',IB,') =',INMSB(IB)
        WRITE(IOIMP,*)'   IORSB(',IB,') =',IORSB(IB)
        WRITE(IOIMP,*)'   IAROTA(',IB,') =',IAROTA(IB)
        WRITE(IOIMP,*)'   XPHILB(/1) = ',XPHILB(/1)
        WRITE(IOIMP,*)'   XPHILB(/2) = ',XPHILB(/2)
        WRITE(IOIMP,*)'   XPHILB(/3) = ',XPHILB(/3)
        WRITE(IOIMP,*)'   XPHILB(/4) = ',XPHILB(/4)
      ENDIF
*
      END



 
 
