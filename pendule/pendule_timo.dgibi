*** Cas-test issu de Simo & Wong:
* UNCONDITIONALLY STABLE ALGORITHMS FOR RIGID
* BODY DYNAMICS THAT EXACTLY PRESERVE ENERGY
* AND MOMENTUM
rk4 = vrai ;
sw = faux ;
xpinv = vrai ;
linert = faux ;
nmb = faux ; 

*********************************************************************
*                       Valeurs numeriques 
*********************************************************************
* opti impi 555 ;
***** General :
* nbr de modes elastiques : 
* qui marche :
* nmode_ela = 2 ;
* nnoeuds = 5 ;

*# nmode :
nmode_ela = 10 ;

*# ltronq :
ltronq = vrai ; 
* meme si on mets les modes 3d : on enleve que les 2 modes rigides en x et en y :

*# ntronq : 
ntronq = 2 ;

*# nnoeuds :
nnoeuds = 200 ;

* Gravite:
 g = 9.81 ;

* Coefficient de Poisson:
 nuac = 0.3 ;
* Masse volumique: en kg/m^3
****** Geometrie:
stoia = vrai ;
manchette = faux ;
* stoianovici & hurmuzlu : plus longue barre : 
si (stoia) ;
* Module d'Young :
 eac = 210.e9 ; 
* masse volumique :
 rho_ac = 7876.74 ;
*# Rayon:
R = ((12.7e-3)/2.) ;
*# longueur de la poutre: 
h = 0.6 ;
* Section de la poutre :
sectpou = (Pi*(R**2)) ;
* Volume:
V = (Pi*(R**2.)*h) ;
* masse totale du solide utilisee dans tmode , rotas rigides :
M = V * rho_ac ;
* Moment d'inertie / centre de gravite:
Jx_G = (1./12.)*M*((h**2) + (3.*(R**2))) ;
Jy_G = (1./12.)*M*((h**2) + (3.*(R**2))) ;
Jz_G = 0.5*M*(R**2) ; 
* Moments quadratiques de la poutre:
IGx = (Pi*((2.*R)**4))/64. ;
IGy = (Pi*((2.*R)**4))/64. ;
IG = (Pi*((2.*R)**4))/32. ;
finsi ;
*
si (manchette) ;
*# longueur de la poutre: 
L_tot = 1563.4*1.e-3 ;
L_tete = 28.5*1.e-3 ;
L_corps = L_tot - L_tete ; 
h = l_corps ;
* Module d'Young :
 eac = 200.e9 ; 
* masse volumique :
 rho_ac = 7900. ;
*
D_ext = 63.5*1.e-3 ;
R_ext = D_ext/2. ; 
D_int = 55.3*1.e-3 ;
R_int = D_int/2. ;
epai = R_ext - R_int ;
* par rapport au centre de gravite :
JX_G = 2.583844235854036 ;
JY_G = 2.583844235854036 ;
JZ_G = 0.010527338424895177 ;
* Section de la poutre :
sectpou = (Pi*(R_ext**2)) - (Pi*(R_ext**2)) ;
* Moments quadratiques de la poutre :
IGx = ( Pi*((D_ext**4) - (D_int**4) )/64. ) ;
IGy = IGx ;
IG = ( Pi*((D_ext**4) -  (D_int**4) )/32. ) ;
finsi ; 

si (stoia) ;
* nmode = 35 : 20 modes de flexions, 6 modes de traction.
ntrac1 = 8 ;
ntrac2 = 15 ;
ntrac3 = 21 ;
ntrac4 = 25 ;
ntrac5 = 31 ;
ntrac6 = 35 ;
ntrac7 = 0 ;
nban1 = 9 ;
nban2 = 13 ; 
nban3 = 0 ; 
nban4 = 0 ; 
nban5 = 17 ; 
nban6 = 20 ; 
nban7 = 23 ; 
nban8 = 28 ; 
nban9 = 29 ; 
nban10 = 33 ; 
nban11 = 0 ; 
fin ; 
si (manchette) ;
* nmode = 35 : 15 modes de flexions, 7 modes de traction
ntrac1 = 6 ;
ntrac2 = 11 ;
ntrac3 = 17 ;
ntrac4 = 20 ;
ntrac5 = 25 ;
ntrac6 = 29 ;
ntrac7 = 33 ;
nban1 = 7 ;
nban2 = 10 ;
nban3 = 13 ;
nban4 = 16 ;
nban5 = 19 ;
nban6 = 22 ;
nban7 = 24 ;
nban8 = 27 ;
nban9 = 30 ;
nban10 = 32 ;
nban11 = 35 ;
finsi ;

* Position du centre de gravite : manchette ou stoianovici : 
 LG = (h/2.) ;
*
* Centre de rotation = P1 ci-dessous = origine (0. 0. 0.).
*
***** Temporel:
* T = 5.e-4 ;
T = 4. ;
DTE = 1.e-6 ;
NSORT =  2000 ;
* NSORT =  1 ;
*
NPASe = (ENTI 'PROCH' (T / DTe)) - 1 ;
tprog = prog 0. 'PAS' Dte 'NPAS' (NPASe + 1 ) ;
***** Base modale:
* rigide = vrai si presence de rotas rigides dans la base modale:
rigide = vrai ;
* Rotas rigides et modes elastiques:
  typmode = 1 ; 
* Que rotas rigides:
* typmode = 2;
* Que modes elastiques:
* typmode = 3;
si (typmode ega 3);
  rigide = faux ;
finsi;

*
***** Conditions initiales:
* nutation initiale de la toupie (Castem: angles en degres!):
theta_ini = 45. ;
* Vitesses angulaires de rotation inititales ds le repere du solide:
WXini = 0. ;
WYini = 0. ;
WZini = 0. ;
*
*********************************************************************
*                            OPTIONS 
*********************************************************************
***** Figure:
opti 'TRAC' PSC ; 
script = 'pendule_timo';
si (rk4) ;
script = (chai script'_rk4_') ;
algo = 'rk4' ;
finsi ;
si (nmb) ;
script = (chai script'_nmb_') ;
algo = 'nmb' ;
finsi ;
si (sw) ;
script = (chai script'_sw_') ;
algo = 'sw' ;
finsi ;
si xpinv ;
script = (chai script'xpinv') ;
algo = (chai algo'_xpinv') ;
finsi ;
si linert ;
script = (chai script'_inert') ;
algo = (chai algo'_inert') ;
finsi ;
opti 'FTRA ' (chai 'fig/'script'_T_'T'_h_'Dte'_NSORT_'NSORT'.ps' );
opti 'EPTR' 5;
***** OPIONS SORTIE EXCEL: 
OPTI 'SORT' (CHAI 'data/'script'_AC2_data_dgibi_T_' T '_h_' DTe'_NSORT_'NSORT) ;
* opti trac 'X';
***** dime et typel:
Opti dime 3; 
opti elem CUB8; 
* Pour afficher les "IF (IIMPI.EQ.333) THEN WRITE(IOIMP,*)":
* opti impi 333;
oeil1 = (5.*R) (5.*R) (0.5*h) ;
***** RECO totale voulue ?
RECOTOT = FAUX ;
EVOLRECO = VRAI ;
FLVTK = VRAI ;
* SI (RECOTOT EGA FAUX);
*   FLVTK = FAUX ;
* FINSI ;
*********************************************************************
*                            Maillage 
*********************************************************************
P1 = 0. 0. 0. ;
P2 = 0. 0. h ; 
* Centre de masse theorique:
G1 = 0. 0. LG ; 
***** Maillage: nombre d'element de la poutre:
 L1 = d nnoeuds P1 P2 ;
 MESHPOU = L1 ;
*  OPTI 'TRAC' X ; 
 TRAC 'QUAL' meshpou ;
 OPTI 'TRAC' 'PSC' ;
 G1 = MESHPOU POIN 'PROC' G1 ;
* Utilisation de BARY: si le maillage est fidèle! (Pas le cas ici): 
* Cgrav = BARY MESHPOU ;
* G1 = MESHPOU POIN 'PROC' Cgrav ;
* Point d'observation le plus eloigne X,Y,Z >0: utile pour comp avec python
Pobs = G1 ;
list Pobs ;
*
*********************************************************************
*                            MODELE 
*********************************************************************
modpou = mode meshpou 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
* Remarque: l'axe x est l'axe de la poutre contrairement au maillage.
matpou = MATE modpou 'YOUN' eac 'NU' nuac 'RHO' rho_ac  'SECT' sectpou 'INRZ' IGy 'INRY' IGx 'TORS' IG ;
*
* matrice de raideur :
K = rigi modpou matpou ;
* matrice de masse:
M1 = mass modpou matpou ;
****************************************************************************
*                       Conditions limites 
****************************************************************************
CL1 = BLOQ 'DEPL' P1;
K = K et cl1 ; 
*********************************************************************
*                            CLs 
*********************************************************************
* On prend un point qui n appartient pas au plan (Oyz):
CLRX = BLOQ 'RY' 'RZ' meshpou;
CLRY = BLOQ 'RX' 'RZ' meshpou;
CLRZ = BLOQ 'RX' 'RY' meshpou;
* CLela = BLOQ 'RZ' meshpou ;
* CLela = BLOQ 'ROTA' p1 ;
CLelaX = BLOQ 'UX' meshpou ;
CLelaY = BLOQ 'UY' meshpou ;
KRX = K et CLRX ;
KRY = K et CLRY ;
KRZ = K et CLRZ ;
KelaX = K et clelaX ;
KelaY = K et clelaY ;
* Kela = K ;
*********************************************************************
*                          Calculs des modes: 
*********************************************************************
* defini plus haut: Nmode = 5 ;
Tmode_RX  = vibr 'IRAM' 0.5 1 KRX M1 ; 
Tmode_RY  = vibr 'IRAM' 0.5 1 KRY M1 ;
Tmode_RZ  = vibr 'IRAM' 0.5 1 KRZ M1 ;
* On teste egalement en presence de modes elastiques:
Tmode_elaX = vibr 'IRAM' 20. nmode_ela KelaX M1 ;
Tmode_elaY = vibr 'IRAM' 20. nmode_ela KelaY M1 ;
* 
tmodela = tmode_elaX ;
*
si (ltronq) ;
* mail1 = extr (TMODE_ELAX . modes . 1 . deformee_modale) 'MAIL' 'NOMU';
tmodela = table 'BASE_MODALE' ;
tmodela . 'MODES' = table 'BASE_DE_MODES' ;
tmodela . 'MODES' . 'MAILLAGE' = meshpou ;
numode = 1 ;
repe bmode (nmode_ela - ntronq) ;
* si (non ((&bmode ega 6) ou (&bmode ega 7))) ;
si (non (&bmode ega 7)) ;
* X : 
  tmodela . modes . numode                                = table 'MODE' ;
  tmodela . modes . numode . 'NUMERO_MODE'                = numode ;
  tmodela . modes . numode . 'POINT_REPERE'               = tmode_elaX . modes . (&bmode + ntronq) . point_repere ;
  tmodela . modes . numode . 'FREQUENCE'                  = tmode_elaX . modes . (&bmode + ntronq) . frequence ;
  tmodela . modes . numode . 'MASSE_GENERALISEE'          = tmode_elaX . modes . (&bmode + ntronq) . masse_generalisee ;
  tmodela . modes . numode . 'DEPLACEMENTS_GENERALISES'   = tmode_elaX . modes . (&bmode + ntronq) . deplacements_generalises ;
  tmodela . modes . numode . 'DEFORMEE_MODALE'            = tmode_elaX . modes . (&bmode + ntronq) . deformee_modale ;
* transformation de la deformee modale en x a une deformee modale en y  :
* defx = tmode_elaX . modes . (&bmode + ntronq) . deformee_modale ;
* duy = extr defx 'VALE' 'UY' ;
* l0 = (prog (nbno mail1)*0.) ;
* defx = manu chpo mail1 3 'UX' l0 'UY' duy 'UZ' l0 nature diffus; 
* defy = manu chpo mail1 3 'UX' duy 'UY' l0 'UZ' l0 nature diffus; 
* tmodela . modes . numode . 'DEFORMEE_MODALE'            = defx ;
si (non (&bmode ega 6)) ;
* Y : 
  tmodela . modes . (numode + 1)                                = table 'MODE' ;
  tmodela . modes . (numode + 1) . 'NUMERO_MODE'                = (numode + 1) ;
  tmodela . modes . (numode + 1) . 'POINT_REPERE'               = tmode_elaY . modes . (&bmode + ntronq) . point_repere ;
* tmodela . modes . (numode + 1) . 'FREQUENCE'                  = tmode_elaX . modes . (&bmode + ntronq) . frequence ;
* tmodela . modes . (numode + 1) . 'MASSE_GENERALISEE'          = tmode_elaX . modes . (&bmode + ntronq) . masse_generalisee ;
  tmodela . modes . (numode + 1) . 'FREQUENCE'                  = tmode_elaY . modes . (&bmode + ntronq) . frequence ;
  tmodela . modes . (numode + 1) . 'MASSE_GENERALISEE'          = tmode_elaY . modes . (&bmode + ntronq) . masse_generalisee ;
  tmodela . modes . (numode + 1) . 'DEPLACEMENTS_GENERALISES'   = tmode_elaY . modes . (&bmode + ntronq) . deplacements_generalises ;
  tmodela . modes . (numode + 1) . 'DEFORMEE_MODALE'            = tmode_elaY . modes . (&bmode + ntronq) . deformee_modale ;
* incrementation de numode : 
  numode = numode + 1 ;
* fin si non bmode = 6
finsi ; 
  numode = numode + 1 ;
* fin si non bmode = 7
finsi ;

fin bmode ;

finsi ;

* postvibr Tmode_elaX ;
* postvibr Tmode_elaY ;

postvibr Tmodela ;
* calcul des xmno : 
* nmno = (enti (2. * (nmode_ela - ntronq))) ;
* repe bmno nmno ;

* fin bmno ;
* opti donn 5 ; 

*
ptrep_RX =    Tmode_RX . 'MODES' . 1 . 'POINT_REPERE';
ptrep_RY =    Tmode_RY . 'MODES' . 1 . 'POINT_REPERE';
ptrep_RZ =    Tmode_RZ . 'MODES' . 1 . 'POINT_REPERE';
ptrep_ela_1 =    Tmodela . 'MODES' . 1 . 'POINT_REPERE';
ptrep_ela_2 =    Tmodela . 'MODES' . 2 . 'POINT_REPERE';
* ptrep_ela_3 =    Tmodela . 'MODES' . 3 . 'POINT_REPERE';
* ptrep_ela_4 =    Tmodela . 'MODES' . 4 . 'POINT_REPERE';
*
*********************************************************************
*                     Traitement rotations rigides: 
*********************************************************************
* Si l'on veut avoir les bons moments d'inertie (theoriques), 
* on les rentre manuellement en tant que masses generalisees:
     Tmode_RX . modes . 1 . masse_generalisee = Jx_G;
     Tmode_RY . modes . 1 . masse_generalisee = Jy_G;
     Tmode_RZ . modes . 1 . masse_generalisee = Jz_G;
* Pour les rotas rigides:
Tmode_RX . modes . 1 . frequence = 0. ;
Tmode_RY . modes . 1 . frequence = 0. ;
Tmode_RZ . modes . 1 . frequence = 0. ;
*
* Rq tenseur d'inertie : 
* Dans Simo & wong le tenseur d'inertie est déjà défini en la pointe de la toupie P1 !!
* On triche pour ne pas avoir de modif via MAJINERT: 
* CENTRE DE ROTATION = G1 ! 
Tmode_RX . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
Tmode_RX . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= G1 ;
Tmode_RX . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P1;
Tmode_RX . 'MODES' . 1 . 'MASSE'= M ;
Tmode_RX . 'MODES' . 1 . 'COMPOSANTE' = 'RX' ;
Tmode_RY . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
Tmode_RY . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= G1  ;
Tmode_RY . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P1 ;
Tmode_RY . 'MODES' . 1 . 'MASSE'= M ;
Tmode_RY . 'MODES' . 1 . 'COMPOSANTE' = 'RY' ;
Tmode_RZ . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
Tmode_RZ . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= G1  ;
Tmode_RZ . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P1 ;
Tmode_RZ . 'MODES' . 1 . 'MASSE'= M ;
Tmode_RZ . 'MODES' . 1 . 'COMPOSANTE' = 'RZ' ;
*
*********************************************************************
*                     Assemblage des bases modales: 
*********************************************************************
*
* Rotas rigides et modes elastiques:
SI (typmode EGA 1);
* Tmode = (Tmode_RX et Tmode_RY et Tmode_RZ et Tmode_ela) ;
Tmode = (Tmode_RX et Tmode_RY et Tmode_RZ et Tmodela) ;
FINSI;
* Que rotas rigides:
SI (typmode EGA 2);
Tmode = (Tmode_RX et Tmode_RY et Tmode_RZ ) ;
FINSI;
* Que modes elastiques:
SI (typmode EGA 3);
Tmode = (Tmode_ela) ;
FINSI;
*
* opti donn 5 ;
************************************************************************
*     					Parametrage DYNE
************************************************************************
*** TSORT:
TSORT = TABL 'SORTIE';
TSORT . 'VARIABLE'  = tabl 'VARIABLE' ;
TSORT . 'VARIABLE' . 'TYPE_SORTIE'  = mot 'LISTREEL';
*
TSORT . 'VARIABLE' . 'ACCELERATION' = VRAI;

TSORT . 'VARIABLE' . 'VITESSE' = VRAI;
* MOMENT_CINETIQUE : 
TSORT . 'VARIABLE' . 'TRAVAIL_INTERIEUR' = VRAI ;
* ENERGIE_CINETIQUE :
TSORT . 'VARIABLE' . 'TRAVAIL_EXTERIEUR' = VRAI ;
*** TINI:
* Deplacements:
 U0_RX = MANU 'CHPO' ptrep_RX 'NATUR' 'DIFFUS' 'ALFA' (theta_ini*pi/180.) ;
 U0_RY = MANU 'CHPO' ptrep_RY 'NATUR' 'DIFFUS' 'ALFA' 0. ;
 U0_RZ = MANU 'CHPO' ptrep_RZ 'NATUR' 'DIFFUS' 'ALFA' 0. ;
 U0_ela_1 = MANU 'CHPO' ptrep_ela_1 'NATUR' 'DIFFUS' 'ALFA' 0. ;
* U0_ela_2 = MANU 'CHPO' ptrep_ela_2 'NATUR' 'DIFFUS' 'ALFA' 0.;
* assemblage en 1 chpoint:
*  U0_P = (U0_RX et U0_RY et U0_RZ et U0_ela_1 et U0_ela_2);
 U0_P = (U0_RX et U0_RY et U0_RZ) ;
* U0_P = (U0_ela_1 et U0_ela_2) ;
* Vitesses:
si (typmode ega 3);
  WXini = 0. ;
  WYini = 0. ; 
  WZini = 0. ;
finsi;
 V0_PX = MANU 'CHPO' ptrep_RX 'NATUR' 'DIFFUS' 'ALFA' WXini ;
 V0_PY = MANU 'CHPO' ptrep_RY 'NATUR' 'DIFFUS' 'ALFA' WYini ;
 V0_PZ = MANU 'CHPO' ptrep_RZ 'NATUR' 'DIFFUS' 'ALFA' WZini ;
 V0_P = (V0_PX et V0_PY et V0_PZ);
* Table:
  TINI = tabl 'INITIAL';
  TINI . 'DEPLACEMENT' = U0_P;
  TINI . 'VITESSE'     = V0_P;
*
*** TCHAR:
TCHAR = TABL 'CHARGEMENT';
		FPES   = FORC 'FZ' ((-1.)*(m*g)) G1;
		FPESA = PJBA FPES Tmode;

		Fprog = prog (dime tprog)*1. ; 
		evolF = evol 'ROSE' 'MANU' 't' tprog 'F' Fprog;
   DESS evolF 'TITRE' 'chargmt = f(t)' LEGE;
		CHA_PES = CHAR 'FORC' FPES evolF ;
		CHA_PESA = CHAR 'FORC' FPESA evolF ;

* Chargement introduit en base A et en base B:
  TCHAR .'BASE_A' = TABL;
  TCHAR .'BASE_A' = CHA_PESA;
  TCHAR .'BASE_B' = TABL;  
  TCHAR .'BASE_B' = CHA_PES;

* TODO: Determiner si le chargement doit reeelement etre exprime 
*                  en base A ET en base B.
*
***** TLIAI:
* Liaison fictive en G1 pour RECO: pour avoir appel a D2VLFB / 2.
* (appelees uniquement si (NLIAB.NE.0).

	 TL1  =  TABLE  'LIAISON_ELEMENTAIRE'    ;
	 TL1.'TYPE_LIAISON'  =  MOT 'POINT_PLAN' ;
	 TL1.'SUPPORT'       =  G1              ;
	 TL1.'RAIDEUR'       =  1.              ;
	 TL1.'NORMALE' = (poin 1. 0. 0.) ;
*    On prend volontairement un jeu demesure (liaison fictive):
	 TL1.'JEU'           =  10.              ;
*

   Normale_PPLAN = 0. 0. -1. ; 
*  Stoianovici : 
   Jeu1 = 2.*h*(sin theta_ini) ;
*  Jeu1 = 2.h*(sin theta_ini) ;
*  Jeu1 = 1.e-3 ;
*  Stoianovici : 
*  Kchoc = 5.5E+07 ;
   muk = 0.075 ;
   Kchoc = 5.5E+07 ;
   Bamo = 2.0E+04 ;
   K_T= 0.01*Kchoc ;
*  static friction coeff : 
   mu = 0.1 ;
   adh = mu ;
*  Cchoc = 0.1*((M*Kchoc)**0.5) ;
	 TL2  =  TABLE  'LIAISON_ELEMENTAIRE'    ;
	 TL2 . 'TYPE_LIAISON'  =  MOT 'POINT_PLAN_FROTTEMENT' ;
	 TL2 . 'SUPPORT'       =  p2 ;
	 TL2 . 'RAIDEUR'       =  Kchoc ;
   TL2 . 'COEFFICIENT_GLISSEMENT' = muk ; 
   TL2 . 'COEFFICIENT_ADHERENCE' = (0.1*muk) ; 
* 0 si friction uniquement
   TL2 . 'RAIDEUR_TANGENTIELLE' = (0.*Kchoc) ; 
   TL2 . 'AMORTISSEMENT_TANGENTIEL' = 0. ; 
	 TL2 . 'AMORTISSEMENT' =  Bamo ;
	 TL2 . 'NORMALE'       =  NORMALE_PPLAN ;
	 TL2 . 'JEU'           =  jeu1 ;

   TLIAI = TABLE 'LIAISON'   ;
   TTLB = TABLE 'LIAISON_B' ;
   TLIAI .'LIAISON_B' = TTLB  ;
   TTLB . 1 = TL1 ;
   TTLB . 2 = TL2 ;

* sortie liaison point-plan :
TSORL = TABLE 'LIAISON_B' ;
TSORT . 'LIAISON_B' = TSORL ;
TSTL2 = table ;
TSTL2 . 'VITESSE_NORMALE' = VRAI ;
TSTL2 . 'FORCE_DE_CHOC_NORMALE' = VRAI ;
TSTL2 . 'FORCE_DE_CHOC_TANGENTIELLE' = VRAI ;
TSTL2 . 'PUISSANCE_USURE_INSTANTANEE' = VRAI ;
TSORL . TL2 = TSTL2 ; 

************************************************************************
*     					Resolution DYNE
************************************************************************
*
'TEMP' 'ZERO' ;
si (sw) ;
  TRESU = DYNE 'DIFFERENCES_CENTREES' Tmode TLIAI TCHAR TINI TSORT NPASe DTe NSORT;
finsi ;
si (nmb) ;
  TRESU = DYNE 'NMB' Tmode TLIAI TCHAR TINI TSORT NPASe DTe NSORT;
finsi ;
si (rk4) ;
  TRESU = DYNE 'RKMK4' Tmode TLIAI TCHAR TINI TSORT NPASe DTe NSORT;
finsi ;
ctime = ('TEMP' 'ENTI' 'HORL') ;

* TRESU = DYNE 'DIFFERENCES_CENTREES' Tmode TLIAI TINI TSORT NPASe DTe NSORT;
*
tprog = TRESU . TEMPS_DE_SORTIE;
*
Nt = dime tprog;
*
opti donn 5 ; 
************************************************************************
*     					POST TRAITEMENT
************************************************************************
*
************************************************************************
*     			Vitesses et accelerations angulaires
************************************************************************
SI (rigide EGA VRAI) ;
***** Recuperation des nouveaus ptreps associes aux rotas rigides:
ptrep_rig1 = Tmode . rotas . 1 . point_repere;
ptrep_rig2 = Tmode . rotas . 2 . point_repere;
ptrep_rig3 = Tmode . rotas . 3 . point_repere;
ptrep_rig4 = Tmode . rotas . 4 . point_repere;
***** Recuperation des vitesses angulaires de rotation;
W1 = tresu . vitesse . ptrep_rig1;
W2 = tresu . vitesse . ptrep_rig2;
W3 = tresu . vitesse . ptrep_rig3;
*
* W1_ev = EVOL 'ROSE' MANU 't' tprog 'W1' W1;
* W2_ev = EVOL 'VIOL' MANU 't' tprog 'W2' W2;
* W3_ev = EVOL 'BLEU' MANU 't' tprog 'W3' W3;
* *
* TAB1 . 'TITRE' . 1 = 'W1';
* Dess (W1_ev) 'TITRE' 'W1 = f(t)' TAB1 'LEGE';
* TAB1 . 'TITRE' . 1 = 'W2';
* Dess (W2_ev) 'TITRE' 'W2 = f(t)' TAB1 'LEGE';
* TAB1 . 'TITRE' . 1 = 'W3';
* Dess (W3_ev) 'TITRE' 'W3 = f(t)' TAB1 'LEGE';
*
A1 = tresu . acceleration . ptrep_rig1;
A2 = tresu . acceleration . ptrep_rig2;
A3 = tresu . acceleration . ptrep_rig3;
*
* A1_ev = EVOL 'ROSE' MANU 't' tprog 'A1' A1;
* A2_ev = EVOL 'VIOL' MANU 't' tprog 'A2' A2;
* A3_ev = EVOL 'BLEU' MANU 't' tprog 'A3' A3;
*
*** Moment cinétique :
PI1 = tresu . TRAVAIL_INTERIEUR . ptrep_rig1;
PI2 = tresu . TRAVAIL_INTERIEUR . ptrep_rig2;
PI3 = tresu . TRAVAIL_INTERIEUR . ptrep_rig3;
*
* PI1_ev = EVOL 'ROSE' MANU 't' tprog 'PI1' PI1;
* PI2_ev = EVOL 'VIOL' MANU 't' tprog 'PI2' PI2;
* PI3_ev = EVOL 'BLEU' MANU 't' tprog 'PI3' PI3;
* TAB1 . 'TITRE' . 1 = 'PI1';
* Dess (PI1_ev) 'TITRE' 'PI1 = f(t)' TAB1 LEGE;
* TAB1 . 'TITRE' . 1 = 'PI2';
* Dess (PI2_ev) 'TITRE' 'PI2 = f(t)' TAB1 LEGE;
* TAB1 . 'TITRE' . 1 = 'PI3';
* Dess (PI3_ev) 'TITRE' 'PI3 = f(t)' TAB1 LEGE;
* TAB1 . 'TITRE' . 1 = 'PI1';
* TAB1 . 'TITRE' . 2 = 'PI2';
* TAB1 . 'TITRE' . 3 = 'PI3';
* Dess (PI3_ev et PI2_ev et PI3_ev) 'TITRE' 'PI = f(t)' TAB1 LEGE;
*
*** Energie cinetique :
EC1 = tresu . TRAVAIL_EXTERIEUR . ptrep_rig1 ;
* EC1_ev = EVOL 'ROSE' MANU 't' tprog 'EC1' EC1 ;
* TAB1 . 'TITRE' . 1 = 'EC';
* Dess (EC1_ev) 'TITRE' 'EC = f(t)' TAB1 LEGE;
*
*** Energie de deformation :
EP1 = tresu . TRAVAIL_EXTERIEUR . ptrep_rig2 ;
* EP1_ev = EVOL 'ROSE' MANU 't' tprog 'EC1' EP1 ;
* TAB1 . 'TITRE' . 1 = 'EDEF';
* Dess (EP1_ev) 'TITRE' 'EDEF = f(t)' TAB1 LEGE;

*** Energie totale = hamiltonien :
ET1 = EC1 + EP1 ;
* ET1_ev = EVOL 'ROSE' MANU 't' tprog 'EC1' ET1 ;
* TAB1 . 'TITRE' . 1 = 'Etot';
* Dess (ET1_ev) 'TITRE' 'ET = f(t)' TAB1 LEGE;
FINSI;
*
************************************************************************
*     					RECO en tous les points
************************************************************************
Si (RECOTOT EGA VRAI) ;
	 UX1 = prog; 
	 UY1 = prog;
	 UZ1 = prog;
	 VX1 = prog; 
	 VY1 = prog;
	 VZ1 = prog;
   AX1 = prog; 
	 AY1 = prog;
	 AZ1 = prog;
REPE BRECO Nt;
      D1 =  RECO  TRESU  Tmode (extr tprog &BRECO) 'DEPL' ;
*       V1 =  RECO  TRESU  Tmode (extr tprog &BRECO) 'VITE' ;
      UX2 = EXTR D1 'UX' Pobs;
      UY2 = EXTR D1 'UY' Pobs;
	    UZ2 = EXTR D1 'UZ' Pobs;		
      UX1 = UX1 et UX2;
      UY1 = UY1 et UY2;
      UZ1 = UZ1 et UZ2;		  
FIN BRECO;
UX_ev = EVOL 'JAUN' MANU 't' tprog 'UX' UX1;
UY_ev = EVOL 'ORAN' MANU 't' tprog 'UY' UY1;
UZ_ev = EVOL 'ROUG' MANU 't' tprog 'UZ' UZ1;
TAB1 = TABL; TAB1 . 'TITRE' = TABL;
	TAB1 . 'TITRE' . 1 = 'UX';
Dess(UX_ev) 'TITRE' 'Depl = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'UY';
Dess(UY_ev) 'TITRE' 'Depl = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'UZ';
Dess(UZ_ev) 'TITRE' 'Depl = f(t)' TAB1 LEGE;
	TAB1 . 'TITRE' . 1 = 'UX';
	TAB1 . 'TITRE' . 2 = 'UY';	
	TAB1 . 'TITRE' . 3 = 'UZ';
Dess(UX_ev et UY_ev et UZ_ev) 'TITRE' 'recotot: Depl = f(t)' TAB1 LEGE;
* Vitesse:
REPE BRECOVITE Nt;
      VITE1 =  RECO  TRESU  Tmode (extr tprog &BRECOVITE) 'VITE' ;
      VX2 = EXTR VITE1 'UX' Pobs;
      VY2 = EXTR VITE1 'UY' Pobs;
	  VZ2 = EXTR VITE1 'UZ' Pobs;	
      VX1 = VX1 et VX2;
      VY1 = VY1 et VY2;
      VZ1 = VZ1 et VZ2;		  
FIN BRECOVITE;
*
 VX_ev = EVOL 'JAUN' MANU 't' tprog 'VX' VX1;
 VY_ev = EVOL 'ORAN' MANU 't' tprog 'VY' VY1;
 VZ_ev = EVOL 'ROUG' MANU 't' tprog 'VZ' VZ1;
 	TAB1 . 'TITRE' . 1 = 'VX';
Dess(VX_ev) 'TITRE' 'recotot: VX = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'VY';
Dess(VY_ev) 'TITRE' 'recotot: VY = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'VZ';
Dess(VZ_ev) 'TITRE' 'recotot: VZ = f(t)' TAB1 LEGE;
*
    TAB1 . 'TITRE' . 1 = 'VX';
	TAB1 . 'TITRE' . 2 = 'VY';	
	TAB1 . 'TITRE' . 3 = 'VZ';
Dess(VX_ev et VY_ev et VZ_ev) 'TITRE' 'Vitesse = f(t)' TAB1 LEGE;

* Acceleration:
REPE BRECOACC Nt;
      ACCE1 =  RECO  TRESU  Tmode (extr tprog &BRECOACC) 'ACCE' ;
      AX2 = EXTR ACCE1 'UX' Pobs;
      AY2 = EXTR ACCE1 'UY' Pobs;
	    AZ2 = EXTR ACCE1 'UZ' Pobs;	
      AX1 = AX1 et AX2;
      AY1 = AY1 et AY2;
      AZ1 = AZ1 et AZ2;		  
FIN BRECOACC;
*
 AX_ev = EVOL 'JAUN' MANU 't' tprog 'AX' AX1;
 AY_ev = EVOL 'ORAN' MANU 't' tprog 'AY' AY1;
 AZ_ev = EVOL 'ROUG' MANU 't' tprog 'AZ' AZ1;
 	TAB1 . 'TITRE' . 1 = 'AX';
Dess(AX_ev) 'TITRE' 'recotot: AX = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'AY';
Dess(AY_ev) 'TITRE' 'recotot: AY = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'AZ';
Dess(AZ_ev) 'TITRE' 'recotot: AZ = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'AX';
	TAB1 . 'TITRE' . 2 = 'AY';	
	TAB1 . 'TITRE' . 3 = 'AZ';
Dess(AX_ev et AY_ev et AZ_ev) 'TITRE' 'recotot: Acceleration = f(t)' TAB1 LEGE;
* formatT = chai '(D1.' (ABS NdecT) ')';
* list formatT;
* List T;
* Tmot = (chai 'FORMAT' (mot (F1.2)) T );
* list Tmot;
* DTe = (chai 'FORMAT' '(F1.2)' DTe);
* FIN RECOTOT:
FINSI;
******************** VTK *****************************************
  SI (FLVTK);
*   REPE BVTK (enti ((Nt)/10tprog (&BVTK)) 'DEPL';
*    D1 =  RECO  TRESU  Tmode (extr ..));
   REPE BVTK (Nt - 2);
*   REPE BVTK (Nt - 2);
    D1 =  RECO  TRESU  Tmode (extr tprog (&BVTK)) 'DEPL';
    DEP2 = D1 exco (mots 'UX' 'UY' 'UZ') ;
*    DEP3 = CHAN 'CHAM' DEP2 mod1 'GRAVITE' ;
*    DEP4 = CHAN 'CHAM' DEP2 VOL1 ;
     T_I = (extr tprog &BVTK) ;
*    mess T_I ;
*    VOL2 = EXTR DEP2 'MAIL';
*    VOL3 = CHAN 'POI1' VOL1 ;
**** DEformees:
*     def1 = DEFO VOL1 DEP2 1. 'ROUG' ;
*     def0 = DEFO VOL1 DEP2 0. 'VERT' ;
*     def2 = def1 et def0 ;
*     TRAC def2 VOL1 ;
****
    OPTI 'SORT'  (chai 'depl_vtk/'script);
    SORT 'VTK' meshpou 'MAIL' DEP2 'DEPL' 'TEMP' T_I;
    FIN BVTK;
* FIN FLVTK:
  FINSI;
*********************************************************************
*                     EVOL RECO au centre de gravite
*********************************************************************
*
SI (EVOLRECO EGA VRAI) ;
UXG_ev = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' G1 'UX' ;
UYG_ev = EVOL 'ORAN' 'RECO' TRESU TMODE 'DEPL' G1 'UY' ;
UZG_ev = EVOL 'ROUG' 'RECO' TRESU TMODE 'DEPL' G1 'UZ' ;
VXG_ev = EVOL 'JAUN' 'RECO' TRESU TMODE 'VITE' G1 'UX' ;
VYG_ev = EVOL 'ORAN' 'RECO' TRESU TMODE 'VITE' G1 'UY' ;
VZG_ev = EVOL 'ROUG' 'RECO' TRESU TMODE 'VITE' G1 'UZ' ;
AXG_ev = EVOL 'JAUN' 'RECO' TRESU TMODE 'ACCE' G1 'UX' ;
AYG_ev = EVOL 'ORAN' 'RECO' TRESU TMODE 'ACCE' G1 'UY' ;
AZG_ev = EVOL 'ROUG' 'RECO' TRESU TMODE 'ACCE' G1 'UZ' ;
*
UXG2 = EXTR UXG_EV 'ORDO' 1 ;
UYG2 = EXTR UYG_EV 'ORDO' 1 ;
UZG2 = EXTR UZG_EV 'ORDO' 1 ;
VXG2 = EXTR VXG_EV 'ORDO' 1 ;
VYG2 = EXTR VYG_EV 'ORDO' 1 ;
VZG2 = EXTR VZG_EV 'ORDO' 1 ;
AXG2 = EXTR AXG_EV 'ORDO' 1 ;
AYG2 = EXTR AYG_EV 'ORDO' 1 ;
AZG2 = EXTR AZG_EV 'ORDO' 1 ;
*
    TAB1 = TABL ; TAB1 . 'TITRE' = TABL ;
	TAB1 . 'TITRE' . 1 = 'UX_G';	
	TAB1 . 'TITRE' . 2 = 'UY_G';
	TAB1 . 'TITRE' . 3 = 'UZ_G';
Dess (UXG_ev et UYG_ev et UZG_ev) 'TITRE' 'EVOL RECO DEPL' TAB1 LEGE ;
*
	TAB1 . 'TITRE' . 1 = 'VX_G';	
	TAB1 . 'TITRE' . 2 = 'VY_G';
	TAB1 . 'TITRE' . 3 = 'VZ_G';
Dess (VXG_ev et VYG_ev et VZG_ev) 'TITRE' 'EVOL RECO VITE' TAB1 LEGE ;
*
    TAB1 . 'TITRE' . 1 = 'AX_G';
Dess (AXG_ev) 'TITRE' 'EVOL RECO AX' TAB1 LEGE ;
*
    TAB1 . 'TITRE' . 1 = 'AY_G';
Dess (AYG_ev) 'TITRE' 'EVOL RECO AY' TAB1 LEGE ;    
*
    TAB1 . 'TITRE' . 1 = 'AZ_G';
Dess (AZG_ev) 'TITRE' 'EVOL RECO AZ' TAB1 LEGE ;
*
	TAB1 . 'TITRE' . 1 = 'AX_G';	
	TAB1 . 'TITRE' . 2 = 'AY_G';
	TAB1 . 'TITRE' . 3 = 'AZ_G';
Dess (AXG_ev et AYG_ev et AZG_ev) 'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
* fin si evolreco :
FINSI ;
*
si (typmode ega 1) ;
q1 = tresu . deplacement . ptrep_ela_1 ;
q2 = tresu . deplacement . ptrep_ela_2 ;
* q3 = tresu . deplacement . ptrep_ela_3 ;
* q4 = tresu . deplacement . ptrep_ela_4 ;
q1_ev = EVOL 'ROUG' MANU 't' tprog 'q1' q1 ;
q2_ev = EVOL 'ROUG' MANU 't' tprog 'q1' q2 ;
* q3_ev = EVOL 'ROUG' MANU 't' tprog 'q1' q3 ;
* q4_ev = EVOL 'ROUG' MANU 't' tprog 'q1' q4 ;
TAB1 . 'TITRE' . 1 = 'q1';	
Dess q1_ev  'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
TAB1 . 'TITRE' . 1 = 'q2';	
Dess q2_ev  'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
* TAB1 . 'TITRE' . 1 = 'q3';	
* Dess q3_ev  'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
* TAB1 . 'TITRE' . 1 = 'q4';	
* Dess q4_ev  'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
finsi ;

UXp1_ev = EVOL 'ROUG' 'RECO' TRESU tmode 'DEPL' p1 'UX' ;
UYp1_ev = EVOL 'VERT' 'RECO' TRESU tmode 'DEPL' p1 'UY' ;
UZp1_ev = EVOL 'BLEU' 'RECO' TRESU tmode 'DEPL' p1 'UZ' ;
UXp1 = EXTR uxp1_ev 'ORDO' 1 ;
UYp1 = EXTR uyp1_ev 'ORDO' 1 ;
UZp1 = EXTR uzp1_ev 'ORDO' 1 ;
dess (uxp1_ev et uYp1_ev et uzp1_ev) 'TITRE' 'P1' ;

UXp2_ev = EVOL 'ROUG' 'RECO' TRESU tmode 'DEPL' p2 'UX' ;
UYp2_ev = EVOL 'VERT' 'RECO' TRESU tmode 'DEPL' p2 'UY' ;
UZp2_ev = EVOL 'BLEU' 'RECO' TRESU tmode 'DEPL' p2 'UZ' ;
UXp2 = EXTR uxp2_ev 'ORDO' 1 ;
UYp2 = EXTR uyp2_ev 'ORDO' 1 ;
UZp2 = EXTR uzp2_ev 'ORDO' 1 ;
dess (uxp2_ev et uYp2_ev et uzp2_ev) 'TITRE' 'P2' ;
***************************************************************************
*                  SORTIE

*************************************************************************** sorties rotas rigides : 
TSORT = table ;
TSORT . 'algo' = table ;
TSORT . 't' = table ;
TSORT . 'ctime' = table ;
TSORT . 'wx' = table ;
TSORT . 'wy' = table ;
TSORT . 'wz' = table ;
TSORT . 'algo' = (mots algo) ;
TSORT . 't' = tprog ;
TSORT . 'ctime' = (prog ctime) ;
TSORT . 'wx' = w1 ;
TSORT . 'wy' = w2 ;
TSORT . 'wz' = w3 ;
TSORT . 'ax' = table ;
TSORT . 'ay' = table ;
TSORT . 'az' = table ;
TSORT . 'ax' = a1 ;
TSORT . 'ay' = a2 ;
TSORT . 'az' = a3 ;
TSORT . 'pix' = table ;
TSORT . 'piy' = table ;
TSORT . 'piz' = table ;
TSORT . 'pix' = pi1 ;
TSORT . 'piy' = pi2 ;
TSORT . 'piz' = pi3 ;
TSORT . 'ec' = table ;
TSORT . 'ec' = ec1 ;
TSORT . 'edef' = table ;
TSORT . 'edef' = ep1 ;
TSORT . 'et' = table ;
TSORT . 'et' = et1 ;
TSORT . 'uxp1' = table ;
TSORT . 'uyp1' = table ;
TSORT . 'uzp1' = table ;
TSORT . 'uxp1' = uxp1 ;
TSORT . 'uyp1' = uyp1 ;
TSORT . 'uzp1' = uzp1 ;
TSORT . 'uxp2' = table ;
TSORT . 'uyp2' = table ;
TSORT . 'uzp2' = table ;
TSORT . 'uxp2' = uxp2 ;
TSORT . 'uyp2' = uyp2 ;
TSORT . 'uzp2' = uzp2 ;
* Pusure durant les impacts : 
TSORT . 'pusure' = table ;
TSORT . 'fn' = table ;
TSORT . 'ft' = table ;
TSORT . 'vn' = table ;
TSORT . 'pusure' = TRESU . TL2 . 'PUISSANCE_USURE_INSTANTANEE' ;
TSORT . 'vn' = TRESU . TL2 . 'VITESSE_NORMALE' ;
TSORT . 'fn' = TRESU . TL2 . 'FORCE_DE_CHOC_NORMALE' ;
TSORT . 'ft' = TRESU . TL2 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
*
ncolexce = 25 ;

* RECOTOT : 
SI (RECOTOT EGA VRAI) ;
TSORT . 'ux1' = table ;
TSORT . 'uy1' = table ;
TSORT . 'uz1' = table ;
TSORT . 'ux1' = ux1 ;
TSORT . 'uy1' = uy1 ;
TSORT . 'uz1' = uz1 ;
TSORT . 'vx1' = table ;
TSORT . 'vy1' = table ;
TSORT . 'vz1' = table ;
TSORT . 'vx1' = vx1 ;
TSORT . 'vy1' = vy1 ;
TSORT . 'vz1' = vz1 ;
TSORT . 'ax1' = table ;
TSORT . 'ay1' = table ;
TSORT . 'az1' = table ;
TSORT . 'ax1' = ax1 ;
TSORT . 'ay1' = ay1 ;
TSORT . 'az1' = az1 ;
ncolexce = ncolexce + 9 ;
FINSI ; 
* EVOLRECO :
SI (EVOLRECO EGA VRAI) ;
TSORT . 'uxg' = table ;
TSORT . 'uyg' = table ;
TSORT . 'uzg' = table ;
TSORT . 'uxg' = uxg2 ;
TSORT . 'uyg' = uyg2 ;
TSORT . 'uzg' = uzg2 ;
TSORT . 'vxg' = table ;
TSORT . 'vyg' = table ;
TSORT . 'vzg' = table ;
TSORT . 'vxg' = vxg2 ;
TSORT . 'vyg' = vyg2 ;
TSORT . 'vzg' = vzg2 ;
TSORT . 'axg' = table ;
TSORT . 'ayg' = table ;
TSORT . 'azg' = table ;
TSORT . 'axg' = axg2 ;
TSORT . 'ayg' = ayg2 ;
TSORT . 'azg' = azg2 ;
ncolexce = ncolexce + 9 ;
FINSI ; 
si (typmode ega 1) ;
tsort . 'q1' = tresu . deplacement . ptrep_ela_1  ;
ncolexce = ncolexce + 1 ;
finsi ; 
* On rétalbit la sortie par défaut:
OPTI 'SORT' (CHAI 'data/'script'_AC2_data_dgibi_T_' T '_h_' DTe'_NSORT_'NSORT) ;

********************************************************************
SORT 'EXCE' (TSORT) 'NCOL' ncolexce 'SEPA' 'VIRG' 'DIGI' 10 ;

opti donn 5;
