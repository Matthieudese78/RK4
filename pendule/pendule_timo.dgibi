*** Stoianovici and Hurmuzlu :
***** dime et typel :
Opti dime 3 ; 
opti elem CUB8 ; 

opti 'TRAC' 'PSC' ;
opti 'EPTR' 5 ;

*# reprise :
reprise = faux ;

*# rk4 :
rk4 = vrai ;

*# sw :
sw = faux ;

*# nmb :
nmb = faux ; 

xpinv = faux ;

*# linert :
linert = vrai ;

* norme / norme eucl du mode :
*# lnortot :
lnortot = faux ;

* norme / comp max du mode :
*# lnorcomp :
lnorcomp = vrai ;

* norme / masse totale du solide :
*# lnormtot :
lnormtot = faux ;

inert = 0 ;
si linert ;
  inert = 1 ;
finsi ; 

*# limpact :
limpact = vrai ;

*# xi :
xi = 0. ;

*********************************************************************
*                       Valeurs numeriques 
*********************************************************************
***** General :

*# nmode_ela :
nmode_ela = 20 ;

*# typmode :
typmode = 1 ;

si (typmode ega 1) ;
  irigi = 0 ;
finsi ;
si (typmode ega 2) ;
  irigi = 1 ;
  nmode_ela = 0 ;
finsi ;
si (typmode ega 3);
  rigide = faux ;
  irigi = 0 ;
finsi;
*
nsauvmode = nmode_ela ; 

*# ltronq :
ltronq = vrai ; 

* meme si on mets les modes 3d : on enleve que les 2 modes rigides en x et en y :

*# ntronq : 
ntronq = 0 ;


* Gravite :
 g = 9.81 ;

* Coefficient de Poisson:
 nuac = 0.3 ;

* Masse volumique: en kg/m^3
****** Geometrie:

*# stoia :
stoia = vrai ;

*# trig :
trig = vrai ;

*# manchette :
manchette = faux ;

*# vimpact :
vimpact = 1. ;

*# theta_ini_x :
theta_ini_x = 45. ;

theta_ini_x = 90. - theta_ini_x ;
theta_ini_y = 0. ;
theta_ini_z = 0. ;

si (stoia) ;
* Module d'Young :
 eac = 210.e9 ; 
* masse volumique :
 rho_ac = 7876.74 ;
*# Rayon:
R = ((12.7e-3)/2.) ;

*# lbar : 
h = 0.6 ;

* Section de la poutre :
sectpou = (Pi*(R**2)) ;
* Volume:
V = (Pi*(R**2)*h) ;
* masse totale du solide utilisee dans tmode , rotas rigides :
M = V * rho_ac ;
* opti donn 5 ; 
* Moment d'inertie / centre de gravite:
Jx_G = (1./12.)*M*((h**2) + (3.*(R**2))) ;
Jy_G = (1./12.)*M*((h**2) + (3.*(R**2))) ;
Jz_G = 0.5*M*(R**2) ; 
* opti donn 5 ; 
* Moments quadratiques de la poutre:
IGx = (Pi*((2.*R)**4))/64. ;
IGy = (Pi*((2.*R)**4))/64. ;
IG = (Pi*((2.*R)**4))/32. ;
finsi ;
*
si (manchette) ;
*# longueur de la poutre: 
L_tot = 1563.4*1.e-3 ;
L_tete = 28.5*1.e-3 ;
L_corps = L_tot - L_tete ; 
h = l_corps ;
* Module d'Young :
 eac = 200.e9 ; 
* masse volumique :
 rho_ac = 7900. ;
*
D_ext = 63.5*1.e-3 ;
R_ext = D_ext/2. ; 
D_int = 55.3*1.e-3 ;
R_int = D_int/2. ;
epai = R_ext - R_int ;
* Section de la poutre :
sectpou = (Pi*(R_ext**2)) - (Pi*(R_int**2)) ;
v = sectpou*h ;
* massse manchette :
* M = 11.46 ;
M = rho_ac * v ;
* par rapport au centre de gravite :
* JX_G = 2.583844235854036 ;
* JY_G = 2.583844235854036 ;
* JZ_G = 0.010527338424895177 ;
jx_g = (1./12.)*M*((3.*((R_ext**2)+(R_int**2))) + (h**2)) ;
jy_g = jx_g ;
jz_g = 0.5*M*((R_int**2)+(R_ext**2)) ;
* Moments quadratiques de la poutre :
IGx = ( Pi*((D_ext**4) - (D_int**4) )/64. ) ;
IGy = IGx ;
IG = ( Pi*((D_ext**4) -  (D_int**4) )/32. ) ;
finsi ; 
*# parametres de contact :
Normale_PPLAN = 0. 0. -1. ; 
* Stoianovici : 
* Jeu1 = 2.*h*(sin theta_ini_x) ;
Jeu1 = h*(1. + (cos theta_ini_x)) ;
* Stoianovici : 
muk = 0.075 ;
Kchoc = 5.5E+07 ;

*# bamo :
Bamo = 2.0E+07 ;

* Bamo = 2.*M*((Kchoc/M)**0.5)*xi ;
* Bamo = 2.*JX_G*((Kchoc/JX_G)**0.5)*xi ;

* xi = bamo / (2.*JX_G*((Kchoc/JX_G)**0.5)) ;
xi = bamo / (2.*M*((Kchoc/M)**0.5)) ;

Bamo = 2.0E+02 ;

K_T= 0.01*Kchoc ;

* static friction coeff : 
* mu = 0.1 ;
* adh = mu ;
* stoianovici & hurmuzlu : plus longue barre : 
* Frequences des modes :
si (stoia) ;
lfind = prog 111. 361. 751. 1281. 1946. 2151. 2744. 3671. 4722. 5892. 6454. 7177. 8571. 10069. 10757. 11666. 13287.2 15046.3 15060. 16885.2 18798.9 19362.9 20778.5 22826.3 23665.8 24934.7 27099.5 27968.8 ; 
ltrac = lect 6 11 15 19 22 25 28 ; 
lnoe = lect 80 90 100 125 150 175 200 225 250 275 300 325 350 400 450 500 550 600 700 800 900 ;
lnoe = lnoe et (lect 10 * 1000) ;
* repsave = './data/stoia/' ;
* opti 'FTRA' './fig/stoia/modes.ps';
finsi ; 
si (manchette) ;
lfind = prog 109. 351. 721. 819. 1207. 1795. 2458. 2472. 3224. 4039. 4098. 4907. 5738. 5820. 6769. 7750. 8755. 9021. 9782. 10665. 10828. 11888. 12311. 12961. ;
ltrac = lect 4 7 11 13 18 20 23 ; 
lnoe = lect 100 150 200 225 250 275 300 325 350 375 400 425 450 475 500 550 600 650 700 800 900 1000 ;
* repsave = './data/manchette/' ;
* opti 'FTRA' (chai './fig/manchette/modes.ps' );
finsi ;
*# nnoeuds :
si (NMODE_ELA > 0) ;
lfind = extr lfind (lect 1 'PAS' 1 nmode_ela) ;
nnoeuds = 2*(extr lnoe nmode_ela) ;
lindmode = lect (dime lfind)*1 ; 
finsi ; 
* nnoeuds = maxi (lect 500 nnoeuds) ;
* nnoeuds = 1200 ;
* Position du centre de gravite : manchette ou stoianovici : 
 LG = (h/2.) ;
*
* Centre de rotation = P1 ci-dessous = origine (0. 0. 0.).
*
***** Temporel:
*# t :
T = 1. ;

*# n :
n = 6 ;

*# dte :
dte = 2.e-6 ;

*# nsort :
NSORT = 5 ;
*
NPASe = (ENTI 'PROCH' (T / DTe)) - 1 ;
tprog = prog 0. 'PAS' Dte 'NPAS' (NPASe + 1 ) ;
***** Base modale :
* rigide = vrai si presence de rotas rigides dans la base modale:
rigide = vrai ;
* Rotas rigides et modes elastiques:
*   - typmode = 1 : rota rig + ela
*   - typmode = 2 : rota rig seule
*   - typmode = 3 : ela only 
*
***** Conditions initiales:
* nutation initiale de la toupie (Castem: angles en degres!):


* Vitesses angulaires de rotation inititales ds le repere du solide:

*# wxini :
WXini = 0. ;
*# wyini :
WYini = 0. ;
*# wzini :
WZini = 0. ;

*# uxini :
uxini = 0. ;
*# uyini :
uyini = 0. ;
*# uzini :
uzini = 0. ;
*# vxini :
vxini = 0. ;
*# vyini :
vyini = 0. ;
*# vzini :
vzini = 0. ;

*# quat1 :
quat1 = 1. ;
*# quat2 :
quat2 = 0. ;
*# quat3 :
quat3 = 0. ;
*# quat4 :
quat4 = 0. ;

* opti donn 5 ;
* si reprise on ecrase theta_ini avec la fonction vect2quat :
si (reprise) ;
  nquat = (sqrt ((quat1**2) + (quat2**2) + (quat3**2) + (quat4**2))) ;
  quat1 = ( quat1 / nquat ) ;
  quat2 = ( quat2 / nquat ) ;
  quat3 = ( quat3 / nquat ) ;
  quat4 = ( quat4 / nquat ) ;
  nv = (sqrt ( (quat2**2) + (quat3**2) + (quat4**2))) ;
  theta = 2.*(asin nv) ;
  theta_ini_x = theta*(quat2/nv) ;
  theta_ini_y = theta*(quat3/nv) ;
  theta_ini_z = theta*(quat4/nv) ;
finsi ;

*# q1 :
 q1 = 0. ;
*# q1v :
 q1v = 0. ;
*# q2 :
 q2 = 0. ;
*# q2v :
 q2v = 0. ;
*# q3 :
 q3 = 0. ;
*# q3v :
 q3v = 0. ;
*# q4 :
 q4 = 0. ;
*# q4v :
 q4v = 0. ;
*# q5 :
 q5 = 0. ;
*# q5v :
 q5v = 0. ;

lqini = prog q1 q2 q3 q4 q5 ;
lqvini = prog q1v q2v q3v q4v q5v ;

* opti donn 5 ; 
*********************************************************************
*                            OPTIONS 
*********************************************************************
***** Figure:
* opti 'TRAC' PSC ; 
script = 'pendule_timo';
script = (chai script'_nmodes_'nmode_ela) ;
si stoia ;
script = (chai script'_stoia') ;
finsi ;
si manchette ;
script = (chai script'_manchette') ;
finsi ;
si (typmode ega 1) ;
script = (chai script'_ela') ;
finsi ;
si (typmode ega 2) ;
script = (chai script'_rigi') ;
finsi ;
si (rk4) ;
script = (chai script'_rk4') ;
algo = 'rk4' ;
finsi ;
si (nmb) ;
script = (chai script'_nmb') ;
algo = 'nmb' ;
finsi ;
si (sw) ;
script = (chai script'_sw') ;
algo = 'sw' ;
finsi ;
si xpinv ;
script = (chai script'_xpinv') ;
algo = (chai algo'_xpinv') ;
finsi ;
si linert ;
script = (chai script'_inert') ;
algo = (chai algo'_inert') ;
finsi ;

si limpact ;
  si (non (bamo <EG 1.e-10)) ;
    samo = (enti (log ((bamo))/(log 10.))) ;
    script = ( chai script'_bamo_'samo) ;
  sinon ;
    script = ( chai script'_bamo_'0) ;
  finsi ;
finsi ;
* on rajoute le pdt ;
script = (chai script'_dt_'dte) ;

repfig = './fig/' ;
repsave = './data/' ;
si (stoia) ;
  repfig = (chai repfig'stoia/') ;
  repsave = (chai repsave'stoia/') ;
finsi ;
si (manchette) ;
  repfig = (chai repfig'manchette/') ;
  repsave = (chai repsave'manchette/') ;
finsi ; 
si (trig) ;
  repfig = (chai   repfig'trig/') ;
  repsave = (chai repsave'trig/') ;
finsi ;
si (limpact) ;
  repfig = (chai repfig'impact/') ;
  repsave = (chai repsave'impact/') ;
sinon ;
  repfig = (chai repfig'no_impact/') ;
  repsave = (chai repsave'no_impact/') ;
finsi ;
si (linert) ;
  repfig = (chai repfig'inert/') ;
  repsave = (chai repsave'inert/') ;
  si lnorcomp ;
  repfig = (chai repfig'norcomp/') ;
  repsave = (chai repsave'norcomp/') ;
  finsi ;
  si lnortot ;
  repfig = (chai repfig'nortot/') ;
  repsave = (chai repsave'nortot/') ;
  finsi ;
  si lnormtot ;
  repfig = (chai repfig'normtot/') ;
  repsave = (chai repsave'normtot/') ;
  finsi ;
finsi ;
* on rajoute la valeur de xi :
repsave = (chai repsave'xi_'(enti (100.*xi))'/') ; 
* on rajoute la valeur de thini :
repsave = (chai repsave'thini_'(enti theta_ini_x)'/') ; 
* on rajoute la valeur de nmode_ela :
repsave = (chai repsave'nmode_'nmode_ela'/') ; 

* opti 'FTRA' (chai repfig script'.ps') ;
opti 'FTRA' (chai './fig/pendule_timo.ps') ;
opti 'SORT' (chai repsave script'.csv') ;

* on rajoute le pas de temps :
*
* Pour afficher les "IF (IIMPI.EQ.333) THEN WRITE(IOIMP,*)":
* opti impi 333;
* oeil1 = (5.*R) (5.*R) (0.5*h) ;
***** RECO totale voulue ?
RECOTOT = faux ;
EVOLRECO = vrai ;
FLVTK = faux ;
lanime = faux ;
* SI (RECOTOT EGA FAUX);
*   FLVTK = FAUX ;
* FINSI ;
*********************************************************************
*                            Maillage 
*********************************************************************
P1 = 0. 0. 0. ;
P2 = 0. 0. h ; 
* Centre de masse theorique:
G1 = 0. 0. LG ; 
***** Maillage: nombre d'element de la poutre:
 n1 = (enti (nnoeuds/2)) ;
 n2 = nnoeuds - n1 ; 
 L1 = d n1 P1 G1 ;
 L2 = d n2 G1 P2 ;
 L1 = L1 et l2 ;
 MESHPOU = L1 ;
*  OPTI 'TRAC' X ; 
*  TRAC 'QUAL' meshpou ;
*  OPTI 'TRAC' 'PSC' ;
 G1 = MESHPOU POIN 'PROC' G1 ;
* Utilisation de BARY: si le maillage est fidèle! (Pas le cas ici): 
* Cgrav = BARY MESHPOU ;
* G1 = MESHPOU POIN 'PROC' Cgrav ;
* Point d'observation le plus eloigne X,Y,Z >0: utile pour comp avec python
Pobs = p2 ;
list Pobs ;
*
*********************************************************************
*                            MODELE 
*********************************************************************
modpou = mode meshpou 'MECANIQUE' 'ELASTIQUE' 'TIMO' ;
* Remarque: l'axe x est l'axe de la poutre contrairement au maillage.
matpou = MATE modpou 'YOUN' eac 'NU' nuac 'RHO' rho_ac  'SECT' sectpou 'INRZ' IGy 'INRY' IGx 'TORS' IG ;
*
* matrice de raideur :
K = rigi modpou matpou ;
* matrice de masse:
M1 = mass modpou matpou ;
*********************************************************************
*                            check modele 
*********************************************************************
motgauss = mot 'MASSE' ;
section = EXCO 'SECT' 1 matpou ;
s_pou = (COOR meshpou 'CURV') ;
s_pou = CHAN 'CHAM' s_pou modpou motgauss 'SCALAIRE' ;
chaml_rho   = exco matpou 'RHO' 'SCAL' ;
chaml_rho = chan motgauss modpou chaml_rho 'SCALAIRE';
vmanch = (intg modpou section) ;
mmanch = vmanch*rho_ac ;
****************************************************************************
*                       Conditions limites 
****************************************************************************
CL1 = BLOQ 'DEPL' P1;
K = K et cl1 ; 
*********************************************************************
*                            CLs 
*********************************************************************
* On prend un point qui n appartient pas au plan (Oyz):
CLRX = BLOQ 'RY' 'RZ' meshpou;
CLRY = BLOQ 'RX' 'RZ' meshpou;
CLRZ = BLOQ 'RX' 'RY' meshpou;
* CLela = BLOQ 'RZ' meshpou ;
* CLela = BLOQ 'ROTA' p1 ;
CLelaX = BLOQ 'UX' meshpou ;
CLelaY = BLOQ 'UY' meshpou ;
KRX = K et CLRX ;
KRY = K et CLRY ;
KRZ = K et CLRZ ;
* KelaX = K ;
* KelaY = K ;
KelaX = K et clelaX ;
KelaY = K et clelaY ;
* Kela = K ;
*********************************************************************
*                          Calculs des modes: 
*********************************************************************
* defini plus haut: Nmode = 5 ;
Tmode_RX  = vibr 'IRAM' 0.5 1 KRX M1 ; 
Tmode_RY  = vibr 'IRAM' 0.5 1 KRY M1 ;
Tmode_RZ  = vibr 'IRAM' 0.5 1 KRZ M1 ;

nsauvini = 0 ;
si ((typmode ega 1) ou (typmode ega 3)) ;
* On teste egalement en presence de modes elastiques:
* Tmode_elaX = vibr 'IRAM' 20. nmode_ela KelaX M1 ;
* Tmode_elaY = vibr 'IRAM' 20. nmode_ela KelaY M1 ;
tmode_elax = vibr 'PROCHE' lfind lindmode kelax m1 ; 
tmode_elay = vibr 'PROCHE' lfind lindmode kelay m1 ; 
* 
tmodela = tmode_elaX ;

* Tmode_elaX = vibr 'IRAM' 20. 40 KelaX M1 ;
* opti trac x ;
* postvibr tmode_elaX ; 
* opti donn 5 ; 
*
si (ltronq) ;
* mail1 = extr (TMODE_ELAX . modes . 1 . deformee_modale) 'MAIL' 'NOMU';
tmodela = table 'BASE_MODALE' ;
tmodela . 'MODES' = table 'BASE_DE_MODES' ;
tmodela . 'MODES' . 'MAILLAGE' = meshpou ;
Tmodela . 'MAILLAGE_REPERE' = VIDE 'MAILLAGE' ;
numode = 1 ;
repe bmode (nmode_ela - ntronq) ;
* mode traction-compression ? a ne prendre qu'une fois en compte.
*  numdef = tmode_elax . modes . &bmode . 'NUMERO_MODE' ; 
*  lect1 = lect numdef ;
  lect1 = lect &bmode ;
  tracomp = dans lect1 ltrac ;
* on complete le maillage repere :
  Tmodela . 'MAILLAGE_REPERE' = (Tmodela . 'MAILLAGE_REPERE') et (Tmode_elax . 'MODES' . &bmode . 'POINT_REPERE') ;
* on renumerote :
  tmode_elax . modes . &bmode . 'NUMERO_MODE' = numode ; 
  tmodela . modes . numode = tmode_elax . modes . &bmode ;
  si (non tracomp) ;
* on complete le maillage repere :
  Tmodela . 'MAILLAGE_REPERE' = (Tmodela . 'MAILLAGE_REPERE') et (Tmode_elay . 'MODES' . &bmode . 'POINT_REPERE') ;
  tmode_elay . modes . &bmode . 'NUMERO_MODE' = (numode + 1) ; 
  tmodela . modes . (numode + 1) = tmode_elay . modes . &bmode ;
  numode = numode + 1 ;
  finsi ;
* incrementation de numode : 
  numode = numode + 1 ;
fin bmode ;
nsauvini = (numode - 1) ;
finsi ;

* postvibr Tmode_elaX ;
* postvibr Tmode_elaY ;

* opti trac x ;
postvibr Tmodela ;
* calcul des xmno : 
* nmno = (enti (2. * (nmode_ela - ntronq))) ;
* repe bmno nmno ;

* fin bmno ;
* opti donn 5 ; 
*
* fin si typmode = 1 ou 3 :
finsi ;

ptrep_RX =    Tmode_RX . 'MODES' . 1 . 'POINT_REPERE';
ptrep_RY =    Tmode_RY . 'MODES' . 1 . 'POINT_REPERE';
ptrep_RZ =    Tmode_RZ . 'MODES' . 1 . 'POINT_REPERE';
si ((typmode ega 1) ou (typmode ega 3)) ;
ptrep_ela_1 =    Tmodela . 'MODES' . 1 . 'POINT_REPERE';
ptrep_ela_2 =    Tmodela . 'MODES' . 2 . 'POINT_REPERE';
finsi ;
*********************************************************************
*                     Traitement rotations rigides: 
*********************************************************************
* Si l'on veut avoir les bons moments d'inertie (theoriques), 
* on les rentre manuellement en tant que masses generalisees:
     Tmode_RX . modes . 1 . masse_generalisee = Jx_G;
     Tmode_RY . modes . 1 . masse_generalisee = Jy_G;
     Tmode_RZ . modes . 1 . masse_generalisee = Jz_G;
* Pour les rotas rigides:
Tmode_RX . modes . 1 . frequence = 0. ;
Tmode_RY . modes . 1 . frequence = 0. ;
Tmode_RZ . modes . 1 . frequence = 0. ;
*
* Rq tenseur d'inertie : 
* Dans Simo & wong le tenseur d'inertie est déjà défini en la pointe de la toupie P1 !!
* On triche pour ne pas avoir de modif via MAJINERT: 
* CENTRE DE ROTATION = G1 ! 
Tmode_RX . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
Tmode_RX . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= G1 ;
Tmode_RX . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P1;
Tmode_RX . 'MODES' . 1 . 'MASSE'= M ;
Tmode_RX . 'MODES' . 1 . 'COMPOSANTE' = 'RX' ;

Tmode_RY . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
Tmode_RY . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= G1  ;
Tmode_RY . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P1 ;
Tmode_RY . 'MODES' . 1 . 'MASSE'= M ;
Tmode_RY . 'MODES' . 1 . 'COMPOSANTE' = 'RY' ;

Tmode_RZ . 'MODES' . 1  .'ROTATION_RIGIDE' = 'VRAI' ;
Tmode_RZ . 'MODES' . 1 . 'CENTRE_DE_GRAVITE'= G1  ;
Tmode_RZ . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= P1 ;
Tmode_RZ . 'MODES' . 1 . 'MASSE'= M ;
Tmode_RZ . 'MODES' . 1 . 'COMPOSANTE' = 'RZ' ;
*
si (trig) ;
  Tmode_RX . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= G1;
  Tmode_RY . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= G1 ;
  Tmode_RZ . 'MODES' . 1 . 'CENTRE_DE_ROTATION'= G1 ;

***** Translations : 
  PTREP_M_TX = 0. 0. 0. ;
  PTREP_M_TY = 0. 0. 0. ;
  PTREP_M_TZ = 0. 0. 0. ;

  TMODE_M_TX = TABLE 'BASE_MODALE' ; 
  TMODE_M_TX . MODES = TABLE 'BASE_DE_MODES' ;
  TMODE_M_TX . MODES . 'MAILLAGE' = meshpou ;
  TMODE_M_TX . MODES . 1 = TABLE 'MODE' ;

  TMODE_M_TY = TABLE 'BASE_MODALE' ; 
  TMODE_M_TY . MODES = TABLE 'BASE_DE_MODES' ;
  TMODE_M_TY . MODES . 'MAILLAGE' = meshpou ;
  TMODE_M_TY . MODES . 1 = TABLE 'MODE' ;

  TMODE_M_TZ = TABLE 'BASE_MODALE' ; 
  TMODE_M_TZ . MODES = TABLE 'BASE_DE_MODES' ;
  TMODE_M_TZ . MODES . 'MAILLAGE' = meshpou ;
  TMODE_M_TZ . MODES . 1 = TABLE 'MODE' ;

  TMODE_M_TX . MODES . 1 . POINT_REPERE = PTREP_M_TX ;
  TMODE_M_TY . MODES . 1 . POINT_REPERE = PTREP_M_TY ;
  TMODE_M_TZ . MODES . 1 . POINT_REPERE = PTREP_M_TZ ;

  TMODE_M_TX . MODES . 1 . MASSE_GENERALISEE = M ; 
  TMODE_M_TY . MODES . 1 . MASSE_GENERALISEE = M ;
  TMODE_M_TZ . MODES . 1 . MASSE_GENERALISEE = M ;

  TMODE_M_TX . MODES . 1 . FREQUENCE = 0. ;
  TMODE_M_TY . MODES . 1 . FREQUENCE = 0. ;
  TMODE_M_TZ . MODES . 1 . FREQUENCE = 0. ;

  TMODE_M_TX . MODES . 1 . 'TRANSLATION_RIGIDE' = 'VRAI' ;
  TMODE_M_TY . MODES . 1 . 'TRANSLATION_RIGIDE' = 'VRAI' ;
  TMODE_M_TZ . MODES . 1 . 'TRANSLATION_RIGIDE' = 'VRAI' ;

  TMODE_M_TX . MODES . 'MAILLAGE' = meshpou ;
  TMODE_M_TY . MODES . 'MAILLAGE' = meshpou ;
  TMODE_M_TZ . MODES . 'MAILLAGE' = meshpou ;

  DEF_TX = MANU 'CHPO' meshpou 6 'UX' 1. 'UY' 0. 'UZ' 0. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;
  DEF_TY = MANU 'CHPO' meshpou 6 'UX' 0. 'UY' 1. 'UZ' 0. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;
  DEF_TZ = MANU 'CHPO' meshpou 6 'UX' 0. 'UY' 0. 'UZ' 1. 'RX' 0. 'RY' 0. 'RZ' 0. 'NATUR' 'DIFFUS' ;

  TMODE_M_TX . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_TX ;
  TMODE_M_TY . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_TY ;
  TMODE_M_TZ . 'MODES' . 1  . 'DEFORMEE_MODALE' = DEF_TZ ;
finsi ;
*********************************************************************
*                     Assemblage des bases modales : 
*********************************************************************
*
* Rotas rigides et modes elastiques:
SI (typmode EGA 1);
* Tmode = (Tmode_RX et Tmode_RY et Tmode_RZ et Tmode_ela) ;
Tmode = (Tmodela et Tmode_RX et Tmode_RY et Tmode_RZ) ;
FINSI;
* Que rotas rigides:
SI (typmode EGA 2);
Tmode = (Tmode_RX et Tmode_RY et Tmode_RZ ) ;
FINSI;
* Que modes elastiques:
SI (typmode EGA 3);
Tmode = (Tmodela) ;
FINSI;
*
si (trig) ;
  Tmode = Tmode et (Tmode_m_tx et tmode_m_ty et tmode_m_tz) ;
finsi ;
************************************************************************
*     					Parametrage DYNE
************************************************************************
*** TSORT:
TSORT = TABL 'SORTIE';
TSORT . 'VARIABLE'  = tabl 'VARIABLE' ;
TSORT . 'VARIABLE' . 'TYPE_SORTIE'  = mot 'LISTREEL';
*
TSORT . 'VARIABLE' . 'ACCELERATION' = VRAI;

TSORT . 'VARIABLE' . 'VITESSE' = VRAI;
* MOMENT_CINETIQUE : 
TSORT . 'VARIABLE' . 'TRAVAIL_INTERIEUR' = VRAI ;
* ENERGIE_CINETIQUE :
TSORT . 'VARIABLE' . 'TRAVAIL_EXTERIEUR' = VRAI ;
*** TINI:
* Deplacements:
 U0_RX = MANU 'CHPO' ptrep_RX 'NATUR' 'DIFFUS' 'ALFA' (theta_ini_x*pi/180.) ;
 U0_RY = MANU 'CHPO' ptrep_RY 'NATUR' 'DIFFUS' 'ALFA' (theta_ini_y*pi/180.) ;
 U0_RZ = MANU 'CHPO' ptrep_RZ 'NATUR' 'DIFFUS' 'ALFA' (theta_ini_z*pi/180.) ;

*  U0_ela_1 = MANU 'CHPO' ptrep_ela_1 'NATUR' 'DIFFUS' 'ALFA' 0. ;
* U0_ela_2 = MANU 'CHPO' ptrep_ela_2 'NATUR' 'DIFFUS' 'ALFA' 0.;
* assemblage en 1 chpoint:
*  U0_P = (U0_RX et U0_RY et U0_RZ et U0_ela_1 et U0_ela_2);
 U0_P = (U0_RX et U0_RY et U0_RZ) ;
* U0_P = (U0_ela_1 et U0_ela_2) ;
* Vitesses:
si (typmode ega 3);
  WXini = 0. ;
  WYini = 0. ; 
  WZini = 0. ;
finsi;

 V0_PX = MANU 'CHPO' ptrep_RX 'NATUR' 'DIFFUS' 'ALFA' WXini ;
 V0_PY = MANU 'CHPO' ptrep_RY 'NATUR' 'DIFFUS' 'ALFA' WYini ;
 V0_PZ = MANU 'CHPO' ptrep_RZ 'NATUR' 'DIFFUS' 'ALFA' WZini ;
 V0_P = (V0_PX et V0_PY et V0_PZ);

si (trig) ;
** translations :
 U0_TX = MANU 'CHPO' PTREP_M_TX 'NATUR' 'DIFFUS' 'ALFA' UXINI ;
 U0_TY = MANU 'CHPO' PTREP_M_TY 'NATUR' 'DIFFUS' 'ALFA' UYINI ;
 U0_TZ = MANU 'CHPO' PTREP_M_TZ 'NATUR' 'DIFFUS' 'ALFA' UZINI ;
 V0_TX = MANU 'CHPO' PTREP_M_TX 'NATURE' 'DIFFUS' 'ALFA' VXini ;
 V0_TY = MANU 'CHPO' PTREP_M_TY 'NATURE' 'DIFFUS' 'ALFA' VYini ;
 V0_TZ = MANU 'CHPO' PTREP_M_TZ 'NATURE' 'DIFFUS' 'ALFA' VZini ;

 U0_P = (u0_p et U0_TX et U0_TY et U0_TZ) ;
 V0_P = (v0_p et V0_TX et V0_TY et V0_TZ) ;
**
finsi ;

* init coord modales si reprise :
 si ((typmode ega 1) et (reprise)) ;
  repe bqini nmode_ela ;
    ptrpi = tmodela . modes . &bqini . point_repere ; 
    ui =  MANU 'CHPO' ptrpi 'NATUR' 'DIFFUS' 'ALFA' (extr lqini &bqini) ;
    vi =  MANU 'CHPO' ptrpi 'NATUR' 'DIFFUS' 'ALFA' (extr lqvini &bqini) ;
    u0_p = u0_p et ui ;
    v0_p = v0_p et vi ;
  fin bqini ;
 finsi ;
* Table:
  TINI = tabl 'INITIAL';
  TINI . 'DEPLACEMENT' = U0_P;
  TINI . 'VITESSE'     = V0_P;
*
*** TCHAR:
TCHAR = TABL 'CHARGEMENT';
FPES   = FORC 'FZ' ((-1.)*(m*g)) G1;
FPESA = PJBA FPES Tmode ;

Fprog = prog (dime tprog)*1. ; 
evolF = evol 'ROSE' 'MANU' 't' tprog 'F' Fprog;
* DESS evolF 'TITRE' 'chargmt = f(t)' LEGE;
CHA_PES = CHAR 'FORC' FPES evolF ;
CHA_PESA = CHAR 'FORC' FPESA evolF ;

* Chargement introduit en base A et en base B:
  TCHAR .'BASE_A' = TABL;
  TCHAR .'BASE_A' = CHA_PESA;
  TCHAR .'BASE_B' = TABL;  
  TCHAR .'BASE_B' = CHA_PES;

* TODO: Determiner si le chargement doit reeelement etre exprime 
*                  en base A ET en base B.
*
***** TLIAI:
* Liaison fictive en G1 pour RECO: pour avoir appel a D2VLFB / 2.
* (appelees uniquement si (NLIAB.NE.0).

	 TL1  =  TABLE  'LIAISON_ELEMENTAIRE'    ;
	 TL1.'TYPE_LIAISON'  =  MOT 'POINT_PLAN' ;
	 TL1.'SUPPORT'       =  G1              ;
	 TL1.'RAIDEUR'       =  1.              ;
	 TL1.'NORMALE' = (poin 1. 0. 0.) ;
*    On prend volontairement un jeu demesure (liaison fictive):
	 TL1.'JEU'           =  10.              ;
*

*  Cchoc = 0.1*((M*Kchoc)**0.5) ;
	 TL2  =  TABLE  'LIAISON_ELEMENTAIRE'    ;
	 TL2 . 'TYPE_LIAISON'  =  MOT 'POINT_PLAN_FROTTEMENT' ;
	 TL2 . 'SUPPORT'       =  p2 ;
   si (trig) ;
	  TL2 . 'SUPPORT'       =  p1 ;
   finsi ;
	 TL2 . 'RAIDEUR'       =  Kchoc ;
   TL2 . 'COEFFICIENT_GLISSEMENT' = muk ; 
   TL2 . 'COEFFICIENT_ADHERENCE' = (0.1*muk) ; 
* 0 si friction uniquement
   TL2 . 'RAIDEUR_TANGENTIELLE' = (0.*Kchoc) ; 
   TL2 . 'AMORTISSEMENT_TANGENTIEL' = 0. ; 
	 TL2 . 'AMORTISSEMENT' =  Bamo ;
	 TL2 . 'NORMALE'       =  NORMALE_PPLAN ;
	 TL2 . 'JEU'           =  jeu1 ;

   TLIAI = TABLE 'LIAISON'   ;
   TTLB = TABLE 'LIAISON_B' ;
   TLIAI .'LIAISON_B' = TTLB  ;
   TTLB . 1 = TL1 ;
   si (limpact) ;
    TTLB . 2 = TL2 ;
*   sortie liaison point-plan :
    TSORL = TABLE 'LIAISON_B' ;
    TSORT . 'LIAISON_B' = TSORL ;
    TSTL2 = table ;
    TSTL2 . 'VITESSE_NORMALE' = VRAI ;
    TSTL2 . 'VITESSE_TANGENTIELLE' = VRAI ;
    TSTL2 . 'FORCE_DE_CHOC_NORMALE' = VRAI ;
    TSTL2 . 'FORCE_DE_CHOC_TANGENTIELLE' = VRAI ;
    TSTL2 . 'PUISSANCE_USURE_INSTANTANEE' = VRAI ;
    TSTL2 . 'UX' = VRAI ;
    TSTL2 . 'UY' = VRAI ;
    TSTL2 . 'UZ' = VRAI ;
    TSORL . TL2 = TSTL2 ; 
   finsi ;

* opti donn 5 ; 
************************************************************************
*     					Resolution DYNE
************************************************************************
*
* opti donn 5 ; 
'TEMP' 'ZERO' ;
si (sw) ;
  TRESU = DYNE 'DIFFERENCES_CENTREES' Tmode TLIAI TCHAR TINI TSORT NPASe DTe NSORT;
finsi ;
si (nmb) ;
  TRESU = DYNE 'NMB' Tmode TLIAI TCHAR TINI TSORT NPASe DTe NSORT;
finsi ;
si (rk4) ;
  TRESU = DYNE 'RKMK4' Tmode TLIAI TCHAR TINI TSORT NPASe DTe NSORT;
finsi ;
ctime = ('TEMP' 'ENTI' 'HORL') ;

* TRESU = DYNE 'DIFFERENCES_CENTREES' Tmode TLIAI TINI TSORT NPASe DTe NSORT;
*
tprog = TRESU . TEMPS_DE_SORTIE;
*
Nt = dime tprog;
*
* opti donn 5 ; 
************************************************************************
*     					POST TRAITEMENT
************************************************************************
*
************************************************************************
*     			Vitesses et accelerations angulaires
************************************************************************
SI (rigide EGA VRAI) ;
***** Recuperation des nouveaus ptreps associes aux rotas rigides:
ptrep_rig1 = Tmode . rotas . 1 . point_repere;
ptrep_rig2 = Tmode . rotas . 2 . point_repere;
ptrep_rig3 = Tmode . rotas . 3 . point_repere;
ptrep_rig4 = Tmode . rotas . 4 . point_repere;
***** Recuperation des vitesses angulaires de rotation;
W1 = tresu . vitesse . ptrep_rig1;
W2 = tresu . vitesse . ptrep_rig2;
W3 = tresu . vitesse . ptrep_rig3;
*
W1_ev = EVOL 'ROSE' MANU 't' tprog 'W1' W1;
W2_ev = EVOL 'VIOL' MANU 't' tprog 'W2' W2;
W3_ev = EVOL 'BLEU' MANU 't' tprog 'W3' W3;
*
TAB1 = TABLE ; 
TAB1 . 'TITRE' = TABLE ;
*
TAB1 . 'TITRE' . 1 = 'W1';
Dess (W1_ev) 'TITRE' 'W1 = f(t)' TAB1 'LEGE';
TAB1 . 'TITRE' . 1 = 'W2';
Dess (W2_ev) 'TITRE' 'W2 = f(t)' TAB1 'LEGE';
TAB1 . 'TITRE' . 1 = 'W3';
Dess (W3_ev) 'TITRE' 'W3 = f(t)' TAB1 'LEGE';
*
A1 = tresu . acceleration . ptrep_rig1;
A2 = tresu . acceleration . ptrep_rig2;
A3 = tresu . acceleration . ptrep_rig3;
*
* A1_ev = EVOL 'ROSE' MANU 't' tprog 'A1' A1;
* A2_ev = EVOL 'VIOL' MANU 't' tprog 'A2' A2;
* A3_ev = EVOL 'BLEU' MANU 't' tprog 'A3' A3;
*
*** Moment cinétique :
PI1 = tresu . TRAVAIL_INTERIEUR . ptrep_rig1;
PI2 = tresu . TRAVAIL_INTERIEUR . ptrep_rig2;
PI3 = tresu . TRAVAIL_INTERIEUR . ptrep_rig3;
*
* PI1_ev = EVOL 'ROSE' MANU 't' tprog 'PI1' PI1;
* PI2_ev = EVOL 'VIOL' MANU 't' tprog 'PI2' PI2;
* PI3_ev = EVOL 'BLEU' MANU 't' tprog 'PI3' PI3;
* TAB1 . 'TITRE' . 1 = 'PI1';
* Dess (PI1_ev) 'TITRE' 'PI1 = f(t)' TAB1 LEGE;
* TAB1 . 'TITRE' . 1 = 'PI2';
* Dess (PI2_ev) 'TITRE' 'PI2 = f(t)' TAB1 LEGE;
* TAB1 . 'TITRE' . 1 = 'PI3';
* Dess (PI3_ev) 'TITRE' 'PI3 = f(t)' TAB1 LEGE;
* TAB1 . 'TITRE' . 1 = 'PI1';
* TAB1 . 'TITRE' . 2 = 'PI2';
* TAB1 . 'TITRE' . 3 = 'PI3';
* Dess (PI3_ev et PI2_ev et PI3_ev) 'TITRE' 'PI = f(t)' TAB1 LEGE;
*
*** Energie cinetique :
EC1 = tresu . TRAVAIL_EXTERIEUR . ptrep_rig1 ;
* ECDEF =  tresu . travail_exterieur . ptrep_ela_1 ;
* EC1_ev = EVOL 'ROSE' MANU 't' tprog 'EC1' EC1 ;
* TAB1 . 'TITRE' . 1 = 'EC';
* Dess (EC1_ev) 'TITRE' 'EC = f(t)' TAB1 LEGE;
*
*** Energie de deformation :
EP1 = tresu . TRAVAIL_EXTERIEUR . ptrep_rig2 ;
* EP1_ev = EVOL 'ROSE' MANU 't' tprog 'EC1' EP1 ;
* TAB1 . 'TITRE' . 1 = 'EDEF';
* Dess (EP1_ev) 'TITRE' 'EDEF = f(t)' TAB1 LEGE;

*** Energie totale = hamiltonien :
ET1 = EC1 + EP1 ;
* ET1_ev = EVOL 'ROSE' MANU 't' tprog 'EC1' ET1 ;
* TAB1 . 'TITRE' . 1 = 'Etot';
* Dess (ET1_ev) 'TITRE' 'ET = f(t)' TAB1 LEGE;
FINSI;
*
************************************************************************
*     					RECO en tous les points
************************************************************************
Si (RECOTOT EGA VRAI) ;
	 UX1 = prog; 
	 UY1 = prog;
	 UZ1 = prog;
	 VX1 = prog; 
	 VY1 = prog;
	 VZ1 = prog;
   AX1 = prog; 
	 AY1 = prog;
	 AZ1 = prog;
REPE BRECO Nt;
      D1 =  RECO  TRESU  Tmode (extr tprog &BRECO) 'DEPL' ;
*       V1 =  RECO  TRESU  Tmode (extr tprog &BRECO) 'VITE' ;
      UX2 = EXTR D1 'UX' Pobs;
      UY2 = EXTR D1 'UY' Pobs;
	    UZ2 = EXTR D1 'UZ' Pobs;		
      UX1 = UX1 et UX2;
      UY1 = UY1 et UY2;
      UZ1 = UZ1 et UZ2;		  
FIN BRECO;
UX_ev = EVOL 'JAUN' MANU 't' tprog 'UX' UX1;
UY_ev = EVOL 'ORAN' MANU 't' tprog 'UY' UY1;
UZ_ev = EVOL 'ROUG' MANU 't' tprog 'UZ' UZ1;
TAB1 = TABL; TAB1 . 'TITRE' = TABL;
	TAB1 . 'TITRE' . 1 = 'UX';
Dess(UX_ev) 'TITRE' 'Depl = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'UY';
Dess(UY_ev) 'TITRE' 'Depl = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'UZ';
Dess(UZ_ev) 'TITRE' 'Depl = f(t)' TAB1 LEGE;
	TAB1 . 'TITRE' . 1 = 'UX';
	TAB1 . 'TITRE' . 2 = 'UY';	
	TAB1 . 'TITRE' . 3 = 'UZ';
Dess(UX_ev et UY_ev et UZ_ev) 'TITRE' 'recotot: Depl = f(t)' TAB1 LEGE;
* Vitesse:
REPE BRECOVITE Nt;
      VITE1 =  RECO  TRESU  Tmode (extr tprog &BRECOVITE) 'VITE' ;
      VX2 = EXTR VITE1 'UX' Pobs;
      VY2 = EXTR VITE1 'UY' Pobs;
	  VZ2 = EXTR VITE1 'UZ' Pobs;	
      VX1 = VX1 et VX2;
      VY1 = VY1 et VY2;
      VZ1 = VZ1 et VZ2;		  
FIN BRECOVITE ;
*
 VX_ev = EVOL 'JAUN' MANU 't' tprog 'VX' VX1;
 VY_ev = EVOL 'ORAN' MANU 't' tprog 'VY' VY1;
 VZ_ev = EVOL 'ROUG' MANU 't' tprog 'VZ' VZ1;
 	TAB1 . 'TITRE' . 1 = 'VX';
Dess(VX_ev) 'TITRE' 'recotot: VX = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'VY';
Dess(VY_ev) 'TITRE' 'recotot: VY = f(t)' TAB1 LEGE;
    TAB1 . 'TITRE' . 1 = 'VZ';
Dess(VZ_ev) 'TITRE' 'recotot: VZ = f(t)' TAB1 LEGE;
*
    TAB1 . 'TITRE' . 1 = 'VX';
	TAB1 . 'TITRE' . 2 = 'VY';	
	TAB1 . 'TITRE' . 3 = 'VZ';
Dess(VX_ev et VY_ev et VZ_ev) 'TITRE' 'Vitesse = f(t)' TAB1 LEGE;

* Acceleration:
*REPE BRECOACC Nt;
*      ACCE1 =  RECO  TRESU  Tmode (extr tprog &BRECOACC) 'ACCE' ;
*      AX2 = EXTR ACCE1 'UX' Pobs;
*      AY2 = EXTR ACCE1 'UY' Pobs;
*	    AZ2 = EXTR ACCE1 'UZ' Pobs;	
*      AX1 = AX1 et AX2;
*      AY1 = AY1 et AY2;
*      AZ1 = AZ1 et AZ2;		  
*FIN BRECOACC;
**
* AX_ev = EVOL 'JAUN' MANU 't' tprog 'AX' AX1;
* AY_ev = EVOL 'ORAN' MANU 't' tprog 'AY' AY1;
* AZ_ev = EVOL 'ROUG' MANU 't' tprog 'AZ' AZ1;
* 	TAB1 . 'TITRE' . 1 = 'AX';
*Dess(AX_ev) 'TITRE' 'recotot: AX = f(t)' TAB1 LEGE;
*    TAB1 . 'TITRE' . 1 = 'AY';
*Dess(AY_ev) 'TITRE' 'recotot: AY = f(t)' TAB1 LEGE;
*    TAB1 . 'TITRE' . 1 = 'AZ';
*Dess(AZ_ev) 'TITRE' 'recotot: AZ = f(t)' TAB1 LEGE;
*    TAB1 . 'TITRE' . 1 = 'AX';
*	TAB1 . 'TITRE' . 2 = 'AY';	
*	TAB1 . 'TITRE' . 3 = 'AZ';
*Dess(AX_ev et AY_ev et AZ_ev) 'TITRE' 'recotot: Acceleration = f(t)' TAB1 LEGE;
*
** formatT = chai '(D1.' (ABS NdecT) ')';
** list formatT;
** List T;
** Tmot = (chai 'FORMAT' (mot (F1.2)) T );
** list Tmot;
** DTe = (chai 'FORMAT' '(F1.2)' DTe);

* FIN RECOTOT:
FINSI;
*********************************************************************
*                     EVOL RECO au centre de gravite
*********************************************************************
*
SI (EVOLRECO EGA VRAI) ;
UXG_ev = EVOL 'JAUN' 'RECO' TRESU TMODE 'DEPL' G1 'UX' ;
UYG_ev = EVOL 'ORAN' 'RECO' TRESU TMODE 'DEPL' G1 'UY' ;
UZG_ev = EVOL 'ROUG' 'RECO' TRESU TMODE 'DEPL' G1 'UZ' ;
VXG_ev = EVOL 'JAUN' 'RECO' TRESU TMODE 'VITE' G1 'UX' ;
VYG_ev = EVOL 'ORAN' 'RECO' TRESU TMODE 'VITE' G1 'UY' ;
VZG_ev = EVOL 'ROUG' 'RECO' TRESU TMODE 'VITE' G1 'UZ' ;
AXG_ev = EVOL 'JAUN' 'RECO' TRESU TMODE 'ACCE' G1 'UX' ;
AYG_ev = EVOL 'ORAN' 'RECO' TRESU TMODE 'ACCE' G1 'UY' ;
AZG_ev = EVOL 'ROUG' 'RECO' TRESU TMODE 'ACCE' G1 'UZ' ;
*
UXG2 = EXTR UXG_EV 'ORDO' 1 ;
UYG2 = EXTR UYG_EV 'ORDO' 1 ;
UZG2 = EXTR UZG_EV 'ORDO' 1 ;
VXG2 = EXTR VXG_EV 'ORDO' 1 ;
VYG2 = EXTR VYG_EV 'ORDO' 1 ;
VZG2 = EXTR VZG_EV 'ORDO' 1 ;
AXG2 = EXTR AXG_EV 'ORDO' 1 ;
AYG2 = EXTR AYG_EV 'ORDO' 1 ;
AZG2 = EXTR AZG_EV 'ORDO' 1 ;
*
    TAB1 = TABL ; TAB1 . 'TITRE' = TABL ;
	TAB1 . 'TITRE' . 1 = 'UX_G';	
	TAB1 . 'TITRE' . 2 = 'UY_G';
	TAB1 . 'TITRE' . 3 = 'UZ_G';
Dess (UXG_ev et UYG_ev et UZG_ev) 'TITRE' 'EVOL RECO DEPL' TAB1 LEGE ;
*
	TAB1 . 'TITRE' . 1 = 'VX_G';	
	TAB1 . 'TITRE' . 2 = 'VY_G';
	TAB1 . 'TITRE' . 3 = 'VZ_G';
Dess (VXG_ev et VYG_ev et VZG_ev) 'TITRE' 'EVOL RECO VITE' TAB1 LEGE ;
*
    TAB1 . 'TITRE' . 1 = 'AX_G';
Dess (AXG_ev) 'TITRE' 'EVOL RECO AX' TAB1 LEGE ;
*
    TAB1 . 'TITRE' . 1 = 'AY_G';
Dess (AYG_ev) 'TITRE' 'EVOL RECO AY' TAB1 LEGE ;    
*
    TAB1 . 'TITRE' . 1 = 'AZ_G';
Dess (AZG_ev) 'TITRE' 'EVOL RECO AZ' TAB1 LEGE ;
*
	TAB1 . 'TITRE' . 1 = 'AX_G';	
	TAB1 . 'TITRE' . 2 = 'AY_G';
	TAB1 . 'TITRE' . 3 = 'AZ_G';
Dess (AXG_ev et AYG_ev et AZG_ev) 'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
* fin si evolreco :
FINSI ;
*
si (typmode ega 1) ;
q1 = tresu . deplacement . ptrep_ela_1 ;
q2 = tresu . deplacement . ptrep_ela_2 ;
* q3 = tresu . deplacement . ptrep_ela_3 ;
* q4 = tresu . deplacement . ptrep_ela_4 ;
q1_ev = EVOL 'ROUG' MANU 't' tprog 'q1' q1 ;
q2_ev = EVOL 'ROUG' MANU 't' tprog 'q1' q2 ;
* q3_ev = EVOL 'ROUG' MANU 't' tprog 'q1' q3 ;
* q4_ev = EVOL 'ROUG' MANU 't' tprog 'q1' q4 ;
TAB1 . 'TITRE' . 1 = 'q1';	
Dess q1_ev  'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
TAB1 . 'TITRE' . 1 = 'q2';	
Dess q2_ev  'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
* TAB1 . 'TITRE' . 1 = 'q3';	
* Dess q3_ev  'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
* TAB1 . 'TITRE' . 1 = 'q4';	
* Dess q4_ev  'TITRE' 'EVOL RECO ACCE' TAB1 LEGE ;
finsi ;

UXp1_ev = EVOL 'ROUG' 'RECO' TRESU tmode 'DEPL' p1 'UX' ;
UYp1_ev = EVOL 'VERT' 'RECO' TRESU tmode 'DEPL' p1 'UY' ;
UZp1_ev = EVOL 'BLEU' 'RECO' TRESU tmode 'DEPL' p1 'UZ' ;
TAB1 . 'TITRE' . 1 = 'uxp1';	
TAB1 . 'TITRE' . 2 = 'uyp1';	
TAB1 . 'TITRE' . 3 = 'uzp1';	
UXp1 = EXTR uxp1_ev 'ORDO' 1 ;
UYp1 = EXTR uyp1_ev 'ORDO' 1 ;
UZp1 = EXTR uzp1_ev 'ORDO' 1 ;
dess (uxp1_ev et uYp1_ev et uzp1_ev) 'TITRE' tab1 'P1' ;

UXp2_ev = EVOL 'ROUG' 'RECO' TRESU tmode 'DEPL' p2 'UX' ;
UYp2_ev = EVOL 'VERT' 'RECO' TRESU tmode 'DEPL' p2 'UY' ;
UZp2_ev = EVOL 'BLEU' 'RECO' TRESU tmode 'DEPL' p2 'UZ' ;
TAB1 . 'TITRE' . 1 = 'uxp2';	
TAB1 . 'TITRE' . 2 = 'uyp2';	
TAB1 . 'TITRE' . 3 = 'uzp2';	
UXp2 = EXTR uxp2_ev 'ORDO' 1 ;
UYp2 = EXTR uyp2_ev 'ORDO' 1 ;
UZp2 = EXTR uzp2_ev 'ORDO' 1 ;
dess (uxp2_ev et uYp2_ev et uzp2_ev) 'TITRE' tab1 'P2' ;
***************************************************************************
*                  SORTIE

*************************************************************************** sorties rotas rigides : 
TSORT = table ;
TSORT . 'dt' = table ;
TSORT . 'M' = table ;
TSORT . 'amor' = table ;
TSORT . 'algo' = table ;
TSORT . 'rigi' = table ;
TSORT . 'inert' = table ;
TSORT . 'thini' = table ;
TSORT . 'nnoe' = table ;
TSORT . 'nmode' = table ;
TSORT . 'lbar' = table ;
TSORT . 't' = table ;
TSORT . 'ctime' = table ;
TSORT . 'wx' = table ;
TSORT . 'wy' = table ;
TSORT . 'wz' = table ;
TSORT . 'dt' = prog (dime tprog)*dte ;
TSORT . 'M' = prog (dime tprog)*M ;
TSORT . 'amor' = prog (dime tprog)*bamo ;
TSORT . 'algo' = (mots (dime tprog)*algo) ;
TSORT . 'rigi' = lect (dime tprog)*irigi ;
TSORT . 'inert' = lect (dime tprog)*inert ;
TSORT . 'thini' = prog (dime tprog)*theta_ini_x ;
* TSORT . 'thini_y' = prog (dime tprog)*theta_ini_x ;
* TSORT . 'thini_z' = prog (dime tprog)*theta_ini_x ;
TSORT . 'nnoe' = lect (dime tprog)*nnoeuds ;
TSORT . 'nmode' = lect (dime tprog)*nsauvini ;
TSORT . 'lbar' = prog (dime tprog)*h ;
TSORT . 't' = tprog ;
TSORT . 'ctime' = (prog (dime tprog)*ctime) ;
TSORT . 'wx' = w1 ;
TSORT . 'wy' = w2 ;
TSORT . 'wz' = w3 ;
TSORT . 'ax' = table ;
TSORT . 'ay' = table ;
TSORT . 'az' = table ;
TSORT . 'ax' = a1 ;
TSORT . 'ay' = a2 ;
TSORT . 'az' = a3 ;
TSORT . 'pix' = table ;
TSORT . 'piy' = table ;
TSORT . 'piz' = table ;
TSORT . 'pix' = pi1 ;
TSORT . 'piy' = pi2 ;
TSORT . 'piz' = pi3 ;
TSORT . 'ec' = table ;
TSORT . 'ec' = ec1 ;
TSORT . 'edef' = table ;
TSORT . 'edef' = ep1 ;
TSORT . 'et' = table ;
TSORT . 'et' = et1 ;
TSORT . 'uxp1' = table ;
TSORT . 'uyp1' = table ;
TSORT . 'uzp1' = table ;
TSORT . 'uxp1' = uxp1 ;
TSORT . 'uyp1' = uyp1 ;
TSORT . 'uzp1' = uzp1 ;
TSORT . 'uxp2' = table ;
TSORT . 'uyp2' = table ;
TSORT . 'uzp2' = table ;
TSORT . 'uxp2' = uxp2 ;
TSORT . 'uyp2' = uyp2 ;
TSORT . 'uzp2' = uzp2 ;

TSORT . 'quat1' = table ;
TSORT . 'quat2' = table ;
TSORT . 'quat3' = table ;
TSORT . 'quat4' = table ;
TSORT . 'quat1' = tresu . deplacement . ptrep_rig1 ;
TSORT . 'quat2' = tresu . deplacement . ptrep_rig2 ;
TSORT . 'quat3' = tresu . deplacement . ptrep_rig3 ;
TSORT . 'quat4' = tresu . deplacement . ptrep_rig4 ;

ncolexce = 34 ; 

si reprise ;
* repe bsauvq nmode_ela ;
repe bsauvq nsauvini ;
  ptrpi = tmodela . modes . &bsauvq . point_repere ;  
  tsort . (chai 'q'&bsauvq)    = table ; 
  tsort . (chai 'q'&bsauvq'v') = table ;
  tsort . (chai 'q'&bsauvq) = tresu . deplacement . ptrpi ; 
  tsort . (chai 'q'&bsauvq'v') = tresu . vitesse . ptrpi ; 
  ncolexce = ncolexce + 2 ;
fin bsauvq ;
finsi ; 

si (limpact) ;
* Pusure durant les impacts : 
TSORT . 'pusure' = table ;
TSORT . 'fn' = table ;
TSORT . 'ft' = table ;
TSORT . 'vt' = table ;
TSORT . 'vn' = table ;
TSORT . 'uxpchoc' = table ;
TSORT . 'uypchoc' = table ;
TSORT . 'uzpchoc' = table ;
TSORT . 'pusure' = TRESU . TL2 . 'PUISSANCE_USURE_INSTANTANEE' ;
TSORT . 'vn' = TRESU . TL2 . 'VITESSE_NORMALE' ;
TSORT . 'vt' = TRESU . TL2 . 'VITESSE_TANGENTIELLE' ;
TSORT . 'fn' = TRESU . TL2 . 'FORCE_DE_CHOC_NORMALE' ;
TSORT . 'ft' = TRESU . TL2 . 'FORCE_DE_CHOC_TANGENTIELLE' ;
TSORT . 'uxpchoc' = TRESU . TL2 . 'UX' ;
TSORT . 'uypchoc' = TRESU . TL2 . 'UY' ;
TSORT . 'uzpchoc' = TRESU . TL2 . 'UZ' ;
ncolexce = ncolexce + 8 ;
finsi ;
*

* RECOTOT : 
SI (RECOTOT EGA VRAI) ;
TSORT . 'ux1' = table ;
TSORT . 'uy1' = table ;
TSORT . 'uz1' = table ;
TSORT . 'ux1' = ux1 ;
TSORT . 'uy1' = uy1 ;
TSORT . 'uz1' = uz1 ;
TSORT . 'vx1' = table ;
TSORT . 'vy1' = table ;
TSORT . 'vz1' = table ;
TSORT . 'vx1' = vx1 ;
TSORT . 'vy1' = vy1 ;
TSORT . 'vz1' = vz1 ;
*TSORT . 'ax1' = table ;
*TSORT . 'ay1' = table ;
*TSORT . 'az1' = table ;
*TSORT . 'ax1' = ax1 ;
*TSORT . 'ay1' = ay1 ;
*TSORT . 'az1' = az1 ;
ncolexce = ncolexce + 6 ;
FINSI ; 
* EVOLRECO :
SI (EVOLRECO EGA VRAI) ;
TSORT . 'uxg' = table ;
TSORT . 'uyg' = table ;
TSORT . 'uzg' = table ;
TSORT . 'uxg' = uxg2 ;
TSORT . 'uyg' = uyg2 ;
TSORT . 'uzg' = uzg2 ;
TSORT . 'vxg' = table ;
TSORT . 'vyg' = table ;
TSORT . 'vzg' = table ;
TSORT . 'vxg' = vxg2 ;
TSORT . 'vyg' = vyg2 ;
TSORT . 'vzg' = vzg2 ;
TSORT . 'axg' = table ;
TSORT . 'ayg' = table ;
TSORT . 'azg' = table ;
TSORT . 'axg' = axg2 ;
TSORT . 'ayg' = ayg2 ;
TSORT . 'azg' = azg2 ;
ncolexce = ncolexce + 9 ;
FINSI ; 
numode = 0 ;
repe bsauve (nsauvini) ;
  ptrpi = tmodela . modes . &bsauve . point_repere ;  
  tsort . (chai 'edef'&bsauve)    = table ; 
  tsort . (chai 'ec'&bsauve) = table ;
* tsort . (chai 'q'&bsauve'a') = table ;
  tsort . (chai 'edef'&bsauve)  = tresu . travail_interieur . ptrpi ; 
  tsort . (chai 'ec'&bsauve) = tresu . travail_exterieur . ptrpi ; 

* tsort . (chai 'q'&bsauve'a') = tresu . acceleration . ptrpi ; 
  ncolexce = ncolexce + 2 ;
fin bsauve ;

SORT 'EXCE' (TSORT) 'NCOL' ncolexce 'SEPA' 'VIRG' 'DIGI' 10 ;

* si (typmode ega 1) ;
* tsort . 'q1' = tresu . deplacement . ptrep_ela_1  ;
* ncolexce = ncolexce + 1 ;
* finsi ; 
********************************************************************

* si (manchette) ;
*   si (limpact) ;
*     OPTI 'SORT' (CHAI './data/impact/manchette/'script) ;
*   finsi ;
*   si (non limpact) ;
*     OPTI 'SORT' (CHAI './data/no_impact/manchette/'script) ;
*   finsi ;
* finsi ;

* si (stoia) ;
*   si (limpact) ;
*     OPTI 'SORT' (CHAI './data/impact/stoia/'script) ;
*   finsi ;
*   si (non limpact) ;
*     OPTI 'SORT' (CHAI './data/no_impact/stoia/'script) ;
*   finsi ;
* finsi ;


******************** VTK *****************************************
SI (FLVTK) ;
*   REPE BVTK (enti ((Nt)/10tprog (&BVTK)) 'DEPL';
*    D1 =  RECO  TRESU  Tmode (extr ..));
   Ndef = (enti (1.e-3/(nsort*dte))) ;
   Ndef = maxi (lect 1 Ndef) ;
   REPE BVTK (enti ((flott Nt)/(flott Ndef))) ;
*   REPE BVTK (Nt - 2);
    D1 =  RECO  TRESU  Tmode (extr tprog (Ndef*&BVTK)) 'DEPL';
    DEP2 = D1 exco (mots 'UX' 'UY' 'UZ') ;
*    DEP3 = CHAN 'CHAM' DEP2 mod1 'GRAVITE' ;
*    DEP4 = CHAN 'CHAM' DEP2 VOL1 ;
     T_I = (extr tprog &BVTK) ;
*    mess T_I ;
*    VOL2 = EXTR DEP2 'MAIL';
*    VOL3 = CHAN 'POI1' VOL1 ;
**** DEformees:
*     def1 = DEFO VOL1 DEP2 1. 'ROUG' ;
*     def0 = DEFO VOL1 DEP2 0. 'VERT' ;
*     def2 = def1 et def0 ;
*     TRAC def2 VOL1 ;
****
* OPTI 'SORT'  (chai 'depl_vtk/'script);
    OPTI 'SORT'  (chai 'depl_vtk/pendule_timo') ;
    SORT 'VTK' meshpou 'MAIL' DEP2 'DEPL' 'TEMP' T_I ;
   FIN BVTK ;
* FIN FLVTK:
FINSI ;

si lanime ;
  opti 'FTRA' (chai './fig/'script'_anime') ;
  maillage_vtk = (meshpou) ;
  Ndef = (enti (5.e-2/(nsort*dte))) ;
  Ndef = maxi (lect 1 Ndef) ;
  REPETER BOUC1 (enti ((flott Nt)/(flott Ndef)))   ;
    TT = EXTR tprog (&BOUC1*Ndef)         ;
    DEP1 = RECO TRESU tmode TT DEPL        ;
* DEF1 = DEFO maillage_vtk DEP1 500. (rep) 'BLEU'     ;
    DEF1 = DEFO DEP1 maillage_vtk 1. ;
* def1 = DEFO U1 (manchette et mailrep) 1. (rep) coul1 ;
    SI (&BOUC1 EGA 1) ;
      DEFTOT1 = DEF1 ; 
    SINON ;
      DEFTOT1= DEFTOT1 ET DEF1 ;
    FINSI                                   ;
  FIN BOUC1                              ;
  TRAC DEFTOT1 'ANIME'    ;
  MESS 'anime trace' ;
finsi ;
*
* opti donn 5 ; 

FIN ;
